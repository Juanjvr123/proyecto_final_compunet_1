/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./index.css":
/*!*******************!*\
  !*** ./index.css ***!
  \*******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !./node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !./node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !./node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !./node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!./node_modules/css-loader/dist/cjs.js!./index.css */ \"./node_modules/css-loader/dist/cjs.js!./index.css\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\n\n      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\n    \noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"] && _node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals ? _node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals : undefined);\n\n\n//# sourceURL=webpack://chat-web-client/./index.css?\n}");

/***/ }),

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _index_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.css */ \"./index.css\");\n/* harmony import */ var _src_router_routes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/router/routes.js */ \"./src/router/routes.js\");\n\n\nvar app = document.getElementById('app');\napp.innerHTML = '';\napp.appendChild(_src_router_routes_js__WEBPACK_IMPORTED_MODULE_1__.routes);\n\n//# sourceURL=webpack://chat-web-client/./index.js?\n}");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./index.css":
/*!*********************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./index.css ***!
  \*********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/css-loader/dist/runtime/noSourceMaps.js */ \"./node_modules/css-loader/dist/runtime/noSourceMaps.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `* {\r\n    margin: 0;\r\n    padding: 0;\r\n    box-sizing: border-box;\r\n}\r\n\r\nbody {\r\n    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\r\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\r\n    min-height: 100vh;\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\r\n}\r\n\r\n#app {\r\n    width: 100%;\r\n    max-width: 1200px;\r\n    min-height: 600px;\r\n    background: white;\r\n    border-radius: 15px;\r\n    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);\r\n    overflow: hidden;\r\n}\r\n\r\n/* Login Page */\r\n.login-container {\r\n    display: flex;\r\n    flex-direction: column;\r\n    justify-content: center;\r\n    align-items: center;\r\n    padding: 60px 40px;\r\n    min-height: 600px;\r\n}\r\n\r\n.login-container h1 {\r\n    font-size: 2.5rem;\r\n    color: #667eea;\r\n    margin-bottom: 20px;\r\n}\r\n\r\n.login-form {\r\n    width: 100%;\r\n    max-width: 400px;\r\n    display: flex;\r\n    flex-direction: column;\r\n    gap: 20px;\r\n}\r\n\r\n.login-form input {\r\n    padding: 15px 20px;\r\n    font-size: 1rem;\r\n    border: 2px solid #e0e0e0;\r\n    border-radius: 8px;\r\n    transition: border-color 0.3s;\r\n}\r\n\r\n.login-form input:focus {\r\n    outline: none;\r\n    border-color: #667eea;\r\n}\r\n\r\n.login-form button {\r\n    padding: 15px 20px;\r\n    font-size: 1.1rem;\r\n    font-weight: bold;\r\n    color: white;\r\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\r\n    border: none;\r\n    border-radius: 8px;\r\n    cursor: pointer;\r\n    transition: transform 0.2s, box-shadow 0.2s;\r\n}\r\n\r\n.login-form button:hover {\r\n    transform: translateY(-2px);\r\n    box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);\r\n}\r\n\r\n/* Chat Page */\r\n.chat-container {\r\n    display: flex;\r\n    height: 600px;\r\n}\r\n\r\n/* Sidebar */\r\n.sidebar {\r\n    width: 300px;\r\n    background: #f5f7fa;\r\n    border-right: 1px solid #e0e0e0;\r\n    display: flex;\r\n    flex-direction: column;\r\n}\r\n\r\n.sidebar-header {\r\n    padding: 20px;\r\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\r\n    color: white;\r\n}\r\n\r\n.sidebar-header h2 {\r\n    font-size: 1.3rem;\r\n    margin-bottom: 5px;\r\n}\r\n\r\n.sidebar-header p {\r\n    font-size: 0.9rem;\r\n    opacity: 0.9;\r\n}\r\n\r\n.sidebar-tabs {\r\n    display: flex;\r\n    border-bottom: 1px solid #e0e0e0;\r\n}\r\n\r\n.sidebar-tabs button {\r\n    flex: 1;\r\n    padding: 15px;\r\n    background: transparent;\r\n    border: none;\r\n    cursor: pointer;\r\n    font-weight: 600;\r\n    color: #666;\r\n    transition: all 0.3s;\r\n}\r\n\r\n.sidebar-tabs button.active {\r\n    color: #667eea;\r\n    border-bottom: 3px solid #667eea;\r\n}\r\n\r\n.sidebar-content {\r\n    flex: 1;\r\n    overflow-y: auto;\r\n    padding: 10px;\r\n}\r\n\r\n.user-item, .group-item {\r\n    padding: 15px;\r\n    margin-bottom: 5px;\r\n    border-radius: 8px;\r\n    cursor: pointer;\r\n    transition: background 0.2s;\r\n    display: flex;\r\n    align-items: center;\r\n    gap: 10px;\r\n}\r\n\r\n.user-item:hover, .group-item:hover {\r\n    background: #e8eaf6;\r\n}\r\n\r\n.user-item.active, .group-item.active {\r\n    background: #667eea;\r\n    color: white;\r\n}\r\n\r\n.user-avatar, .group-avatar {\r\n    width: 40px;\r\n    height: 40px;\r\n    border-radius: 50%;\r\n    background: #667eea;\r\n    color: white;\r\n    display: flex;\r\n    align-items: center;\r\n    justify-content: center;\r\n    font-weight: bold;\r\n    font-size: 1.2rem;\r\n}\r\n\r\n.user-info, .group-info {\r\n    flex: 1;\r\n}\r\n\r\n.user-name, .group-name {\r\n    font-weight: 600;\r\n    margin-bottom: 3px;\r\n}\r\n\r\n.user-status {\r\n    font-size: 0.85rem;\r\n    color: #666;\r\n}\r\n\r\n/* Chat Area */\r\n.chat-area {\r\n    flex: 1;\r\n    display: flex;\r\n    flex-direction: column;\r\n}\r\n\r\n.chat-header {\r\n    padding: 20px;\r\n    background: white;\r\n    border-bottom: 1px solid #e0e0e0;\r\n}\r\n\r\n.chat-header h3 {\r\n    font-size: 1.3rem;\r\n    color: #333;\r\n}\r\n\r\n.chat-messages {\r\n    flex: 1;\r\n    overflow-y: auto;\r\n    padding: 20px;\r\n    background: #fafbfc;\r\n}\r\n\r\n.message {\r\n    margin-bottom: 20px;\r\n    display: flex;\r\n    flex-direction: column;\r\n}\r\n\r\n.message.sent {\r\n    align-items: flex-end;\r\n}\r\n\r\n.message-header {\r\n    font-size: 0.85rem;\r\n    color: #666;\r\n    margin-bottom: 5px;\r\n}\r\n\r\n.message-bubble {\r\n    max-width: 60%;\r\n    padding: 12px 16px;\r\n    border-radius: 12px;\r\n    word-wrap: break-word;\r\n}\r\n\r\n.message.received .message-bubble {\r\n    background: white;\r\n    border: 1px solid #e0e0e0;\r\n}\r\n\r\n.message.sent .message-bubble {\r\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\r\n    color: white;\r\n}\r\n\r\n.message-time {\r\n    font-size: 0.75rem;\r\n    margin-top: 5px;\r\n    opacity: 0.7;\r\n}\r\n\r\n/* Chat Input */\r\n.chat-input {\r\n    padding: 20px;\r\n    background: white;\r\n    border-top: 1px solid #e0e0e0;\r\n    display: flex;\r\n    gap: 10px;\r\n}\r\n\r\n.chat-input input {\r\n    flex: 1;\r\n    padding: 12px 16px;\r\n    font-size: 1rem;\r\n    border: 2px solid #e0e0e0;\r\n    border-radius: 25px;\r\n    transition: border-color 0.3s;\r\n}\r\n\r\n.chat-input input:focus {\r\n    outline: none;\r\n    border-color: #667eea;\r\n}\r\n\r\n.chat-input button {\r\n    padding: 12px 30px;\r\n    font-weight: 600;\r\n    color: white;\r\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\r\n    border: none;\r\n    border-radius: 25px;\r\n    cursor: pointer;\r\n    transition: transform 0.2s;\r\n}\r\n\r\n.chat-input button:hover {\r\n    transform: scale(1.05);\r\n}\r\n\r\n/* New Group Modal */\r\n.modal {\r\n    position: fixed;\r\n    top: 0;\r\n    left: 0;\r\n    width: 100%;\r\n    height: 100%;\r\n    background: rgba(0, 0, 0, 0.5);\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\r\n    z-index: 1000;\r\n}\r\n\r\n.modal-content {\r\n    background: white;\r\n    padding: 30px;\r\n    border-radius: 15px;\r\n    width: 90%;\r\n    max-width: 400px;\r\n}\r\n\r\n.modal-content h3 {\r\n    margin-bottom: 20px;\r\n    color: #333;\r\n}\r\n\r\n.modal-content input {\r\n    width: 100%;\r\n    padding: 12px;\r\n    margin-bottom: 15px;\r\n    border: 2px solid #e0e0e0;\r\n    border-radius: 8px;\r\n}\r\n\r\n.modal-actions {\r\n    display: flex;\r\n    gap: 10px;\r\n    justify-content: flex-end;\r\n}\r\n\r\n.modal-actions button {\r\n    padding: 10px 20px;\r\n    border: none;\r\n    border-radius: 8px;\r\n    cursor: pointer;\r\n    font-weight: 600;\r\n}\r\n\r\n.btn-cancel {\r\n    background: #e0e0e0;\r\n    color: #666;\r\n}\r\n\r\n.btn-create {\r\n    background: #667eea;\r\n    color: white;\r\n}\r\n\r\n/* Scrollbar */\r\n::-webkit-scrollbar {\r\n    width: 8px;\r\n}\r\n\r\n::-webkit-scrollbar-track {\r\n    background: #f1f1f1;\r\n}\r\n\r\n::-webkit-scrollbar-thumb {\r\n    background: #888;\r\n    border-radius: 4px;\r\n}\r\n\r\n::-webkit-scrollbar-thumb:hover {\r\n    background: #555;\r\n}\r\n\r\n/* Create Group Modal */\r\n.group-modal-users {\r\n    max-height: 300px;\r\n    overflow-y: auto;\r\n    margin: 15px 0;\r\n    border: 2px solid #e0e0e0;\r\n    border-radius: 8px;\r\n    padding: 10px;\r\n}\r\n\r\n.user-checkbox-item {\r\n    display: flex;\r\n    align-items: center;\r\n    padding: 10px;\r\n    margin: 5px 0;\r\n    border-radius: 6px;\r\n    cursor: pointer;\r\n    transition: background 0.2s;\r\n}\r\n\r\n.user-checkbox-item:hover {\r\n    background: #f5f5f5;\r\n}\r\n\r\n.user-checkbox-item input[type=\"checkbox\"] {\r\n    margin-right: 12px;\r\n    width: 18px;\r\n    height: 18px;\r\n    cursor: pointer;\r\n}\r\n\r\n.user-checkbox-item label {\r\n    cursor: pointer;\r\n    flex: 1;\r\n    font-size: 0.95rem;\r\n    color: #333;\r\n}\r\n\r\n.group-modal-info {\r\n    font-size: 0.85rem;\r\n    color: #666;\r\n    margin-top: 10px;\r\n    text-align: center;\r\n}\r\n\r\n/* Voice Recording Button */\r\n.voice-btn {\r\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\r\n    color: white;\r\n    border: none;\r\n    border-radius: 50%;\r\n    width: 42px;\r\n    height: 42px;\r\n    font-size: 1.3rem;\r\n    cursor: pointer;\r\n    transition: all 0.3s ease;\r\n    display: flex;\r\n    align-items: center;\r\n    justify-content: center;\r\n    box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);\r\n    flex-shrink: 0;\r\n    margin-right: 8px;\r\n}\r\n\r\n.voice-btn:hover {\r\n    transform: scale(1.1);\r\n    box-shadow: 0 4px 12px rgba(102, 126, 234, 0.5);\r\n}\r\n\r\n.voice-btn:active {\r\n    transform: scale(0.95);\r\n}\r\n\r\n.voice-btn.recording {\r\n    background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);\r\n    animation: pulse 1.5s ease-in-out infinite;\r\n}\r\n\r\n@keyframes pulse {\r\n    0%, 100% {\r\n        transform: scale(1);\r\n        box-shadow: 0 2px 8px rgba(245, 87, 108, 0.3);\r\n    }\r\n    50% {\r\n        transform: scale(1.15);\r\n        box-shadow: 0 4px 16px rgba(245, 87, 108, 0.6);\r\n    }\r\n}\r\n\r\n/* Voice Note Messages */\r\n.message.voice-note {\r\n    margin-bottom: 20px;\r\n    display: flex;\r\n    flex-direction: column;\r\n}\r\n\r\n.message.voice-note.sent {\r\n    align-items: flex-end;\r\n}\r\n\r\n.message.voice-note.received {\r\n    align-items: flex-start;\r\n}\r\n\r\n.message.voice-note .message-bubble.voice-bubble {\r\n    max-width: 320px;\r\n    color: white;\r\n    padding: 12px 16px;\r\n    border-radius: 18px;\r\n    display: flex;\r\n    align-items: center;\r\n    gap: 12px;\r\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\r\n}\r\n\r\n.message.voice-note.sent .message-bubble.voice-bubble {\r\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\r\n}\r\n\r\n.message.voice-note.received .message-bubble.voice-bubble {\r\n    background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);\r\n}\r\n\r\n.voice-icon {\r\n    font-size: 1.8rem;\r\n    flex-shrink: 0;\r\n    line-height: 1;\r\n}\r\n\r\n.voice-content {\r\n    display: flex;\r\n    flex-direction: column;\r\n    gap: 2px;\r\n    flex: 1;\r\n    min-width: 0;\r\n}\r\n\r\n.voice-text {\r\n    font-size: 0.9rem;\r\n    font-weight: 500;\r\n}\r\n\r\n.voice-duration {\r\n    font-size: 0.75rem;\r\n    opacity: 0.85;\r\n}\r\n\r\n.play-audio-btn {\r\n    background: rgba(255, 255, 255, 0.25);\r\n    color: white;\r\n    border: none;\r\n    border-radius: 50%;\r\n    width: 40px;\r\n    height: 40px;\r\n    font-size: 1.2rem;\r\n    cursor: pointer;\r\n    transition: all 0.2s ease;\r\n    display: flex;\r\n    align-items: center;\r\n    justify-content: center;\r\n    flex-shrink: 0;\r\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\r\n}\r\n\r\n.play-audio-btn:hover:not(:disabled) {\r\n    background: rgba(255, 255, 255, 0.4);\r\n    transform: scale(1.1);\r\n}\r\n\r\n.play-audio-btn:active:not(:disabled) {\r\n    transform: scale(0.95);\r\n}\r\n\r\n.play-audio-btn:disabled {\r\n    opacity: 0.7;\r\n    cursor: not-allowed;\r\n}\r\n\r\n/* ========== LLAMADAS WEBRTC ========== */\r\n\r\n.call-btn {\r\n    background: #10b981;\r\n    color: white;\r\n    border: none;\r\n    border-radius: 50%;\r\n    width: 45px;\r\n    height: 45px;\r\n    font-size: 1.5rem;\r\n    cursor: pointer;\r\n    transition: all 0.3s ease;\r\n    box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);\r\n    margin-left: auto;\r\n}\r\n\r\n.call-btn:hover {\r\n    background: #059669;\r\n    transform: scale(1.1);\r\n    box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);\r\n}\r\n\r\n.call-btn:active {\r\n    transform: scale(0.95);\r\n}\r\n\r\n.call-container {\r\n    display: none;\r\n    flex-direction: column;\r\n    gap: 20px;\r\n    padding: 20px;\r\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\r\n    border-radius: 15px;\r\n    margin: 20px;\r\n    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);\r\n}\r\n\r\n.call-info {\r\n    text-align: center;\r\n    color: white;\r\n}\r\n\r\n.call-info h3 {\r\n    font-size: 1.5rem;\r\n    margin-bottom: 10px;\r\n}\r\n\r\n.call-status {\r\n    font-size: 0.9rem;\r\n    opacity: 0.9;\r\n    animation: pulse 2s infinite;\r\n}\r\n\r\n@keyframes pulse {\r\n    0%, 100% { opacity: 0.9; }\r\n    50% { opacity: 0.6; }\r\n}\r\n\r\n.call-videos {\r\n    display: flex;\r\n    gap: 20px;\r\n    justify-content: center;\r\n    flex-wrap: wrap;\r\n}\r\n\r\n.video-container {\r\n    position: relative;\r\n    background: #1f2937;\r\n    border-radius: 10px;\r\n    overflow: hidden;\r\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\r\n    flex: 1;\r\n    min-width: 250px;\r\n    max-width: 400px;\r\n}\r\n\r\n.video-container video {\r\n    width: 100%;\r\n    height: 100%;\r\n    object-fit: cover;\r\n    min-height: 200px;\r\n    background: #1f2937;\r\n}\r\n\r\n.video-container label {\r\n    position: absolute;\r\n    bottom: 10px;\r\n    left: 10px;\r\n    background: rgba(0, 0, 0, 0.7);\r\n    color: white;\r\n    padding: 5px 10px;\r\n    border-radius: 5px;\r\n    font-size: 0.85rem;\r\n    font-weight: 500;\r\n}\r\n\r\n.call-controls {\r\n    display: flex;\r\n    justify-content: center;\r\n    gap: 15px;\r\n}\r\n\r\n.hangup-btn {\r\n    background: #ef4444;\r\n    color: white;\r\n    border: none;\r\n    border-radius: 50px;\r\n    padding: 15px 30px;\r\n    font-size: 1rem;\r\n    font-weight: 600;\r\n    cursor: pointer;\r\n    transition: all 0.3s ease;\r\n    box-shadow: 0 4px 12px rgba(239, 68, 68, 0.4);\r\n    display: flex;\r\n    align-items: center;\r\n    gap: 8px;\r\n}\r\n\r\n.hangup-btn:hover {\r\n    background: #dc2626;\r\n    transform: translateY(-2px);\r\n    box-shadow: 0 6px 16px rgba(239, 68, 68, 0.5);\r\n}\r\n\r\n.hangup-btn:active {\r\n    transform: translateY(0);\r\n}\r\n\r\n/* ========== MODAL DE LLAMADA ENTRANTE ========== */\r\n\r\n.incoming-call-modal {\r\n    position: fixed;\r\n    top: 0;\r\n    left: 0;\r\n    width: 100%;\r\n    height: 100%;\r\n    z-index: 2000;\r\n    opacity: 0;\r\n    transition: opacity 0.3s ease;\r\n}\r\n\r\n.incoming-call-modal.show {\r\n    opacity: 1;\r\n}\r\n\r\n.incoming-call-overlay {\r\n    position: absolute;\r\n    top: 0;\r\n    left: 0;\r\n    width: 100%;\r\n    height: 100%;\r\n    background: rgba(0, 0, 0, 0.85);\r\n    backdrop-filter: blur(8px);\r\n}\r\n\r\n.incoming-call-card {\r\n    position: absolute;\r\n    top: 50%;\r\n    left: 50%;\r\n    transform: translate(-50%, -50%) scale(0.9);\r\n    background: linear-gradient(145deg, #ffffff 0%, #f8f9fa 100%);\r\n    border-radius: 25px;\r\n    padding: 50px 40px;\r\n    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);\r\n    text-align: center;\r\n    min-width: 350px;\r\n    transition: transform 0.3s ease;\r\n}\r\n\r\n.incoming-call-modal.show .incoming-call-card {\r\n    transform: translate(-50%, -50%) scale(1);\r\n}\r\n\r\n.incoming-call-avatar {\r\n    position: relative;\r\n    width: 120px;\r\n    height: 120px;\r\n    margin: 0 auto 25px;\r\n}\r\n\r\n.avatar-ring {\r\n    position: absolute;\r\n    top: -10px;\r\n    left: -10px;\r\n    width: 140px;\r\n    height: 140px;\r\n    border: 4px solid #10b981;\r\n    border-radius: 50%;\r\n    animation: ringPulse 2s infinite ease-in-out;\r\n}\r\n\r\n@keyframes ringPulse {\r\n    0%, 100% {\r\n        transform: scale(1);\r\n        opacity: 1;\r\n    }\r\n    50% {\r\n        transform: scale(1.1);\r\n        opacity: 0.7;\r\n    }\r\n}\r\n\r\n.avatar-circle {\r\n    width: 120px;\r\n    height: 120px;\r\n    border-radius: 50%;\r\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\r\n    display: flex;\r\n    align-items: center;\r\n    justify-content: center;\r\n    box-shadow: 0 8px 20px rgba(102, 126, 234, 0.4);\r\n}\r\n\r\n.avatar-initial {\r\n    font-size: 3rem;\r\n    font-weight: bold;\r\n    color: white;\r\n    text-transform: uppercase;\r\n}\r\n\r\n.incoming-call-name {\r\n    font-size: 2rem;\r\n    font-weight: 700;\r\n    color: #1f2937;\r\n    margin-bottom: 10px;\r\n}\r\n\r\n.incoming-call-text {\r\n    font-size: 1.1rem;\r\n    color: #6b7280;\r\n    margin-bottom: 35px;\r\n    animation: blink 1.5s infinite;\r\n}\r\n\r\n@keyframes blink {\r\n    0%, 100% { opacity: 1; }\r\n    50% { opacity: 0.5; }\r\n}\r\n\r\n.incoming-call-buttons {\r\n    display: flex;\r\n    gap: 20px;\r\n    justify-content: center;\r\n}\r\n\r\n.call-accept-btn,\r\n.call-reject-btn {\r\n    width: 140px;\r\n    padding: 18px 0;\r\n    border: none;\r\n    border-radius: 50px;\r\n    font-size: 1.1rem;\r\n    font-weight: 600;\r\n    cursor: pointer;\r\n    transition: all 0.3s ease;\r\n    display: flex;\r\n    align-items: center;\r\n    justify-content: center;\r\n    gap: 8px;\r\n    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);\r\n}\r\n\r\n.call-accept-btn {\r\n    background: linear-gradient(135deg, #10b981 0%, #059669 100%);\r\n    color: white;\r\n}\r\n\r\n.call-accept-btn:hover {\r\n    transform: translateY(-3px);\r\n    box-shadow: 0 6px 20px rgba(16, 185, 129, 0.5);\r\n}\r\n\r\n.call-reject-btn {\r\n    background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);\r\n    color: white;\r\n}\r\n\r\n.call-reject-btn:hover {\r\n    transform: translateY(-3px);\r\n    box-shadow: 0 6px 20px rgba(239, 68, 68, 0.5);\r\n}\r\n\r\n.call-accept-btn:active,\r\n.call-reject-btn:active {\r\n    transform: translateY(-1px);\r\n}\r\n\r\n.btn-icon {\r\n    font-size: 1.4rem;\r\n    line-height: 1;\r\n}\r\n\r\n/* Audio Indicators para llamadas WebSocket */\r\n.call-audio-indicators {\r\n    display: flex;\r\n    justify-content: space-around;\r\n    align-items: center;\r\n    padding: 30px;\r\n    gap: 40px;\r\n}\r\n\r\n.audio-indicator {\r\n    display: flex;\r\n    flex-direction: column;\r\n    align-items: center;\r\n    gap: 15px;\r\n}\r\n\r\n.audio-wave {\r\n    display: flex;\r\n    gap: 5px;\r\n    align-items: center;\r\n    height: 60px;\r\n}\r\n\r\n.audio-wave span {\r\n    width: 6px;\r\n    height: 20px;\r\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\r\n    border-radius: 3px;\r\n    display: inline-block;\r\n}\r\n\r\n.audio-wave.remote span {\r\n    background: linear-gradient(135deg, #10b981 0%, #059669 100%);\r\n}\r\n\r\n@keyframes wave {\r\n    0%, 100% {\r\n        height: 20px;\r\n    }\r\n    50% {\r\n        height: 50px;\r\n    }\r\n}\r\n\r\n.audio-indicator label {\r\n    font-size: 0.95rem;\r\n    color: #666;\r\n    font-weight: 500;\r\n}\r\n`, \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://chat-web-client/./index.css?./node_modules/css-loader/dist/cjs.js\n}");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("{\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = [];\n\n  // return the list of modules as css string\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n      content += cssWithMappingToString(item);\n      if (needLayer) {\n        content += \"}\";\n      }\n      if (item[2]) {\n        content += \"}\";\n      }\n      if (item[4]) {\n        content += \"}\";\n      }\n      return content;\n    }).join(\"\");\n  };\n\n  // import a list of modules into the list\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n    var alreadyImportedModules = {};\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n      list.push(item);\n    }\n  };\n  return list;\n};\n\n//# sourceURL=webpack://chat-web-client/./node_modules/css-loader/dist/runtime/api.js?\n}");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/noSourceMaps.js":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/noSourceMaps.js ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";
eval("{\n\nmodule.exports = function (i) {\n  return i[1];\n};\n\n//# sourceURL=webpack://chat-web-client/./node_modules/css-loader/dist/runtime/noSourceMaps.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Glacier2/Glacier2.js":
/*!***************************************************!*\
  !*** ./node_modules/ice/src/Glacier2/Glacier2.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Glacier2/PermissionsVerifier */ \"./node_modules/ice/src/Glacier2/PermissionsVerifier.js\");\n__webpack_require__(/*! ../Glacier2/Router */ \"./node_modules/ice/src/Glacier2/Router.js\");\n__webpack_require__(/*! ../Glacier2/SSLInfo */ \"./node_modules/ice/src/Glacier2/SSLInfo.js\");\n__webpack_require__(/*! ../Glacier2/Session */ \"./node_modules/ice/src/Glacier2/Session.js\");\nmodule.exports.Glacier2 = _ModuleRegistry.module(\"Glacier2\");\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Glacier2/Glacier2.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Glacier2/PermissionsVerifier.js":
/*!**************************************************************!*\
  !*** ./node_modules/ice/src/Glacier2/PermissionsVerifier.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `PermissionsVerifier.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nvar _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\nvar Glacier2 = (__webpack_require__(/*! ../Glacier2/SSLInfo */ \"./node_modules/ice/src/Glacier2/SSLInfo.js\").Glacier2);\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\");\n__webpack_require__(/*! ../Ice/ObjectPrx */ \"./node_modules/ice/src/Ice/ObjectPrx.js\");\n__webpack_require__(/*! ../Ice/Operation */ \"./node_modules/ice/src/Ice/Operation.js\");\n__webpack_require__(/*! ../Ice/Exception */ \"./node_modules/ice/src/Ice/Exception.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\nvar Ice = _ModuleRegistry.module(\"Ice\");\nvar Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n\n/**\n * This exception is raised if a client is denied the ability to create\n * a session with the router.\n *\n **/\nGlacier2.PermissionDeniedException = /*#__PURE__*/function (_Ice$UserException) {\n  \"use strict\";\n\n  function _class() {\n    var _this;\n    var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class);\n    _this = _callSuper(this, _class, [_cause]);\n    _this.reason = reason;\n    return _this;\n  }\n  _inherits(_class, _Ice$UserException);\n  return _createClass(_class, [{\n    key: \"_mostDerivedType\",\n    value: function _mostDerivedType() {\n      return Glacier2.PermissionDeniedException;\n    }\n  }, {\n    key: \"_writeMemberImpl\",\n    value: function _writeMemberImpl(ostr) {\n      ostr.writeString(this.reason);\n    }\n  }, {\n    key: \"_readMemberImpl\",\n    value: function _readMemberImpl(istr) {\n      this.reason = istr.readString();\n    }\n  }], [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.UserException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Glacier2::PermissionDeniedException\";\n    }\n  }]);\n}(Ice.UserException);\nSlice.PreservedUserException(Glacier2.PermissionDeniedException);\nvar iceC_Glacier2_PermissionsVerifier_ids = [\"::Glacier2::PermissionsVerifier\", \"::Ice::Object\"];\n\n/**\n * The Glacier2 permissions verifier. This is called through the\n * process of establishing a session.\n *\n * @see Router\n *\n **/\nGlacier2.PermissionsVerifier = /*#__PURE__*/function (_Ice$Object) {\n  \"use strict\";\n\n  function _class2() {\n    _classCallCheck(this, _class2);\n    return _callSuper(this, _class2, arguments);\n  }\n  _inherits(_class2, _Ice$Object);\n  return _createClass(_class2);\n}(Ice.Object);\nGlacier2.PermissionsVerifierPrx = /*#__PURE__*/function (_Ice$ObjectPrx) {\n  \"use strict\";\n\n  function _class3() {\n    _classCallCheck(this, _class3);\n    return _callSuper(this, _class3, arguments);\n  }\n  _inherits(_class3, _Ice$ObjectPrx);\n  return _createClass(_class3);\n}(Ice.ObjectPrx);\nSlice.defineOperations(Glacier2.PermissionsVerifier, Glacier2.PermissionsVerifierPrx, iceC_Glacier2_PermissionsVerifier_ids, 0, {\n  \"checkPermissions\": [, 2, 1, 2, [1], [[7], [7]], [[7]], [Glacier2.PermissionDeniedException],,]\n});\nvar iceC_Glacier2_SSLPermissionsVerifier_ids = [\"::Glacier2::SSLPermissionsVerifier\", \"::Ice::Object\"];\n\n/**\n * The SSL Glacier2 permissions verifier. This is called through the\n * process of establishing a session.\n *\n * @see Router\n *\n **/\nGlacier2.SSLPermissionsVerifier = /*#__PURE__*/function (_Ice$Object2) {\n  \"use strict\";\n\n  function _class4() {\n    _classCallCheck(this, _class4);\n    return _callSuper(this, _class4, arguments);\n  }\n  _inherits(_class4, _Ice$Object2);\n  return _createClass(_class4);\n}(Ice.Object);\nGlacier2.SSLPermissionsVerifierPrx = /*#__PURE__*/function (_Ice$ObjectPrx2) {\n  \"use strict\";\n\n  function _class5() {\n    _classCallCheck(this, _class5);\n    return _callSuper(this, _class5, arguments);\n  }\n  _inherits(_class5, _Ice$ObjectPrx2);\n  return _createClass(_class5);\n}(Ice.ObjectPrx);\nSlice.defineOperations(Glacier2.SSLPermissionsVerifier, Glacier2.SSLPermissionsVerifierPrx, iceC_Glacier2_SSLPermissionsVerifier_ids, 0, {\n  \"authorize\": [, 2, 1, 2, [1], [[Glacier2.SSLInfo]], [[7]], [Glacier2.PermissionDeniedException],,]\n});\n/* slice2js browser-bundle-skip */\nexports.Glacier2 = Glacier2;\n/* slice2js browser-bundle-skip-end */\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Glacier2/PermissionsVerifier.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Glacier2/Router.js":
/*!*************************************************!*\
  !*** ./node_modules/ice/src/Glacier2/Router.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `Router.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nvar _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Glacier2/Session */ \"./node_modules/ice/src/Glacier2/Session.js\");\n__webpack_require__(/*! ../Glacier2/PermissionsVerifier */ \"./node_modules/ice/src/Glacier2/PermissionsVerifier.js\");\nvar Glacier2 = _ModuleRegistry.module(\"Glacier2\");\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\");\n__webpack_require__(/*! ../Ice/ObjectPrx */ \"./node_modules/ice/src/Ice/ObjectPrx.js\");\n__webpack_require__(/*! ../Ice/Operation */ \"./node_modules/ice/src/Ice/Operation.js\");\n__webpack_require__(/*! ../Ice/Exception */ \"./node_modules/ice/src/Ice/Exception.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\n__webpack_require__(/*! ../Ice/Router */ \"./node_modules/ice/src/Ice/Router.js\");\nvar Ice = _ModuleRegistry.module(\"Ice\");\nvar Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n\n/**\n * This exception is raised if a client tries to destroy a session\n * with a router, but no session exists for the client.\n *\n * @see Router#destroySession\n *\n **/\nGlacier2.SessionNotExistException = /*#__PURE__*/function (_Ice$UserException) {\n  \"use strict\";\n\n  function _class() {\n    var _cause = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    _classCallCheck(this, _class);\n    return _callSuper(this, _class, [_cause]);\n  }\n  _inherits(_class, _Ice$UserException);\n  return _createClass(_class, [{\n    key: \"_mostDerivedType\",\n    value: function _mostDerivedType() {\n      return Glacier2.SessionNotExistException;\n    }\n  }], [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.UserException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Glacier2::SessionNotExistException\";\n    }\n  }]);\n}(Ice.UserException);\nvar iceC_Glacier2_Router_ids = [\"::Glacier2::Router\", \"::Ice::Object\", \"::Ice::Router\"];\n\n/**\n * The Glacier2 specialization of the <code>Ice::Router</code> interface.\n *\n **/\nGlacier2.Router = /*#__PURE__*/function (_Ice$Object) {\n  \"use strict\";\n\n  function _class2() {\n    _classCallCheck(this, _class2);\n    return _callSuper(this, _class2, arguments);\n  }\n  _inherits(_class2, _Ice$Object);\n  return _createClass(_class2, null, [{\n    key: \"_iceImplements\",\n    get: function get() {\n      return [Ice.Router];\n    }\n  }]);\n}(Ice.Object);\nGlacier2.RouterPrx = /*#__PURE__*/function (_Ice$ObjectPrx) {\n  \"use strict\";\n\n  function _class3() {\n    _classCallCheck(this, _class3);\n    return _callSuper(this, _class3, arguments);\n  }\n  _inherits(_class3, _Ice$ObjectPrx);\n  return _createClass(_class3, null, [{\n    key: \"_implements\",\n    get: function get() {\n      return [Ice.RouterPrx];\n    }\n  }]);\n}(Ice.ObjectPrx);\nSlice.defineOperations(Glacier2.Router, Glacier2.RouterPrx, iceC_Glacier2_Router_ids, 0, {\n  \"getCategoryForClient\": [, 2, 1,, [7],,,,,],\n  \"createSession\": [,,, 2, [\"Glacier2.SessionPrx\"], [[7], [7]],, [Glacier2.CannotCreateSessionException, Glacier2.PermissionDeniedException],,],\n  \"createSessionFromSecureConnection\": [,,, 2, [\"Glacier2.SessionPrx\"],,, [Glacier2.CannotCreateSessionException, Glacier2.PermissionDeniedException],,],\n  \"refreshSession\": [,,,,,,, [Glacier2.SessionNotExistException],,],\n  \"destroySession\": [,,,,,,, [Glacier2.SessionNotExistException],,],\n  \"getSessionTimeout\": [, 2, 1,, [4],,,,,],\n  \"getACMTimeout\": [, 2, 1,, [3],,,,,]\n});\n/* slice2js browser-bundle-skip */\nexports.Glacier2 = Glacier2;\n/* slice2js browser-bundle-skip-end */\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Glacier2/Router.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Glacier2/SSLInfo.js":
/*!**************************************************!*\
  !*** ./node_modules/ice/src/Glacier2/SSLInfo.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `SSLInfo.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nvar _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Struct */ \"./node_modules/ice/src/Ice/Struct.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\n__webpack_require__(/*! ../Ice/BuiltinSequences */ \"./node_modules/ice/src/Ice/BuiltinSequences.js\");\nvar Ice = _ModuleRegistry.module(\"Ice\");\nvar Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n/* slice2js browser-bundle-skip */\n\nvar Glacier2 = _ModuleRegistry.module(\"Glacier2\");\n/* slice2js browser-bundle-skip-end */\n\n/**\n * Information taken from an SSL connection used for permissions\n * verification.\n *\n * @see PermissionsVerifier\n *\n **/\nGlacier2.SSLInfo = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function _class() {\n    var remoteHost = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var remotePort = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var localHost = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n    var localPort = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    var cipher = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : \"\";\n    var certs = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n    _classCallCheck(this, _class);\n    this.remoteHost = remoteHost;\n    this.remotePort = remotePort;\n    this.localHost = localHost;\n    this.localPort = localPort;\n    this.cipher = cipher;\n    this.certs = certs;\n  }\n  return _createClass(_class, [{\n    key: \"_write\",\n    value: function _write(ostr) {\n      ostr.writeString(this.remoteHost);\n      ostr.writeInt(this.remotePort);\n      ostr.writeString(this.localHost);\n      ostr.writeInt(this.localPort);\n      ostr.writeString(this.cipher);\n      Ice.StringSeqHelper.write(ostr, this.certs);\n    }\n  }, {\n    key: \"_read\",\n    value: function _read(istr) {\n      this.remoteHost = istr.readString();\n      this.remotePort = istr.readInt();\n      this.localHost = istr.readString();\n      this.localPort = istr.readInt();\n      this.cipher = istr.readString();\n      this.certs = Ice.StringSeqHelper.read(istr);\n    }\n  }], [{\n    key: \"minWireSize\",\n    get: function get() {\n      return 12;\n    }\n  }]);\n}();\nSlice.defineStruct(Glacier2.SSLInfo, true, true);\n/* slice2js browser-bundle-skip */\nexports.Glacier2 = Glacier2;\n/* slice2js browser-bundle-skip-end */\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Glacier2/SSLInfo.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Glacier2/Session.js":
/*!**************************************************!*\
  !*** ./node_modules/ice/src/Glacier2/Session.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `Session.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nvar _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\nvar Glacier2 = (__webpack_require__(/*! ../Glacier2/SSLInfo */ \"./node_modules/ice/src/Glacier2/SSLInfo.js\").Glacier2);\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\");\n__webpack_require__(/*! ../Ice/ObjectPrx */ \"./node_modules/ice/src/Ice/ObjectPrx.js\");\n__webpack_require__(/*! ../Ice/Operation */ \"./node_modules/ice/src/Ice/Operation.js\");\n__webpack_require__(/*! ../Ice/Exception */ \"./node_modules/ice/src/Ice/Exception.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\n__webpack_require__(/*! ../Ice/BuiltinSequences */ \"./node_modules/ice/src/Ice/BuiltinSequences.js\");\n__webpack_require__(/*! ../Ice/Identity */ \"./node_modules/ice/src/Ice/Identity.js\");\nvar Ice = _ModuleRegistry.module(\"Ice\");\nvar Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n\n/**\n * This exception is raised if an attempt to create a new session failed.\n *\n **/\nGlacier2.CannotCreateSessionException = /*#__PURE__*/function (_Ice$UserException) {\n  \"use strict\";\n\n  function _class() {\n    var _this;\n    var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class);\n    _this = _callSuper(this, _class, [_cause]);\n    _this.reason = reason;\n    return _this;\n  }\n  _inherits(_class, _Ice$UserException);\n  return _createClass(_class, [{\n    key: \"_mostDerivedType\",\n    value: function _mostDerivedType() {\n      return Glacier2.CannotCreateSessionException;\n    }\n  }, {\n    key: \"_writeMemberImpl\",\n    value: function _writeMemberImpl(ostr) {\n      ostr.writeString(this.reason);\n    }\n  }, {\n    key: \"_readMemberImpl\",\n    value: function _readMemberImpl(istr) {\n      this.reason = istr.readString();\n    }\n  }], [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.UserException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Glacier2::CannotCreateSessionException\";\n    }\n  }]);\n}(Ice.UserException);\nSlice.PreservedUserException(Glacier2.CannotCreateSessionException);\nvar iceC_Glacier2_Session_ids = [\"::Glacier2::Session\", \"::Ice::Object\"];\n\n/**\n * A client-visible session object, which is tied to the lifecycle of a {@link Router}.\n *\n * @see Router\n * @see SessionManager\n *\n **/\nGlacier2.Session = /*#__PURE__*/function (_Ice$Object) {\n  \"use strict\";\n\n  function _class2() {\n    _classCallCheck(this, _class2);\n    return _callSuper(this, _class2, arguments);\n  }\n  _inherits(_class2, _Ice$Object);\n  return _createClass(_class2);\n}(Ice.Object);\nGlacier2.SessionPrx = /*#__PURE__*/function (_Ice$ObjectPrx) {\n  \"use strict\";\n\n  function _class3() {\n    _classCallCheck(this, _class3);\n    return _callSuper(this, _class3, arguments);\n  }\n  _inherits(_class3, _Ice$ObjectPrx);\n  return _createClass(_class3);\n}(Ice.ObjectPrx);\nSlice.defineOperations(Glacier2.Session, Glacier2.SessionPrx, iceC_Glacier2_Session_ids, 0, {\n  \"destroy\": [,,,,,,,,,]\n});\nvar iceC_Glacier2_StringSet_ids = [\"::Glacier2::StringSet\", \"::Ice::Object\"];\n\n/**\n * An object for managing the set of identity constraints for specific\n * parts of object identity on a\n * {@link Session}.\n *\n * @see Session\n * @see SessionControl\n *\n **/\nGlacier2.StringSet = /*#__PURE__*/function (_Ice$Object2) {\n  \"use strict\";\n\n  function _class4() {\n    _classCallCheck(this, _class4);\n    return _callSuper(this, _class4, arguments);\n  }\n  _inherits(_class4, _Ice$Object2);\n  return _createClass(_class4);\n}(Ice.Object);\nGlacier2.StringSetPrx = /*#__PURE__*/function (_Ice$ObjectPrx2) {\n  \"use strict\";\n\n  function _class5() {\n    _classCallCheck(this, _class5);\n    return _callSuper(this, _class5, arguments);\n  }\n  _inherits(_class5, _Ice$ObjectPrx2);\n  return _createClass(_class5);\n}(Ice.ObjectPrx);\nSlice.defineOperations(Glacier2.StringSet, Glacier2.StringSetPrx, iceC_Glacier2_StringSet_ids, 0, {\n  \"add\": [, 2, 2,,, [[\"Ice.StringSeqHelper\"]],,,,],\n  \"remove\": [, 2, 2,,, [[\"Ice.StringSeqHelper\"]],,,,],\n  \"get\": [, 2, 2,, [\"Ice.StringSeqHelper\"],,,,,]\n});\nvar iceC_Glacier2_IdentitySet_ids = [\"::Glacier2::IdentitySet\", \"::Ice::Object\"];\n\n/**\n * An object for managing the set of object identity constraints on a\n * {@link Session}.\n *\n * @see Session\n * @see SessionControl\n *\n **/\nGlacier2.IdentitySet = /*#__PURE__*/function (_Ice$Object3) {\n  \"use strict\";\n\n  function _class6() {\n    _classCallCheck(this, _class6);\n    return _callSuper(this, _class6, arguments);\n  }\n  _inherits(_class6, _Ice$Object3);\n  return _createClass(_class6);\n}(Ice.Object);\nGlacier2.IdentitySetPrx = /*#__PURE__*/function (_Ice$ObjectPrx3) {\n  \"use strict\";\n\n  function _class7() {\n    _classCallCheck(this, _class7);\n    return _callSuper(this, _class7, arguments);\n  }\n  _inherits(_class7, _Ice$ObjectPrx3);\n  return _createClass(_class7);\n}(Ice.ObjectPrx);\nSlice.defineOperations(Glacier2.IdentitySet, Glacier2.IdentitySetPrx, iceC_Glacier2_IdentitySet_ids, 0, {\n  \"add\": [, 2, 2,,, [[\"Ice.IdentitySeqHelper\"]],,,,],\n  \"remove\": [, 2, 2,,, [[\"Ice.IdentitySeqHelper\"]],,,,],\n  \"get\": [, 2, 2,, [\"Ice.IdentitySeqHelper\"],,,,,]\n});\nvar iceC_Glacier2_SessionControl_ids = [\"::Glacier2::SessionControl\", \"::Ice::Object\"];\n\n/**\n * An administrative session control object, which is tied to the\n * lifecycle of a {@link Session}.\n *\n * @see Session\n *\n **/\nGlacier2.SessionControl = /*#__PURE__*/function (_Ice$Object4) {\n  \"use strict\";\n\n  function _class8() {\n    _classCallCheck(this, _class8);\n    return _callSuper(this, _class8, arguments);\n  }\n  _inherits(_class8, _Ice$Object4);\n  return _createClass(_class8);\n}(Ice.Object);\nGlacier2.SessionControlPrx = /*#__PURE__*/function (_Ice$ObjectPrx4) {\n  \"use strict\";\n\n  function _class9() {\n    _classCallCheck(this, _class9);\n    return _callSuper(this, _class9, arguments);\n  }\n  _inherits(_class9, _Ice$ObjectPrx4);\n  return _createClass(_class9);\n}(Ice.ObjectPrx);\nSlice.defineOperations(Glacier2.SessionControl, Glacier2.SessionControlPrx, iceC_Glacier2_SessionControl_ids, 0, {\n  \"categories\": [,,,, [\"Glacier2.StringSetPrx\"],,,,,],\n  \"adapterIds\": [,,,, [\"Glacier2.StringSetPrx\"],,,,,],\n  \"identities\": [,,,, [\"Glacier2.IdentitySetPrx\"],,,,,],\n  \"getSessionTimeout\": [, 2, 2,, [3],,,,,],\n  \"destroy\": [,,,,,,,,,]\n});\nvar iceC_Glacier2_SessionManager_ids = [\"::Glacier2::SessionManager\", \"::Ice::Object\"];\n\n/**\n * The session manager for username/password authenticated users that\n * is responsible for managing {@link Session} objects. New session objects\n * are created by the {@link Router} object calling on an application-provided\n * session manager. If no session manager is provided by the application,\n * no client-visible sessions are passed to the client.\n *\n * @see Router\n * @see Session\n *\n **/\nGlacier2.SessionManager = /*#__PURE__*/function (_Ice$Object5) {\n  \"use strict\";\n\n  function _class0() {\n    _classCallCheck(this, _class0);\n    return _callSuper(this, _class0, arguments);\n  }\n  _inherits(_class0, _Ice$Object5);\n  return _createClass(_class0);\n}(Ice.Object);\nGlacier2.SessionManagerPrx = /*#__PURE__*/function (_Ice$ObjectPrx5) {\n  \"use strict\";\n\n  function _class1() {\n    _classCallCheck(this, _class1);\n    return _callSuper(this, _class1, arguments);\n  }\n  _inherits(_class1, _Ice$ObjectPrx5);\n  return _createClass(_class1);\n}(Ice.ObjectPrx);\nSlice.defineOperations(Glacier2.SessionManager, Glacier2.SessionManagerPrx, iceC_Glacier2_SessionManager_ids, 0, {\n  \"create\": [,,, 2, [\"Glacier2.SessionPrx\"], [[7], [\"Glacier2.SessionControlPrx\"]],, [Glacier2.CannotCreateSessionException],,]\n});\nvar iceC_Glacier2_SSLSessionManager_ids = [\"::Glacier2::SSLSessionManager\", \"::Ice::Object\"];\n\n/**\n * The session manager for SSL authenticated users that is\n * responsible for managing {@link Session} objects. New session objects are\n * created by the {@link Router} object calling on an application-provided\n * session manager. If no session manager is provided by the\n * application, no client-visible sessions are passed to the client.\n *\n * @see Router\n * @see Session\n *\n **/\nGlacier2.SSLSessionManager = /*#__PURE__*/function (_Ice$Object6) {\n  \"use strict\";\n\n  function _class10() {\n    _classCallCheck(this, _class10);\n    return _callSuper(this, _class10, arguments);\n  }\n  _inherits(_class10, _Ice$Object6);\n  return _createClass(_class10);\n}(Ice.Object);\nGlacier2.SSLSessionManagerPrx = /*#__PURE__*/function (_Ice$ObjectPrx6) {\n  \"use strict\";\n\n  function _class11() {\n    _classCallCheck(this, _class11);\n    return _callSuper(this, _class11, arguments);\n  }\n  _inherits(_class11, _Ice$ObjectPrx6);\n  return _createClass(_class11);\n}(Ice.ObjectPrx);\nSlice.defineOperations(Glacier2.SSLSessionManager, Glacier2.SSLSessionManagerPrx, iceC_Glacier2_SSLSessionManager_ids, 0, {\n  \"create\": [,,, 2, [\"Glacier2.SessionPrx\"], [[Glacier2.SSLInfo], [\"Glacier2.SessionControlPrx\"]],, [Glacier2.CannotCreateSessionException],,]\n});\n/* slice2js browser-bundle-skip */\nexports.Glacier2 = Glacier2;\n/* slice2js browser-bundle-skip-end */\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Glacier2/Session.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/ACM.js":
/*!*****************************************!*\
  !*** ./node_modules/ice/src/Ice/ACM.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n__webpack_require__(/*! ../Ice/Connection */ \"./node_modules/ice/src/Ice/Connection.js\");\n__webpack_require__(/*! ../Ice/Debug */ \"./node_modules/ice/src/Ice/Debug.js\");\nvar Debug = Ice.Debug;\nvar ACMConfig = /*#__PURE__*/_createClass(function ACMConfig(p, l, prefix, dflt) {\n  \"use strict\";\n\n  _classCallCheck(this, ACMConfig);\n  if (p === undefined) {\n    this.timeout = 60 * 1000;\n    this.heartbeat = Ice.ACMHeartbeat.HeartbeatOnDispatch;\n    this.close = Ice.ACMClose.CloseOnInvocationAndIdle;\n    return;\n  }\n  var timeoutProperty;\n  if ((prefix == \"Ice.ACM.Client\" || prefix == \"Ice.ACM.Server\") && p.getProperty(prefix + \".Timeout\").length === 0) {\n    timeoutProperty = prefix; // Deprecated property.\n  } else {\n    timeoutProperty = prefix + \".Timeout\";\n  }\n  this.timeout = p.getPropertyAsIntWithDefault(timeoutProperty, dflt.timeout / 1000) * 1000; // To ms\n  if (this.timeout < 0) {\n    l.warning(\"invalid value for property `\" + timeoutProperty + \"', default value will be used instead\");\n    this.timeout = dflt.timeout;\n  }\n  var hb = p.getPropertyAsIntWithDefault(prefix + \".Heartbeat\", dflt.heartbeat.value);\n  if (hb >= 0 && hb <= Ice.ACMHeartbeat.maxValue) {\n    this.heartbeat = Ice.ACMHeartbeat.valueOf(hb);\n  } else {\n    l.warning(\"invalid value for property `\" + prefix + \".Heartbeat\" + \"', default value will be used instead\");\n    this.heartbeat = dflt.heartbeat;\n  }\n  var cl = p.getPropertyAsIntWithDefault(prefix + \".Close\", dflt.close.value);\n  if (cl >= 0 && cl <= Ice.ACMClose.maxValue) {\n    this.close = Ice.ACMClose.valueOf(cl);\n  } else {\n    l.warning(\"invalid value for property `\" + prefix + \".Close\" + \"', default value will be used instead\");\n    this.close = dflt.close;\n  }\n});\nvar FactoryACMMonitor = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function FactoryACMMonitor(instance, config) {\n    _classCallCheck(this, FactoryACMMonitor);\n    this._instance = instance;\n    this._config = config;\n    this._reapedConnections = [];\n    this._connections = [];\n  }\n  return _createClass(FactoryACMMonitor, [{\n    key: \"destroy\",\n    value: function destroy() {\n      if (this._instance === null) {\n        return;\n      }\n      this._instance = null;\n    }\n  }, {\n    key: \"add\",\n    value: function add(connection) {\n      var _this = this;\n      if (this._config.timeout === 0) {\n        return;\n      }\n      this._connections.push(connection);\n      if (this._connections.length == 1) {\n        this._timerToken = this._instance.timer().scheduleRepeated(function () {\n          return _this.runTimerTask();\n        }, this._config.timeout / 2);\n      }\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(connection) {\n      if (this._config.timeout === 0) {\n        return;\n      }\n      var i = this._connections.indexOf(connection);\n      Debug.assert(i >= 0);\n      this._connections.splice(i, 1);\n      if (this._connections.length === 0) {\n        this._instance.timer().cancel(this._timerToken);\n      }\n    }\n  }, {\n    key: \"reap\",\n    value: function reap(connection) {\n      this._reapedConnections.push(connection);\n    }\n  }, {\n    key: \"acm\",\n    value: function acm(timeout, close, heartbeat) {\n      Debug.assert(this._instance !== null);\n      var config = new ACMConfig();\n      config.timeout = this._config.timeout;\n      config.close = this._config.close;\n      config.heartbeat = this._config.heartbeat;\n      if (timeout !== undefined) {\n        config.timeout = timeout * 1000; // To milliseconds\n      }\n      if (close !== undefined) {\n        config.close = close;\n      }\n      if (heartbeat !== undefined) {\n        config.heartbeat = heartbeat;\n      }\n      return new ConnectionACMMonitor(this, this._instance.timer(), config);\n    }\n  }, {\n    key: \"getACM\",\n    value: function getACM() {\n      return new Ice.ACM(this._config.timeout / 1000, this._config.close, this._config.heartbeat);\n    }\n  }, {\n    key: \"swapReapedConnections\",\n    value: function swapReapedConnections() {\n      if (this._reapedConnections.length === 0) {\n        return null;\n      }\n      var connections = this._reapedConnections;\n      this._reapedConnections = [];\n      return connections;\n    }\n  }, {\n    key: \"runTimerTask\",\n    value: function runTimerTask() {\n      var _this2 = this;\n      if (this._instance === null) {\n        this._connections = null;\n        return;\n      }\n\n      //\n      // Monitor connections outside the thread synchronization, so\n      // that connections can be added or removed during monitoring.\n      //\n      var now = Date.now();\n      this._connections.forEach(function (connection) {\n        try {\n          connection.monitor(now, _this2._config);\n        } catch (ex) {\n          _this2.handleException(ex);\n        }\n      });\n    }\n  }, {\n    key: \"handleException\",\n    value: function handleException(ex) {\n      if (this._instance === null) {\n        return;\n      }\n      this._instance.initializationData().logger.error(\"exception in connection monitor:\\n\" + ex);\n    }\n  }]);\n}();\nvar ConnectionACMMonitor = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function ConnectionACMMonitor(parent, timer, config) {\n    _classCallCheck(this, ConnectionACMMonitor);\n    this._parent = parent;\n    this._timer = timer;\n    this._config = config;\n    this._connection = null;\n  }\n  return _createClass(ConnectionACMMonitor, [{\n    key: \"add\",\n    value: function add(connection) {\n      var _this3 = this;\n      Debug.assert(this._connection === null);\n      this._connection = connection;\n      if (this._config.timeout > 0) {\n        this._timerToken = this._timer.scheduleRepeated(function () {\n          return _this3.runTimerTask();\n        }, this._config.timeout / 2);\n      }\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(connection) {\n      Debug.assert(this._connection === connection);\n      this._connection = null;\n      if (this._config.timeout > 0) {\n        this._timer.cancel(this._timerToken);\n      }\n    }\n  }, {\n    key: \"reap\",\n    value: function reap(connection) {\n      this._parent.reap(connection);\n    }\n  }, {\n    key: \"acm\",\n    value: function acm(timeout, close, heartbeat) {\n      return this._parent.acm(timeout, close, heartbeat);\n    }\n  }, {\n    key: \"getACM\",\n    value: function getACM() {\n      return new Ice.ACM(this._config.timeout / 1000, this._config.close, this._config.heartbeat);\n    }\n  }, {\n    key: \"runTimerTask\",\n    value: function runTimerTask() {\n      try {\n        this._connection.monitor(Date.now(), this._config);\n      } catch (ex) {\n        this._parent.handleException(ex);\n      }\n    }\n  }]);\n}();\nIce.FactoryACMMonitor = FactoryACMMonitor;\nIce.ACMConfig = ACMConfig;\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/ACM.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Address.js":
/*!*********************************************!*\
  !*** ./node_modules/ice/src/Ice/Address.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\nvar Address = /*#__PURE__*/_createClass(function Address(host, port) {\n  \"use strict\";\n\n  _classCallCheck(this, Address);\n  this.host = host;\n  this.port = port;\n});\nIce.Address = Address;\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/Address.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/ArrayUtil.js":
/*!***********************************************!*\
  !*** ./node_modules/ice/src/Ice/ArrayUtil.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\nvar _ModuleRegistry = Ice._ModuleRegistry;\nvar _eq = function eq(e1, e2) {\n  if (e1 === e2) {\n    return true; // If identity compare equals members are equal.\n  } else if (e1 === null || e1 === undefined || e2 === null || e2 === undefined) {\n    return false;\n  } else if (e1.prototype !== e2.prototype) {\n    return false;\n  } else if (typeof e1.equals == \"function\") {\n    return e1.equals(e2);\n  } else if (e1 instanceof Array || e1 instanceof Uint8Array) {\n    return ArrayUtil.equals(e1, e2, _eq);\n  }\n  return false;\n};\nvar ArrayUtil = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function ArrayUtil() {\n    _classCallCheck(this, ArrayUtil);\n  }\n  return _createClass(ArrayUtil, null, [{\n    key: \"clone\",\n    value: function clone(arr) {\n      if (arr === undefined) {\n        return arr;\n      } else if (arr === null) {\n        return [];\n      } else {\n        return arr.slice();\n      }\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(v1, v2, valuesEqual) {\n      if (v1.length != v2.length) {\n        return false;\n      }\n      var equalFn = valuesEqual || _eq;\n      for (var i = 0; i < v1.length; ++i) {\n        if (!equalFn.call(equalFn, v1[i], v2[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }, {\n    key: \"shuffle\",\n    value: function shuffle(arr) {\n      for (var i = arr.length; i > 1; --i) {\n        var e = arr[i - 1];\n        var rand = Math.floor(Math.random() * i);\n        arr[i - 1] = arr[rand];\n        arr[rand] = e;\n      }\n    }\n  }]);\n}();\nArrayUtil.eq = _eq;\nIce.Slice.defineSequence = function (module, name, valueHelper, fixed, elementType) {\n  var helper = null;\n  Object.defineProperty(module, name, {\n    get: function get() {\n      if (helper === null) {\n        helper = Ice.StreamHelpers.generateSeqHelper(_ModuleRegistry.type(valueHelper), fixed, _ModuleRegistry.type(elementType));\n      }\n      return helper;\n    }\n  });\n};\nIce.ArrayUtil = ArrayUtil;\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/ArrayUtil.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/AsyncResult.js":
/*!*************************************************!*\
  !*** ./node_modules/ice/src/Ice/AsyncResult.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n__webpack_require__(/*! ../Ice/AsyncResultBase */ \"./node_modules/ice/src/Ice/AsyncResultBase.js\");\n__webpack_require__(/*! ../Ice/Debug */ \"./node_modules/ice/src/Ice/Debug.js\");\n__webpack_require__(/*! ../Ice/Exception */ \"./node_modules/ice/src/Ice/Exception.js\");\n__webpack_require__(/*! ../Ice/Protocol */ \"./node_modules/ice/src/Ice/Protocol.js\");\n__webpack_require__(/*! ../Ice/Stream */ \"./node_modules/ice/src/Ice/Stream.js\");\nvar AsyncResultBase = Ice.AsyncResultBase;\nvar Debug = Ice.Debug;\nvar Protocol = Ice.Protocol;\nvar UserException = Ice.UserException;\nvar OutputStream = Ice.OutputStream;\nvar AsyncResult = /*#__PURE__*/function (_AsyncResultBase) {\n  \"use strict\";\n\n  function AsyncResult(com, op, connection, proxy, adapter, completedFn) {\n    var _this;\n    _classCallCheck(this, AsyncResult);\n    _this = _callSuper(this, AsyncResult, [com, op, connection, proxy, adapter]);\n    _this._completed = completedFn;\n    _this._is = null;\n    _this._os = com !== null ? new OutputStream(_this._instance, Protocol.currentProtocolEncoding) : null;\n    _this._state = 0;\n    _this._exception = null;\n    _this._sentSynchronously = false;\n    return _this;\n  }\n  _inherits(AsyncResult, _AsyncResultBase);\n  return _createClass(AsyncResult, [{\n    key: \"cancel\",\n    value: function cancel() {\n      this.cancelWithException(new Ice.InvocationCanceledException());\n    }\n  }, {\n    key: \"isCompleted\",\n    value: function isCompleted() {\n      return (this._state & AsyncResult.Done) > 0;\n    }\n  }, {\n    key: \"isSent\",\n    value: function isSent() {\n      return (this._state & AsyncResult.Sent) > 0;\n    }\n  }, {\n    key: \"throwLocalException\",\n    value: function throwLocalException() {\n      if (this._exception !== null) {\n        throw this._exception;\n      }\n    }\n  }, {\n    key: \"sentSynchronously\",\n    value: function sentSynchronously() {\n      return this._sentSynchronously;\n    }\n  }, {\n    key: \"markSent\",\n    value: function markSent(done) {\n      Debug.assert((this._state & AsyncResult.Done) === 0);\n      this._state |= AsyncResult.Sent;\n      if (done) {\n        this._state |= AsyncResult.Done | AsyncResult.OK;\n        this._cancellationHandler = null;\n        this.resolve();\n      }\n    }\n  }, {\n    key: \"markFinished\",\n    value: function markFinished(ok, completed) {\n      Debug.assert((this._state & AsyncResult.Done) === 0);\n      this._state |= AsyncResult.Done;\n      if (ok) {\n        this._state |= AsyncResult.OK;\n      }\n      this._cancellationHandler = null;\n      if (completed) {\n        completed(this);\n      } else {\n        this.resolve();\n      }\n    }\n  }, {\n    key: \"markFinishedEx\",\n    value: function markFinishedEx(ex) {\n      Debug.assert((this._state & AsyncResult.Done) === 0);\n      this._exception = ex;\n      this._state |= AsyncResult.Done;\n      this._cancellationHandler = null;\n      this.reject(ex);\n    }\n  }, {\n    key: \"cancelWithException\",\n    value: function cancelWithException(ex) {\n      if (this._cancellationHandler) {\n        this._cancellationHandler.asyncRequestCanceled(this, ex);\n      } else {\n        this._cancellationException = ex;\n      }\n    }\n  }, {\n    key: \"cancelable\",\n    value: function cancelable(handler) {\n      if (this._cancellationException) {\n        try {\n          throw this._cancellationException;\n        } finally {\n          this._cancellationException = null;\n        }\n      }\n      this._cancellationHandler = handler;\n    }\n  }, {\n    key: \"getOs\",\n    value: function getOs() {\n      return this._os;\n    }\n  }, {\n    key: \"startReadParams\",\n    value: function startReadParams() {\n      this._is.startEncapsulation();\n      return this._is;\n    }\n  }, {\n    key: \"endReadParams\",\n    value: function endReadParams() {\n      this._is.endEncapsulation();\n    }\n  }, {\n    key: \"readEmptyParams\",\n    value: function readEmptyParams() {\n      this._is.skipEmptyEncapsulation();\n    }\n  }, {\n    key: \"throwUserException\",\n    value: function throwUserException() {\n      Debug.assert((this._state & AsyncResult.Done) !== 0);\n      if ((this._state & AsyncResult.OK) === 0) {\n        try {\n          this._is.startEncapsulation();\n          this._is.throwException();\n        } catch (ex) {\n          if (ex instanceof UserException) {\n            this._is.endEncapsulation();\n          }\n          throw ex;\n        }\n      }\n    }\n  }]);\n}(AsyncResultBase);\nAsyncResult.OK = 0x1;\nAsyncResult.Done = 0x2;\nAsyncResult.Sent = 0x4;\nIce.AsyncResult = AsyncResult;\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/AsyncResult.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/AsyncResultBase.js":
/*!*****************************************************!*\
  !*** ./node_modules/ice/src/Ice/AsyncResultBase.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/Promise */ \"./node_modules/ice/src/Ice/Promise.js\").Ice);\nvar AsyncResultBase = /*#__PURE__*/function (_Ice$Promise) {\n  \"use strict\";\n\n  function AsyncResultBase(communicator, op, connection, proxy, adapter) {\n    var _this;\n    _classCallCheck(this, AsyncResultBase);\n    _this = _callSuper(this, AsyncResultBase);\n    _this._communicator = communicator;\n    _this._instance = communicator ? communicator.instance : null;\n    _this._operation = op;\n    _this._connection = connection;\n    _this._proxy = proxy;\n    _this._adapter = adapter;\n    return _this;\n  }\n  _inherits(AsyncResultBase, _Ice$Promise);\n  return _createClass(AsyncResultBase, [{\n    key: \"communicator\",\n    get: function get() {\n      return this._communicator;\n    }\n  }, {\n    key: \"connection\",\n    get: function get() {\n      return this._connection;\n    }\n  }, {\n    key: \"proxy\",\n    get: function get() {\n      return this._proxy;\n    }\n  }, {\n    key: \"adapter\",\n    get: function get() {\n      return this._adapter;\n    }\n  }, {\n    key: \"operation\",\n    get: function get() {\n      return this._operation;\n    }\n  }]);\n}(Ice.Promise);\nIce.AsyncResultBase = AsyncResultBase;\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/AsyncResultBase.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/AsyncStatus.js":
/*!*************************************************!*\
  !*** ./node_modules/ice/src/Ice/AsyncStatus.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\nIce.AsyncStatus = {\n  Queued: 0,\n  Sent: 1\n};\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/AsyncStatus.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Base64.js":
/*!********************************************!*\
  !*** ./node_modules/ice/src/Ice/Base64.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/Buffer */ \"./node_modules/ice/src/Ice/Buffer.js\").Ice);\nvar _codeA = \"A\".charCodeAt(0);\nvar _codea = \"a\".charCodeAt(0);\nvar _code0 = \"0\".charCodeAt(0);\nfunction encodeChar(uc) {\n  if (uc < 26) {\n    return String.fromCharCode(_codeA + uc);\n  }\n  if (uc < 52) {\n    return String.fromCharCode(_codea + (uc - 26));\n  }\n  if (uc < 62) {\n    return String.fromCharCode(_code0 + (uc - 52));\n  }\n  if (uc == 62) {\n    return \"+\";\n  }\n  return \"/\";\n}\nfunction decodeChar(c) {\n  if (c >= 'A' && c <= 'Z') {\n    return c.charCodeAt(0) - _codeA;\n  }\n  if (c >= 'a' && c <= 'z') {\n    return c.charCodeAt(0) - _codea + 26;\n  }\n  if (c >= '0' && c <= '9') {\n    return c.charCodeAt(0) - _code0 + 52;\n  }\n  if (c == '+') {\n    return 62;\n  }\n  return 63;\n}\nvar Base64 = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function Base64() {\n    _classCallCheck(this, Base64);\n  }\n  return _createClass(Base64, null, [{\n    key: \"encode\",\n    value:\n    // Expects native Buffer\n    function encode(buf) {\n      if (buf === null || buf.length === 0) {\n        return \"\";\n      }\n      var v = [];\n      var by1;\n      var by2;\n      var by3;\n      var by4;\n      var by5;\n      var by6;\n      var by7;\n      for (var i = 0; i < buf.length; i += 3) {\n        by1 = buf[i] & 0xff;\n        by2 = 0;\n        by3 = 0;\n        if (i + 1 < buf.length) {\n          by2 = buf[i + 1] & 0xff;\n        }\n        if (i + 2 < buf.length) {\n          by3 = buf[i + 2] & 0xff;\n        }\n        by4 = by1 >> 2 & 0xff;\n        by5 = ((by1 & 0x3) << 4 | by2 >> 4) & 0xff;\n        by6 = ((by2 & 0xf) << 2 | by3 >> 6) & 0xff;\n        by7 = by3 & 0x3f;\n        v.push(encodeChar(by4));\n        v.push(encodeChar(by5));\n        if (i + 1 < buf.length) {\n          v.push(encodeChar(by6));\n        } else {\n          v.push(\"=\");\n        }\n        if (i + 2 < buf.length) {\n          v.push(encodeChar(by7));\n        } else {\n          v.push(\"=\");\n        }\n      }\n      var retval = v.join(\"\");\n      var outString = [];\n      var iter = 0;\n      while (retval.length - iter > 76) {\n        outString.push(retval.substring(iter, iter + 76));\n        outString.push(\"\\r\\n\");\n        iter += 76;\n      }\n      outString.push(retval.substring(iter));\n      return outString.join(\"\");\n    }\n  }, {\n    key: \"decode\",\n    value: function decode(str)\n    // Returns native Buffer\n    {\n      var newStr = [];\n      for (var j = 0; j < str.length; j++) {\n        var c = str.charAt(j);\n        if (Base64.isBase64(c)) {\n          newStr.push(c);\n        }\n      }\n      if (newStr.length === 0) {\n        return null;\n      }\n\n      // Note: This is how we were previously computing the size of the return\n      //       sequence.  The method below is more efficient (and correct).\n      // size_t lines = str.size() / 78;\n      // size_t totalBytes = (lines * 76) + (((str.size() - (lines * 78)) * 3) / 4);\n\n      // Figure out how long the final sequence is going to be.\n      var totalBytes = newStr.length * 3 / 4 + 1;\n      var retval = new Ice.Buffer();\n      retval.resize(totalBytes);\n      var by1;\n      var by2;\n      var by3;\n      var by4;\n      var c1;\n      var c2;\n      var c3;\n      var c4;\n      for (var i = 0; i < newStr.length; i += 4) {\n        c1 = \"A\";\n        c2 = \"A\";\n        c3 = \"A\";\n        c4 = \"A\";\n        c1 = newStr[i];\n        if (i + 1 < newStr.length) {\n          c2 = newStr[i + 1];\n        }\n        if (i + 2 < newStr.length) {\n          c3 = newStr[i + 2];\n        }\n        if (i + 3 < newStr.length) {\n          c4 = newStr[i + 3];\n        }\n        by1 = decodeChar(c1) & 0xff;\n        by2 = decodeChar(c2) & 0xff;\n        by3 = decodeChar(c3) & 0xff;\n        by4 = decodeChar(c4) & 0xff;\n        retval.put(by1 << 2 | by2 >> 4);\n        if (c3 != \"=\") {\n          retval.put((by2 & 0xf) << 4 | by3 >> 2);\n        }\n        if (c4 != \"=\") {\n          retval.put((by3 & 0x3) << 6 | by4);\n        }\n      }\n      return retval.remaining > 0 ? retval.getArrayAt(0, retval.position) : retval.getArrayAt(0);\n    }\n  }, {\n    key: \"isBase64\",\n    value: function isBase64(c) {\n      if (c >= 'A' && c <= 'Z') {\n        return true;\n      }\n      if (c >= 'a' && c <= 'z') {\n        return true;\n      }\n      if (c >= '0' && c <= '9') {\n        return true;\n      }\n      if (c == '+') {\n        return true;\n      }\n      if (c == '/') {\n        return true;\n      }\n      if (c == '=') {\n        return true;\n      }\n      return false;\n    }\n  }]);\n}();\nIce.Base64 = Base64;\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/Base64.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/BatchRequestQueue.js":
/*!*******************************************************!*\
  !*** ./node_modules/ice/src/Ice/BatchRequestQueue.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n__webpack_require__(/*! ../Ice/Debug */ \"./node_modules/ice/src/Ice/Debug.js\");\n__webpack_require__(/*! ../Ice/Protocol */ \"./node_modules/ice/src/Ice/Protocol.js\");\n__webpack_require__(/*! ../Ice/Stream */ \"./node_modules/ice/src/Ice/Stream.js\");\nvar OutputStream = Ice.OutputStream;\nvar Debug = Ice.Debug;\nvar Protocol = Ice.Protocol;\nvar udpOverhead = 20 + 8;\nvar BatchRequestQueue = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function BatchRequestQueue(instance, datagram) {\n    _classCallCheck(this, BatchRequestQueue);\n    this._batchStreamInUse = false;\n    this._batchRequestNum = 0;\n    this._batchStream = new OutputStream(instance, Protocol.currentProtocolEncoding);\n    this._batchStream.writeBlob(Protocol.requestBatchHdr);\n    this._batchMarker = this._batchStream.size;\n    this._exception = null;\n    this._maxSize = instance.batchAutoFlushSize();\n    if (this._maxSize > 0 && datagram) {\n      var udpSndSize = instance.initializationData().properties.getPropertyAsIntWithDefault(\"Ice.UDP.SndSize\", 65535 - udpOverhead);\n      if (udpSndSize < this._maxSize) {\n        this._maxSize = udpSndSize;\n      }\n    }\n  }\n  return _createClass(BatchRequestQueue, [{\n    key: \"prepareBatchRequest\",\n    value: function prepareBatchRequest(os) {\n      if (this._exception) {\n        throw this._exception;\n      }\n      this._batchStream.swap(os);\n    }\n  }, {\n    key: \"finishBatchRequest\",\n    value: function finishBatchRequest(os, proxy, operation) {\n      //\n      // No need for synchronization, no other threads are supposed\n      // to modify the queue since we set this._batchStreamInUse to true.\n      //\n      this._batchStream.swap(os);\n      try {\n        if (this._maxSize > 0 && this._batchStream.size >= this._maxSize) {\n          proxy.ice_flushBatchRequests(); // Auto flush\n        }\n        Debug.assert(this._batchMarker < this._batchStream.size);\n        this._batchMarker = this._batchStream.size;\n        ++this._batchRequestNum;\n      } finally {\n        this._batchStream.resize(this._batchMarker);\n      }\n    }\n  }, {\n    key: \"abortBatchRequest\",\n    value: function abortBatchRequest(os) {\n      this._batchStream.swap(os);\n      this._batchStream.resize(this._batchMarker);\n    }\n  }, {\n    key: \"swap\",\n    value: function swap(os) {\n      if (this._batchRequestNum === 0) {\n        return 0;\n      }\n      var lastRequest = null;\n      if (this._batchMarker < this._batchStream.size) {\n        var length = this._batchStream.size - this._batchMarker;\n        this._batchStream.pos = this._batchMarker;\n        lastRequest = this._batchStream.buffer.getArray(length);\n        this._batchStream.resize(this._batchMarker);\n      }\n      var requestNum = this._batchRequestNum;\n      this._batchStream.swap(os);\n\n      //\n      // Reset the batch.\n      //\n      this._batchRequestNum = 0;\n      this._batchStream.writeBlob(Protocol.requestBatchHdr);\n      this._batchMarker = this._batchStream.size;\n      if (lastRequest !== null) {\n        this._batchStream.writeBlob(lastRequest);\n      }\n      return requestNum;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy(ex) {\n      this._exception = ex;\n    }\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return this._batchStream.size === Protocol.requestBatchHdr.length;\n    }\n  }]);\n}();\nIce.BatchRequestQueue = BatchRequestQueue;\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/BatchRequestQueue.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Buffer.js":
/*!********************************************!*\
  !*** ./node_modules/ice/src/Ice/Buffer.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\").Ice);\nvar Long = Ice.Long;\nvar bufferOverflowExceptionMsg = \"BufferOverflowException\";\nvar bufferUnderflowExceptionMsg = \"BufferUnderflowException\";\nvar indexOutOfBoundsExceptionMsg = \"IndexOutOfBoundsException\";\nvar Buffer = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function Buffer(buffer) {\n    _classCallCheck(this, Buffer);\n    if (buffer !== undefined) {\n      this.b = buffer;\n      this.v = new DataView(this.b);\n      this._limit = this.b.byteLength;\n    } else {\n      this.b = null; // ArrayBuffer\n      this.v = null; // DataView\n      this._limit = 0;\n    }\n    this._position = 0;\n    this._shrinkCounter = 0;\n  }\n  return _createClass(Buffer, [{\n    key: \"empty\",\n    value: function empty() {\n      return this._limit === 0;\n    }\n  }, {\n    key: \"resize\",\n    value: function resize(n) {\n      if (n === 0) {\n        this.clear();\n      } else if (n > this.capacity) {\n        this.reserve(n);\n      }\n      this._limit = n;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.b = null;\n      this.v = null;\n      this._position = 0;\n      this._limit = 0;\n    }\n\n    //\n    // Call expand(n) to add room for n additional bytes. Note that expand()\n    // examines the current position of the buffer first; we don't want to\n    // expand the buffer if the caller is writing to a location that is\n    // already in the buffer.\n    //\n  }, {\n    key: \"expand\",\n    value: function expand(n) {\n      var sz = this.capacity === 0 ? n : this._position + n;\n      if (sz > this._limit) {\n        this.resize(sz);\n      }\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      if (this._limit > 0 && this._limit * 2 < this.capacity) {\n        //\n        // If the current buffer size is smaller than the\n        // buffer capacity, we shrink the buffer memory to the\n        // current size. This is to avoid holding on to too much\n        // memory if it's not needed anymore.\n        //\n        if (++this._shrinkCounter > 2) {\n          this.reserve(this._limit);\n          this._shrinkCounter = 0;\n        }\n      } else {\n        this._shrinkCounter = 0;\n      }\n      this._limit = this.capacity();\n      this._position = 0;\n    }\n  }, {\n    key: \"reserve\",\n    value: function reserve(n) {\n      if (n > this.capacity) {\n        var capacity = Math.max(1024, Math.max(n, 2 * this.capacity));\n        if (!this.b) {\n          this.b = new ArrayBuffer(capacity);\n        } else {\n          var b = new Uint8Array(capacity);\n          b.set(new Uint8Array(this.b));\n          this.b = b.buffer;\n        }\n        this.v = new DataView(this.b);\n      } else if (n < this.capacity) {\n        this.b = this.b.slice(0, n);\n        this.v = new DataView(this.b);\n      }\n    }\n  }, {\n    key: \"put\",\n    value: function put(v) {\n      if (this._position === this._limit) {\n        throw new RangeError(bufferOverflowExceptionMsg);\n      }\n      this.v.setUint8(this._position, v);\n      this._position++;\n    }\n  }, {\n    key: \"putAt\",\n    value: function putAt(i, v) {\n      if (i >= this._limit) {\n        throw new RangeError(indexOutOfBoundsExceptionMsg);\n      }\n      this.v.setUint8(i, v);\n    }\n  }, {\n    key: \"putArray\",\n    value: function putArray(v) {\n      // Expects an Uint8Array\n      if (!(v instanceof Uint8Array)) {\n        throw new TypeError('argument is not a Uint8Array');\n      }\n      if (v.byteLength > 0) {\n        if (this._position + v.length > this._limit) {\n          throw new RangeError(bufferOverflowExceptionMsg);\n        }\n        new Uint8Array(this.b, 0, this.b.byteLength).set(v, this._position);\n        this._position += v.byteLength;\n      }\n    }\n  }, {\n    key: \"putShort\",\n    value: function putShort(v) {\n      if (this._position + 2 > this._limit) {\n        throw new RangeError(bufferOverflowExceptionMsg);\n      }\n      this.v.setInt16(this._position, v, true);\n      this._position += 2;\n    }\n  }, {\n    key: \"putInt\",\n    value: function putInt(v) {\n      if (this._position + 4 > this._limit) {\n        throw new RangeError(bufferOverflowExceptionMsg);\n      }\n      this.v.setInt32(this._position, v, true);\n      this._position += 4;\n    }\n  }, {\n    key: \"putIntAt\",\n    value: function putIntAt(i, v) {\n      if (i + 4 > this._limit || i < 0) {\n        throw new RangeError(indexOutOfBoundsExceptionMsg);\n      }\n      this.v.setInt32(i, v, true);\n    }\n  }, {\n    key: \"putFloat\",\n    value: function putFloat(v) {\n      if (this._position + 4 > this._limit) {\n        throw new RangeError(bufferOverflowExceptionMsg);\n      }\n      this.v.setFloat32(this._position, v, true);\n      this._position += 4;\n    }\n  }, {\n    key: \"putDouble\",\n    value: function putDouble(v) {\n      if (this._position + 8 > this._limit) {\n        throw new RangeError(bufferOverflowExceptionMsg);\n      }\n      this.v.setFloat64(this._position, v, true);\n      this._position += 8;\n    }\n  }, {\n    key: \"putLong\",\n    value: function putLong(v) {\n      if (this._position + 8 > this._limit) {\n        throw new RangeError(bufferOverflowExceptionMsg);\n      }\n      this.v.setInt32(this._position, v.low, true);\n      this._position += 4;\n      this.v.setInt32(this._position, v.high, true);\n      this._position += 4;\n    }\n  }, {\n    key: \"writeString\",\n    value: function writeString(stream, v) {\n      //\n      // Encode the string as utf8\n      //\n      var encoded = unescape(encodeURIComponent(v));\n      stream.writeSize(encoded.length);\n      stream.expand(encoded.length);\n      this.putString(encoded, encoded.length);\n    }\n  }, {\n    key: \"putString\",\n    value: function putString(v, sz) {\n      if (this._position + sz > this._limit) {\n        throw new RangeError(bufferOverflowExceptionMsg);\n      }\n      for (var i = 0; i < sz; ++i) {\n        this.v.setUint8(this._position, v.charCodeAt(i));\n        this._position++;\n      }\n    }\n  }, {\n    key: \"get\",\n    value: function get() {\n      if (this._position >= this._limit) {\n        throw new RangeError(bufferUnderflowExceptionMsg);\n      }\n      var v = this.v.getUint8(this._position);\n      this._position++;\n      return v;\n    }\n  }, {\n    key: \"getAt\",\n    value: function getAt(i) {\n      if (i < 0 || i >= this._limit) {\n        throw new RangeError(indexOutOfBoundsExceptionMsg);\n      }\n      return this.v.getUint8(i);\n    }\n  }, {\n    key: \"getArray\",\n    value: function getArray(length) {\n      if (this._position + length > this._limit) {\n        throw new RangeError(bufferUnderflowExceptionMsg);\n      }\n      var buffer = this.b.slice(this._position, this._position + length);\n      this._position += length;\n      return new Uint8Array(buffer);\n    }\n  }, {\n    key: \"getArrayAt\",\n    value: function getArrayAt(position, length) {\n      if (position + length > this._limit) {\n        throw new RangeError(bufferUnderflowExceptionMsg);\n      }\n      return new Uint8Array(this.b.slice(position, position + length === undefined ? this.b.byteLength - position : length));\n    }\n  }, {\n    key: \"getShort\",\n    value: function getShort() {\n      if (this._limit - this._position < 2) {\n        throw new RangeError(bufferUnderflowExceptionMsg);\n      }\n      var v = this.v.getInt16(this._position, true);\n      this._position += 2;\n      return v;\n    }\n  }, {\n    key: \"getInt\",\n    value: function getInt() {\n      if (this._limit - this._position < 4) {\n        throw new RangeError(bufferUnderflowExceptionMsg);\n      }\n      var v = this.v.getInt32(this._position, true);\n      this._position += 4;\n      return v;\n    }\n  }, {\n    key: \"getFloat\",\n    value: function getFloat() {\n      if (this._limit - this._position < 4) {\n        throw new RangeError(bufferUnderflowExceptionMsg);\n      }\n      var v = this.v.getFloat32(this._position, true);\n      this._position += 4;\n      return v;\n    }\n  }, {\n    key: \"getDouble\",\n    value: function getDouble() {\n      if (this._limit - this._position < 8) {\n        throw new RangeError(bufferUnderflowExceptionMsg);\n      }\n      var v = this.v.getFloat64(this._position, true);\n      this._position += 8;\n      return v;\n    }\n  }, {\n    key: \"getLong\",\n    value: function getLong() {\n      if (this._limit - this._position < 8) {\n        throw new RangeError(bufferUnderflowExceptionMsg);\n      }\n      var low = this.v.getUint32(this._position, true);\n      this._position += 4;\n      var high = this.v.getUint32(this._position, true);\n      this._position += 4;\n      return new Long(high, low);\n    }\n  }, {\n    key: \"getString\",\n    value: function getString(length) {\n      if (this._position + length > this._limit) {\n        throw new RangeError(bufferUnderflowExceptionMsg);\n      }\n      var data = new DataView(this.b, this._position, length);\n      var s = \"\";\n      for (var i = 0; i < length; ++i) {\n        s += String.fromCharCode(data.getUint8(i));\n      }\n      this._position += length;\n      return decodeURIComponent(escape(s));\n    }\n  }, {\n    key: \"position\",\n    get: function get() {\n      return this._position;\n    },\n    set: function set(value) {\n      if (value >= 0 && value <= this._limit) {\n        this._position = value;\n      }\n    }\n  }, {\n    key: \"limit\",\n    get: function get() {\n      return this._limit;\n    },\n    set: function set(value) {\n      if (value <= this.capacity) {\n        this._limit = value;\n        if (this._position > value) {\n          this._position = value;\n        }\n      }\n    }\n  }, {\n    key: \"capacity\",\n    get: function get() {\n      return this.b === null ? 0 : this.b.byteLength;\n    }\n  }, {\n    key: \"remaining\",\n    get: function get() {\n      return this._limit - this._position;\n    }\n  }]);\n}();\nIce.Buffer = Buffer;\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/Buffer.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/BuiltinSequences.js":
/*!******************************************************!*\
  !*** ./node_modules/ice/src/Ice/BuiltinSequences.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `BuiltinSequences.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nvar _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\nvar Ice = _ModuleRegistry.module(\"Ice\");\nvar Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n\nSlice.defineSequence(Ice, \"BoolSeqHelper\", \"Ice.BoolHelper\", true);\nSlice.defineSequence(Ice, \"ByteSeqHelper\", \"Ice.ByteHelper\", true);\nSlice.defineSequence(Ice, \"ShortSeqHelper\", \"Ice.ShortHelper\", true);\nSlice.defineSequence(Ice, \"IntSeqHelper\", \"Ice.IntHelper\", true);\nSlice.defineSequence(Ice, \"LongSeqHelper\", \"Ice.LongHelper\", true);\nSlice.defineSequence(Ice, \"FloatSeqHelper\", \"Ice.FloatHelper\", true);\nSlice.defineSequence(Ice, \"DoubleSeqHelper\", \"Ice.DoubleHelper\", true);\nSlice.defineSequence(Ice, \"StringSeqHelper\", \"Ice.StringHelper\", false);\nSlice.defineSequence(Ice, \"ObjectSeqHelper\", \"Ice.ObjectHelper\", false, \"Ice.Value\");\nSlice.defineSequence(Ice, \"ObjectProxySeqHelper\", \"Ice.ObjectPrx\", false);\n/* slice2js browser-bundle-skip */\nexports.Ice = Ice;\n/* slice2js browser-bundle-skip-end */\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/BuiltinSequences.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Communicator.js":
/*!**************************************************!*\
  !*** ./node_modules/ice/src/Ice/Communicator.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `Communicator.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nvar _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\");\n__webpack_require__(/*! ../Ice/ObjectPrx */ \"./node_modules/ice/src/Ice/ObjectPrx.js\");\n__webpack_require__(/*! ../Ice/EnumBase */ \"./node_modules/ice/src/Ice/EnumBase.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\n__webpack_require__(/*! ../Ice/LoggerF */ \"./node_modules/ice/src/Ice/LoggerF.js\");\n__webpack_require__(/*! ../Ice/InstrumentationF */ \"./node_modules/ice/src/Ice/InstrumentationF.js\");\n__webpack_require__(/*! ../Ice/ObjectAdapterF */ \"./node_modules/ice/src/Ice/ObjectAdapterF.js\");\n__webpack_require__(/*! ../Ice/ObjectFactory */ \"./node_modules/ice/src/Ice/ObjectFactory.js\");\n__webpack_require__(/*! ../Ice/ValueFactory */ \"./node_modules/ice/src/Ice/ValueFactory.js\");\n__webpack_require__(/*! ../Ice/Router */ \"./node_modules/ice/src/Ice/Router.js\");\n__webpack_require__(/*! ../Ice/Locator */ \"./node_modules/ice/src/Ice/Locator.js\");\n__webpack_require__(/*! ../Ice/PluginF */ \"./node_modules/ice/src/Ice/PluginF.js\");\n__webpack_require__(/*! ../Ice/ImplicitContextF */ \"./node_modules/ice/src/Ice/ImplicitContextF.js\");\n__webpack_require__(/*! ../Ice/Current */ \"./node_modules/ice/src/Ice/Current.js\");\n__webpack_require__(/*! ../Ice/Properties */ \"./node_modules/ice/src/Ice/Properties.js\");\n__webpack_require__(/*! ../Ice/FacetMap */ \"./node_modules/ice/src/Ice/FacetMap.js\");\n__webpack_require__(/*! ../Ice/Connection */ \"./node_modules/ice/src/Ice/Connection.js\");\nvar Ice = _ModuleRegistry.module(\"Ice\");\nvar Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n\n/**\n * The output mode for xxxToString method such as identityToString and proxyToString.\n * The actual encoding format for the string is the same for all modes: you\n * don't need to specify an encoding format or mode when reading such a string.\n *\n **/\nIce.ToStringMode = Slice.defineEnum([['Unicode', 0], ['ASCII', 1], ['Compat', 2]]);\n/* slice2js browser-bundle-skip */\nexports.Ice = Ice;\n/* slice2js browser-bundle-skip-end */\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/Communicator.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/CommunicatorI.js":
/*!***************************************************!*\
  !*** ./node_modules/ice/src/Ice/CommunicatorI.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n__webpack_require__(/*! ../Ice/AsyncResultBase */ \"./node_modules/ice/src/Ice/AsyncResultBase.js\");\n__webpack_require__(/*! ../Ice/Debug */ \"./node_modules/ice/src/Ice/Debug.js\");\n__webpack_require__(/*! ../Ice/Instance */ \"./node_modules/ice/src/Ice/Instance.js\");\n__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\");\n__webpack_require__(/*! ../Ice/UUID */ \"./node_modules/ice/src/Ice/UUID.js\");\nvar Instance = Ice.Instance;\nvar Debug = Ice.Debug;\n\n//\n// Ice.Communicator\n//\nvar Communicator = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function Communicator(initData) {\n    _classCallCheck(this, Communicator);\n    this._instance = new Instance(initData);\n  }\n\n  //\n  // Certain initialization tasks need to be completed after the\n  // constructor.\n  //\n  return _createClass(Communicator, [{\n    key: \"finishSetup\",\n    value: function finishSetup(promise) {\n      this._instance.finishSetup(this, promise);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      return this._instance.destroy();\n    }\n  }, {\n    key: \"shutdown\",\n    value: function shutdown() {\n      try {\n        return this._instance.objectAdapterFactory().shutdown();\n      } catch (ex) {\n        Debug.assert(ex instanceof Ice.CommunicatorDestroyedException);\n        return Ice.Promise.resolve();\n      }\n    }\n  }, {\n    key: \"waitForShutdown\",\n    value: function waitForShutdown() {\n      try {\n        return this._instance.objectAdapterFactory().waitForShutdown();\n      } catch (ex) {\n        Debug.assert(ex instanceof Ice.CommunicatorDestroyedException);\n        return Ice.Promise.resolve();\n      }\n    }\n  }, {\n    key: \"isShutdown\",\n    value: function isShutdown() {\n      try {\n        return this._instance.objectAdapterFactory().isShutdown();\n      } catch (ex) {\n        if (!(ex instanceof Ice.CommunicatorDestroyedException)) {\n          throw ex;\n        }\n        return true;\n      }\n    }\n  }, {\n    key: \"stringToProxy\",\n    value: function stringToProxy(s) {\n      return this._instance.proxyFactory().stringToProxy(s);\n    }\n  }, {\n    key: \"proxyToString\",\n    value: function proxyToString(proxy) {\n      return this._instance.proxyFactory().proxyToString(proxy);\n    }\n  }, {\n    key: \"propertyToProxy\",\n    value: function propertyToProxy(s) {\n      return this._instance.proxyFactory().propertyToProxy(s);\n    }\n  }, {\n    key: \"proxyToProperty\",\n    value: function proxyToProperty(proxy, prefix) {\n      return this._instance.proxyFactory().proxyToProperty(proxy, prefix);\n    }\n  }, {\n    key: \"stringToIdentity\",\n    value: function stringToIdentity(s) {\n      return Ice.stringToIdentity(s);\n    }\n  }, {\n    key: \"identityToString\",\n    value: function identityToString(ident) {\n      return Ice.identityToString(ident, this._instance.toStringMode());\n    }\n  }, {\n    key: \"createObjectAdapter\",\n    value: function createObjectAdapter(name) {\n      var promise = new Ice.AsyncResultBase(this, \"createObjectAdapter\", this, null, null);\n      this._instance.objectAdapterFactory().createObjectAdapter(name, null, promise);\n      return promise;\n    }\n  }, {\n    key: \"createObjectAdapterWithEndpoints\",\n    value: function createObjectAdapterWithEndpoints(name, endpoints) {\n      if (name.length === 0) {\n        name = Ice.generateUUID();\n      }\n      this.getProperties().setProperty(name + \".Endpoints\", endpoints);\n      var promise = new Ice.AsyncResultBase(this, \"createObjectAdapterWithEndpoints\", this, null, null);\n      this._instance.objectAdapterFactory().createObjectAdapter(name, null, promise);\n      return promise;\n    }\n  }, {\n    key: \"createObjectAdapterWithRouter\",\n    value: function createObjectAdapterWithRouter(name, router) {\n      var _this = this;\n      if (name.length === 0) {\n        name = Ice.generateUUID();\n      }\n      var promise = new Ice.AsyncResultBase(this, \"createObjectAdapterWithRouter\", this, null, null);\n\n      //\n      // We set the proxy properties here, although we still use the proxy supplied.\n      //\n      this.proxyToProperty(router, name + \".Router\").forEach(function (value, key) {\n        _this.getProperties().setProperty(key, value);\n      });\n      this._instance.objectAdapterFactory().createObjectAdapter(name, router, promise);\n      return promise;\n    }\n  }, {\n    key: \"addObjectFactory\",\n    value: function addObjectFactory(factory, id) {\n      this._instance.addObjectFactory(factory, id);\n    }\n  }, {\n    key: \"findObjectFactory\",\n    value: function findObjectFactory(id) {\n      return this._instance.findObjectFactory(id);\n    }\n  }, {\n    key: \"getValueFactoryManager\",\n    value: function getValueFactoryManager() {\n      return this._instance.initializationData().valueFactoryManager;\n    }\n  }, {\n    key: \"getImplicitContext\",\n    value: function getImplicitContext() {\n      return this._instance.getImplicitContext();\n    }\n  }, {\n    key: \"getProperties\",\n    value: function getProperties() {\n      return this._instance.initializationData().properties;\n    }\n  }, {\n    key: \"getLogger\",\n    value: function getLogger() {\n      return this._instance.initializationData().logger;\n    }\n  }, {\n    key: \"getDefaultRouter\",\n    value: function getDefaultRouter() {\n      return this._instance.referenceFactory().getDefaultRouter();\n    }\n  }, {\n    key: \"setDefaultRouter\",\n    value: function setDefaultRouter(router) {\n      this._instance.setDefaultRouter(router);\n    }\n  }, {\n    key: \"getDefaultLocator\",\n    value: function getDefaultLocator() {\n      return this._instance.referenceFactory().getDefaultLocator();\n    }\n  }, {\n    key: \"setDefaultLocator\",\n    value: function setDefaultLocator(locator) {\n      this._instance.setDefaultLocator(locator);\n    }\n  }, {\n    key: \"flushBatchRequests\",\n    value: function flushBatchRequests() {\n      return this._instance.outgoingConnectionFactory().flushAsyncBatchRequests();\n    }\n  }, {\n    key: \"instance\",\n    get: function get() {\n      return this._instance;\n    }\n  }]);\n}();\nIce.Communicator = Communicator;\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/CommunicatorI.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/CompactIdRegistry.js":
/*!*******************************************************!*\
  !*** ./node_modules/ice/src/Ice/CompactIdRegistry.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\nIce.CompactIdRegistry = new Map();\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/CompactIdRegistry.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/ConnectRequestHandler.js":
/*!***********************************************************!*\
  !*** ./node_modules/ice/src/Ice/ConnectRequestHandler.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n__webpack_require__(/*! ../Ice/AsyncStatus */ \"./node_modules/ice/src/Ice/AsyncStatus.js\");\n__webpack_require__(/*! ../Ice/ConnectionRequestHandler */ \"./node_modules/ice/src/Ice/ConnectionRequestHandler.js\");\n__webpack_require__(/*! ../Ice/Debug */ \"./node_modules/ice/src/Ice/Debug.js\");\n__webpack_require__(/*! ../Ice/Exception */ \"./node_modules/ice/src/Ice/Exception.js\");\n__webpack_require__(/*! ../Ice/ReferenceMode */ \"./node_modules/ice/src/Ice/ReferenceMode.js\");\n__webpack_require__(/*! ../Ice/RetryException */ \"./node_modules/ice/src/Ice/RetryException.js\");\nvar AsyncStatus = Ice.AsyncStatus;\nvar ConnectionRequestHandler = Ice.ConnectionRequestHandler;\nvar Debug = Ice.Debug;\nvar RetryException = Ice.RetryException;\nvar ReferenceMode = Ice.ReferenceMode;\nvar LocalException = Ice.LocalException;\nvar ConnectRequestHandler = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function ConnectRequestHandler(ref, proxy) {\n    _classCallCheck(this, ConnectRequestHandler);\n    this._reference = ref;\n    this._response = ref.getMode() === ReferenceMode.ModeTwoway;\n    this._proxy = proxy;\n    this._proxies = [];\n    this._initialized = false;\n    this._connection = null;\n    this._exception = null;\n    this._requests = [];\n  }\n  return _createClass(ConnectRequestHandler, [{\n    key: \"connect\",\n    value: function connect(proxy) {\n      if (!this.initialized()) {\n        this._proxies.push(proxy);\n      }\n      return this._requestHandler ? this._requestHandler : this;\n    }\n  }, {\n    key: \"update\",\n    value: function update(previousHandler, newHandler) {\n      return previousHandler === this ? newHandler : this;\n    }\n  }, {\n    key: \"sendAsyncRequest\",\n    value: function sendAsyncRequest(out) {\n      if (!this._initialized) {\n        out.cancelable(this); // This will throw if the request is canceled\n      }\n      if (!this.initialized()) {\n        this._requests.push(out);\n        return AsyncStatus.Queued;\n      }\n      return out.invokeRemote(this._connection, this._response);\n    }\n  }, {\n    key: \"asyncRequestCanceled\",\n    value: function asyncRequestCanceled(out, ex) {\n      if (this._exception !== null) {\n        return; // The request has been notified of a failure already.\n      }\n      if (!this.initialized()) {\n        for (var i = 0; i < this._requests.length; i++) {\n          if (this._requests[i] === out) {\n            out.completedEx(ex);\n            this._requests.splice(i, 1);\n            return;\n          }\n        }\n        Debug.assert(false); // The request has to be queued if it timed out and we're not initialized yet.\n      }\n      this._connection.asyncRequestCanceled(out, ex);\n    }\n  }, {\n    key: \"getReference\",\n    value: function getReference() {\n      return this._reference;\n    }\n  }, {\n    key: \"getConnection\",\n    value: function getConnection() {\n      if (this._exception !== null) {\n        throw this._exception;\n      } else {\n        return this._connection;\n      }\n    }\n\n    //\n    // Implementation of Reference_GetConnectionCallback\n    //\n  }, {\n    key: \"setConnection\",\n    value: function setConnection(connection) {\n      var _this = this;\n      Debug.assert(this._exception === null && this._connection === null);\n      this._connection = connection;\n\n      //\n      // If this proxy is for a non-local object, and we are using a router, then\n      // add this proxy to the router info object.\n      //\n      var ri = this._reference.getRouterInfo();\n      if (ri !== null) {\n        ri.addProxy(this._proxy).then(\n        //\n        // The proxy was added to the router\n        // info, we're now ready to send the\n        // queued requests.\n        //\n        function () {\n          return _this.flushRequests();\n        }, function (ex) {\n          return _this.setException(ex);\n        });\n        return; // The request handler will be initialized once addProxy completes.\n      }\n\n      //\n      // We can now send the queued requests.\n      //\n      this.flushRequests();\n    }\n  }, {\n    key: \"setException\",\n    value: function setException(ex) {\n      var _this2 = this;\n      Debug.assert(!this._initialized && this._exception === null);\n      this._exception = ex;\n      this._proxies.length = 0;\n      this._proxy = null; // Break cyclic reference count.\n\n      //\n      // NOTE: remove the request handler *before* notifying the\n      // requests that the connection failed. It's important to ensure\n      // that future invocations will obtain a new connect request\n      // handler once invocations are notified.\n      //\n      try {\n        this._reference.getInstance().requestHandlerFactory().removeRequestHandler(this._reference, this);\n      } catch (exc) {\n        // Ignore\n      }\n      this._requests.forEach(function (request) {\n        if (request !== null) {\n          request.completedEx(_this2._exception);\n        }\n      });\n      this._requests.length = 0;\n    }\n  }, {\n    key: \"initialized\",\n    value: function initialized() {\n      if (this._initialized) {\n        Debug.assert(this._connection !== null);\n        return true;\n      } else if (this._exception !== null) {\n        if (this._connection !== null) {\n          //\n          // Only throw if the connection didn't get established. If\n          // it died after being established, we allow the caller to\n          // retry the connection establishment by not throwing here\n          // (the connection will throw RetryException).\n          //\n          return true;\n        }\n        throw this._exception;\n      } else {\n        return this._initialized;\n      }\n    }\n  }, {\n    key: \"flushRequests\",\n    value: function flushRequests() {\n      var _this3 = this;\n      Debug.assert(this._connection !== null && !this._initialized);\n      var exception = null;\n      this._requests.forEach(function (request) {\n        try {\n          request.invokeRemote(_this3._connection, _this3._response);\n        } catch (ex) {\n          if (ex instanceof RetryException) {\n            exception = ex.inner;\n\n            // Remove the request handler before retrying.\n            _this3._reference.getInstance().requestHandlerFactory().removeRequestHandler(_this3._reference, _this3);\n            request.retryException(ex.inner);\n          } else {\n            Debug.assert(ex instanceof LocalException);\n            exception = ex;\n            request.out.completedEx(ex);\n          }\n        }\n      });\n      this._requests.length = 0;\n      if (this._reference.getCacheConnection() && exception === null) {\n        this._requestHandler = new ConnectionRequestHandler(this._reference, this._connection);\n        this._proxies.forEach(function (proxy) {\n          return proxy._updateRequestHandler(_this3, _this3._requestHandler);\n        });\n      }\n      Debug.assert(!this._initialized);\n      this._exception = exception;\n      this._initialized = this._exception === null;\n\n      //\n      // Only remove once all the requests are flushed to\n      // guarantee serialization.\n      //\n      this._reference.getInstance().requestHandlerFactory().removeRequestHandler(this._reference, this);\n      this._proxies.length = 0;\n      this._proxy = null; // Break cyclic reference count.\n    }\n  }]);\n}();\nIce.ConnectRequestHandler = ConnectRequestHandler;\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/ConnectRequestHandler.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Connection.js":
/*!************************************************!*\
  !*** ./node_modules/ice/src/Ice/Connection.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `Connection.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nvar _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\");\n__webpack_require__(/*! ../Ice/ObjectPrx */ \"./node_modules/ice/src/Ice/ObjectPrx.js\");\n__webpack_require__(/*! ../Ice/Struct */ \"./node_modules/ice/src/Ice/Struct.js\");\n__webpack_require__(/*! ../Ice/EnumBase */ \"./node_modules/ice/src/Ice/EnumBase.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\n__webpack_require__(/*! ../Ice/ObjectAdapterF */ \"./node_modules/ice/src/Ice/ObjectAdapterF.js\");\n__webpack_require__(/*! ../Ice/Identity */ \"./node_modules/ice/src/Ice/Identity.js\");\n__webpack_require__(/*! ../Ice/Endpoint */ \"./node_modules/ice/src/Ice/Endpoint.js\");\nvar Ice = _ModuleRegistry.module(\"Ice\");\nvar Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n\n/**\n * The batch compression option when flushing queued batch requests.\n *\n **/\nIce.CompressBatch = Slice.defineEnum([['Yes', 0], ['No', 1], ['BasedOnProxy', 2]]);\n\n/**\n * Base class providing access to the connection details.\n *\n **/\nIce.ConnectionInfo = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function _class() {\n    var underlying = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var incoming = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var adapterName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n    var connectionId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"\";\n    _classCallCheck(this, _class);\n    this.underlying = underlying;\n    this.incoming = incoming;\n    this.adapterName = adapterName;\n    this.connectionId = connectionId;\n  }\n  return _createClass(_class);\n}();\n\n/**\n * Specifies the close semantics for Active Connection Management.\n **/\nIce.ACMClose = Slice.defineEnum([['CloseOff', 0], ['CloseOnIdle', 1], ['CloseOnInvocation', 2], ['CloseOnInvocationAndIdle', 3], ['CloseOnIdleForceful', 4]]);\n\n/**\n * Specifies the heartbeat semantics for Active Connection Management.\n **/\nIce.ACMHeartbeat = Slice.defineEnum([['HeartbeatOff', 0], ['HeartbeatOnDispatch', 1], ['HeartbeatOnIdle', 2], ['HeartbeatAlways', 3]]);\n\n/**\n * A collection of Active Connection Management configuration settings.\n **/\nIce.ACM = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function _class2() {\n    var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var close = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Ice.ACMClose.CloseOff;\n    var heartbeat = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Ice.ACMHeartbeat.HeartbeatOff;\n    _classCallCheck(this, _class2);\n    this.timeout = timeout;\n    this.close = close;\n    this.heartbeat = heartbeat;\n  }\n  return _createClass(_class2);\n}();\nSlice.defineStruct(Ice.ACM, true, true);\n\n/**\n * Determines the behavior when manually closing a connection.\n **/\nIce.ConnectionClose = Slice.defineEnum([['Forcefully', 0], ['Gracefully', 1], ['GracefullyWithWait', 2]]);\n\n/**\n * Provides access to the connection details of an IP connection\n *\n **/\nIce.IPConnectionInfo = /*#__PURE__*/function (_Ice$ConnectionInfo) {\n  \"use strict\";\n\n  function _class3(underlying, incoming, adapterName, connectionId) {\n    var _this;\n    var localAddress = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : \"\";\n    var localPort = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : -1;\n    var remoteAddress = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : \"\";\n    var remotePort = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : -1;\n    _classCallCheck(this, _class3);\n    _this = _callSuper(this, _class3, [underlying, incoming, adapterName, connectionId]);\n    _this.localAddress = localAddress;\n    _this.localPort = localPort;\n    _this.remoteAddress = remoteAddress;\n    _this.remotePort = remotePort;\n    return _this;\n  }\n  _inherits(_class3, _Ice$ConnectionInfo);\n  return _createClass(_class3);\n}(Ice.ConnectionInfo);\n\n/**\n * Provides access to the connection details of a TCP connection\n *\n **/\nIce.TCPConnectionInfo = /*#__PURE__*/function (_Ice$IPConnectionInfo) {\n  \"use strict\";\n\n  function _class4(underlying, incoming, adapterName, connectionId, localAddress, localPort, remoteAddress, remotePort) {\n    var _this2;\n    var rcvSize = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;\n    var sndSize = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 0;\n    _classCallCheck(this, _class4);\n    _this2 = _callSuper(this, _class4, [underlying, incoming, adapterName, connectionId, localAddress, localPort, remoteAddress, remotePort]);\n    _this2.rcvSize = rcvSize;\n    _this2.sndSize = sndSize;\n    return _this2;\n  }\n  _inherits(_class4, _Ice$IPConnectionInfo);\n  return _createClass(_class4);\n}(Ice.IPConnectionInfo);\n\n/**\n * Provides access to the connection details of a UDP connection\n *\n **/\nIce.UDPConnectionInfo = /*#__PURE__*/function (_Ice$IPConnectionInfo2) {\n  \"use strict\";\n\n  function _class5(underlying, incoming, adapterName, connectionId, localAddress, localPort, remoteAddress, remotePort) {\n    var _this3;\n    var mcastAddress = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : \"\";\n    var mcastPort = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : -1;\n    var rcvSize = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : 0;\n    var sndSize = arguments.length > 11 && arguments[11] !== undefined ? arguments[11] : 0;\n    _classCallCheck(this, _class5);\n    _this3 = _callSuper(this, _class5, [underlying, incoming, adapterName, connectionId, localAddress, localPort, remoteAddress, remotePort]);\n    _this3.mcastAddress = mcastAddress;\n    _this3.mcastPort = mcastPort;\n    _this3.rcvSize = rcvSize;\n    _this3.sndSize = sndSize;\n    return _this3;\n  }\n  _inherits(_class5, _Ice$IPConnectionInfo2);\n  return _createClass(_class5);\n}(Ice.IPConnectionInfo);\nSlice.defineDictionary(Ice, \"HeaderDict\", \"HeaderDictHelper\", \"Ice.StringHelper\", \"Ice.StringHelper\", false, undefined, undefined);\n\n/**\n * Provides access to the connection details of a WebSocket connection\n *\n **/\nIce.WSConnectionInfo = /*#__PURE__*/function (_Ice$ConnectionInfo2) {\n  \"use strict\";\n\n  function _class6(underlying, incoming, adapterName, connectionId) {\n    var _this4;\n    var headers = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    _classCallCheck(this, _class6);\n    _this4 = _callSuper(this, _class6, [underlying, incoming, adapterName, connectionId]);\n    _this4.headers = headers;\n    return _this4;\n  }\n  _inherits(_class6, _Ice$ConnectionInfo2);\n  return _createClass(_class6);\n}(Ice.ConnectionInfo);\n\n/* slice2js browser-bundle-skip */\nexports.Ice = Ice;\n/* slice2js browser-bundle-skip-end */\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/Connection.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/ConnectionF.js":
/*!*************************************************!*\
  !*** ./node_modules/ice/src/Ice/ConnectionF.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `ConnectionF.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nvar _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\nvar Ice = _ModuleRegistry.module(\"Ice\");\nvar Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n/* slice2js browser-bundle-skip */\nexports.Ice = Ice;\n/* slice2js browser-bundle-skip-end */\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/ConnectionF.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/ConnectionI.js":
/*!*************************************************!*\
  !*** ./node_modules/ice/src/Ice/ConnectionI.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n__webpack_require__(/*! ../Ice/AsyncStatus */ \"./node_modules/ice/src/Ice/AsyncStatus.js\");\n__webpack_require__(/*! ../Ice/Stream */ \"./node_modules/ice/src/Ice/Stream.js\");\n__webpack_require__(/*! ../Ice/OutgoingAsync */ \"./node_modules/ice/src/Ice/OutgoingAsync.js\");\n__webpack_require__(/*! ../Ice/Debug */ \"./node_modules/ice/src/Ice/Debug.js\");\n__webpack_require__(/*! ../Ice/ExUtil */ \"./node_modules/ice/src/Ice/ExUtil.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/IncomingAsync */ \"./node_modules/ice/src/Ice/IncomingAsync.js\");\n__webpack_require__(/*! ../Ice/RetryException */ \"./node_modules/ice/src/Ice/RetryException.js\");\n__webpack_require__(/*! ../Ice/Promise */ \"./node_modules/ice/src/Ice/Promise.js\");\n__webpack_require__(/*! ../Ice/Protocol */ \"./node_modules/ice/src/Ice/Protocol.js\");\n__webpack_require__(/*! ../Ice/SocketOperation */ \"./node_modules/ice/src/Ice/SocketOperation.js\");\n__webpack_require__(/*! ../Ice/Timer */ \"./node_modules/ice/src/Ice/Timer.js\");\n__webpack_require__(/*! ../Ice/TraceUtil */ \"./node_modules/ice/src/Ice/TraceUtil.js\");\n__webpack_require__(/*! ../Ice/Version */ \"./node_modules/ice/src/Ice/Version.js\");\n__webpack_require__(/*! ../Ice/Exception */ \"./node_modules/ice/src/Ice/Exception.js\");\n__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\");\n__webpack_require__(/*! ../Ice/BatchRequestQueue */ \"./node_modules/ice/src/Ice/BatchRequestQueue.js\");\nvar AsyncStatus = Ice.AsyncStatus;\nvar AsyncResultBase = Ice.AsyncResultBase;\nvar InputStream = Ice.InputStream;\nvar OutputStream = Ice.OutputStream;\nvar BatchRequestQueue = Ice.BatchRequestQueue;\nvar ConnectionFlushBatch = Ice.ConnectionFlushBatch;\nvar HeartbeatAsync = Ice.HeartbeatAsync;\nvar Debug = Ice.Debug;\nvar ExUtil = Ice.ExUtil;\nvar HashMap = Ice.HashMap;\nvar IncomingAsync = Ice.IncomingAsync;\nvar RetryException = Ice.RetryException;\nvar Protocol = Ice.Protocol;\nvar SocketOperation = Ice.SocketOperation;\nvar Timer = Ice.Timer;\nvar TraceUtil = Ice.TraceUtil;\nvar ProtocolVersion = Ice.ProtocolVersion;\nvar EncodingVersion = Ice.EncodingVersion;\nvar ACM = Ice.ACM;\nvar ACMClose = Ice.ACMClose;\nvar ACMHeartbeat = Ice.ACMHeartbeat;\nvar ConnectionClose = Ice.ConnectionClose;\nvar StateNotInitialized = 0;\nvar StateNotValidated = 1;\nvar StateActive = 2;\nvar StateHolding = 3;\nvar StateClosing = 4;\nvar StateClosed = 5;\nvar StateFinished = 6;\nvar MessageInfo = /*#__PURE__*/_createClass(function MessageInfo(instance) {\n  \"use strict\";\n\n  _classCallCheck(this, MessageInfo);\n  this.stream = new InputStream(instance, Protocol.currentProtocolEncoding);\n  this.invokeNum = 0;\n  this.requestId = 0;\n  this.servantManager = null;\n  this.adapter = null;\n  this.outAsync = null;\n  this.heartbeatCallback = null;\n});\nvar ConnectionI = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function ConnectionI(communicator, instance, monitor, transceiver, endpoint, incoming, adapter) {\n    _classCallCheck(this, ConnectionI);\n    this._communicator = communicator;\n    this._instance = instance;\n    this._monitor = monitor;\n    this._transceiver = transceiver;\n    this._desc = transceiver.toString();\n    this._type = transceiver.type();\n    this._endpoint = endpoint;\n    this._incoming = incoming;\n    this._adapter = adapter;\n    var initData = instance.initializationData();\n    this._logger = initData.logger; // Cached for better performance.\n    this._traceLevels = instance.traceLevels(); // Cached for better performance.\n    this._timer = instance.timer();\n    this._writeTimeoutId = 0;\n    this._writeTimeoutScheduled = false;\n    this._readTimeoutId = 0;\n    this._readTimeoutScheduled = false;\n    this._hasMoreData = {\n      value: false\n    };\n    this._warn = initData.properties.getPropertyAsInt(\"Ice.Warn.Connections\") > 0;\n    this._warnUdp = instance.initializationData().properties.getPropertyAsInt(\"Ice.Warn.Datagrams\") > 0;\n    this._acmLastActivity = this._monitor !== null && this._monitor.getACM().timeout > 0 ? Date.now() : -1;\n    this._nextRequestId = 1;\n    this._messageSizeMax = adapter ? adapter.messageSizeMax() : instance.messageSizeMax();\n    this._batchRequestQueue = new BatchRequestQueue(instance, endpoint.datagram());\n    this._sendStreams = [];\n    this._readStream = new InputStream(instance, Protocol.currentProtocolEncoding);\n    this._readHeader = false;\n    this._writeStream = new OutputStream(instance, Protocol.currentProtocolEncoding);\n    this._readStreamPos = -1;\n    this._writeStreamPos = -1;\n    this._dispatchCount = 0;\n    this._state = StateNotInitialized;\n    this._shutdownInitiated = false;\n    this._initialized = false;\n    this._validated = false;\n    this._readProtocol = new ProtocolVersion();\n    this._readProtocolEncoding = new EncodingVersion();\n    this._asyncRequests = new HashMap(); // Map<int, OutgoingAsync>\n\n    this._exception = null;\n    this._startPromise = null;\n    this._closePromises = [];\n    this._finishedPromises = [];\n    if (this._adapter !== null) {\n      this._servantManager = this._adapter.getServantManager();\n    } else {\n      this._servantManager = null;\n    }\n    this._closeCallback = null;\n    this._heartbeatCallback = null;\n  }\n  return _createClass(ConnectionI, [{\n    key: \"start\",\n    value: function start() {\n      var _this = this;\n      Debug.assert(this._startPromise === null);\n      try {\n        // The connection might already be closed if the communicator was destroyed.\n        if (this._state >= StateClosed) {\n          Debug.assert(this._exception !== null);\n          return Ice.Promise.reject(this._exception);\n        }\n        this._startPromise = new Ice.Promise();\n        this._transceiver.setCallbacks(function () {\n          return _this.message(SocketOperation.Write);\n        },\n        // connected callback\n        function () {\n          return _this.message(SocketOperation.Read);\n        },\n        // read callback\n        function () {\n          return _this.message(SocketOperation.Write);\n        } // write callback\n        );\n        this.initialize();\n      } catch (ex) {\n        var startPromise = this._startPromise;\n        this.exception(ex);\n        return startPromise;\n      }\n      return this._startPromise;\n    }\n  }, {\n    key: \"activate\",\n    value: function activate() {\n      if (this._state <= StateNotValidated) {\n        return;\n      }\n      if (this._acmLastActivity > 0) {\n        this._acmLastActivity = Date.now();\n      }\n      this.setState(StateActive);\n    }\n  }, {\n    key: \"hold\",\n    value: function hold() {\n      if (this._state <= StateNotValidated) {\n        return;\n      }\n      this.setState(StateHolding);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy(reason) {\n      switch (reason) {\n        case ConnectionI.ObjectAdapterDeactivated:\n          {\n            this.setState(StateClosing, new Ice.ObjectAdapterDeactivatedException());\n            break;\n          }\n        case ConnectionI.CommunicatorDestroyed:\n          {\n            this.setState(StateClosing, new Ice.CommunicatorDestroyedException());\n            break;\n          }\n        default:\n          {\n            Debug.assert(false);\n            break;\n          }\n      }\n    }\n  }, {\n    key: \"close\",\n    value: function close(mode) {\n      var r = new AsyncResultBase(this._communicator, \"close\", this, null, null);\n      if (mode == ConnectionClose.Forcefully) {\n        this.setState(StateClosed, new Ice.ConnectionManuallyClosedException(false));\n        r.resolve();\n      } else if (mode == ConnectionClose.Gracefully) {\n        this.setState(StateClosing, new Ice.ConnectionManuallyClosedException(true));\n        r.resolve();\n      } else {\n        Debug.assert(mode == ConnectionClose.GracefullyWithWait);\n\n        //\n        // Wait until all outstanding requests have been completed.\n        //\n        this._closePromises.push(r);\n        this.checkClose();\n      }\n      return r;\n    }\n  }, {\n    key: \"checkClose\",\n    value: function checkClose() {\n      var _this2 = this;\n      //\n      // If close(GracefullyWithWait) has been called, then we need to check if all\n      // requests have completed and we can transition to StateClosing. We also\n      // complete outstanding promises.\n      //\n      if (this._asyncRequests.size === 0 && this._closePromises.length > 0) {\n        //\n        // The caller doesn't expect the state of the connection to change when this is called so\n        // we defer the check immediately after doing whather we're doing. This is consistent with\n        // other implementations as well.\n        //\n        Timer.setImmediate(function () {\n          _this2.setState(StateClosing, new Ice.ConnectionManuallyClosedException(true));\n          _this2._closePromises.forEach(function (p) {\n            return p.resolve();\n          });\n          _this2._closePromises = [];\n        });\n      }\n    }\n  }, {\n    key: \"isActiveOrHolding\",\n    value: function isActiveOrHolding() {\n      return this._state > StateNotValidated && this._state < StateClosing;\n    }\n  }, {\n    key: \"isFinished\",\n    value: function isFinished() {\n      if (this._state !== StateFinished || this._dispatchCount !== 0) {\n        return false;\n      }\n      Debug.assert(this._state === StateFinished);\n      return true;\n    }\n  }, {\n    key: \"throwException\",\n    value: function throwException() {\n      if (this._exception !== null) {\n        Debug.assert(this._state >= StateClosing);\n        throw this._exception;\n      }\n    }\n  }, {\n    key: \"waitUntilFinished\",\n    value: function waitUntilFinished() {\n      var promise = new Ice.Promise();\n      this._finishedPromises.push(promise);\n      this.checkState();\n      return promise;\n    }\n  }, {\n    key: \"monitor\",\n    value: function monitor(now, acm) {\n      if (this._state !== StateActive) {\n        return;\n      }\n\n      //\n      // We send a heartbeat if there was no activity in the last\n      // (timeout / 4) period. Sending a heartbeat sooner than\n      // really needed is safer to ensure that the receiver will\n      // receive the heartbeat in time. Sending the heartbeat if\n      // there was no activity in the last (timeout / 2) period\n      // isn't enough since monitor() is called only every (timeout\n      // / 2) period.\n      //\n      // Note that this doesn't imply that we are sending 4 heartbeats\n      // per timeout period because the monitor() method is still only\n      // called every (timeout / 2) period.\n      //\n      if (acm.heartbeat == Ice.ACMHeartbeat.HeartbeatAlways || acm.heartbeat != Ice.ACMHeartbeat.HeartbeatOff && this._writeStream.isEmpty() && now >= this._acmLastActivity + acm.timeout / 4) {\n        if (acm.heartbeat != Ice.ACMHeartbeat.HeartbeatOnDispatch || this._dispatchCount > 0) {\n          this.sendHeartbeatNow(); // Send heartbeat if idle in the last timeout / 2 period.\n        }\n      }\n      if (this._readStream.size > Protocol.headerSize || !this._writeStream.isEmpty()) {\n        //\n        // If writing or reading, nothing to do, the connection\n        // timeout will kick-in if writes or reads don't progress.\n        // This check is necessary because the actitivy timer is\n        // only set when a message is fully read/written.\n        //\n        return;\n      }\n      if (acm.close != Ice.ACMClose.CloseOff && now >= this._acmLastActivity + acm.timeout) {\n        if (acm.close == Ice.ACMClose.CloseOnIdleForceful || acm.close != Ice.ACMClose.CloseOnIdle && this._asyncRequests.size > 0) {\n          //\n          // Close the connection if we didn't receive a heartbeat in\n          // the last period.\n          //\n          this.setState(StateClosed, new Ice.ConnectionTimeoutException());\n        } else if (acm.close != Ice.ACMClose.CloseOnInvocation && this._dispatchCount === 0 && this._batchRequestQueue.isEmpty() && this._asyncRequests.size === 0) {\n          //\n          // The connection is idle, close it.\n          //\n          this.setState(StateClosing, new Ice.ConnectionTimeoutException());\n        }\n      }\n    }\n  }, {\n    key: \"sendAsyncRequest\",\n    value: function sendAsyncRequest(out, response, batchRequestNum) {\n      var requestId = 0;\n      var ostr = out.getOs();\n      if (this._exception !== null) {\n        //\n        // If the connection is closed before we even have a chance\n        // to send our request, we always try to send the request\n        // again.\n        //\n        throw new RetryException(this._exception);\n      }\n      Debug.assert(this._state > StateNotValidated);\n      Debug.assert(this._state < StateClosing);\n\n      //\n      // Ensure the message isn't bigger than what we can send with the\n      // transport.\n      //\n      this._transceiver.checkSendSize(ostr);\n\n      //\n      // Notify the request that it's cancelable with this connection.\n      // This will throw if the request is canceled.\n      //\n      out.cancelable(this); // Notify the request that it's cancelable\n\n      if (response) {\n        //\n        // Create a new unique request ID.\n        //\n        requestId = this._nextRequestId++;\n        if (requestId <= 0) {\n          this._nextRequestId = 1;\n          requestId = this._nextRequestId++;\n        }\n\n        //\n        // Fill in the request ID.\n        //\n        ostr.pos = Protocol.headerSize;\n        ostr.writeInt(requestId);\n      } else if (batchRequestNum > 0) {\n        ostr.pos = Protocol.headerSize;\n        ostr.writeInt(batchRequestNum);\n      }\n      var status;\n      try {\n        status = this.sendMessage(OutgoingMessage.create(out, out.getOs(), requestId));\n      } catch (ex) {\n        if (ex instanceof Ice.LocalException) {\n          this.setState(StateClosed, ex);\n          Debug.assert(this._exception !== null);\n          throw this._exception;\n        } else {\n          throw ex;\n        }\n      }\n      if (response) {\n        //\n        // Add to the async requests map.\n        //\n        this._asyncRequests.set(requestId, out);\n      }\n      return status;\n    }\n  }, {\n    key: \"getBatchRequestQueue\",\n    value: function getBatchRequestQueue() {\n      return this._batchRequestQueue;\n    }\n  }, {\n    key: \"flushBatchRequests\",\n    value: function flushBatchRequests() {\n      var result = new ConnectionFlushBatch(this, this._communicator, \"flushBatchRequests\");\n      result.invoke();\n      return result;\n    }\n  }, {\n    key: \"setCloseCallback\",\n    value: function setCloseCallback(callback) {\n      var _this3 = this;\n      if (this._state >= StateClosed) {\n        if (callback !== null) {\n          Timer.setImmediate(function () {\n            try {\n              callback(_this3);\n            } catch (ex) {\n              _this3._logger.error(\"connection callback exception:\\n\" + ex + '\\n' + _this3._desc);\n            }\n          });\n        }\n      } else {\n        this._closeCallback = callback;\n      }\n    }\n  }, {\n    key: \"setHeartbeatCallback\",\n    value: function setHeartbeatCallback(callback) {\n      if (this._state >= StateClosed) {\n        return;\n      }\n      this._heartbeatCallback = callback;\n    }\n  }, {\n    key: \"heartbeat\",\n    value: function heartbeat() {\n      var result = new HeartbeatAsync(this, this._communicator);\n      result.invoke();\n      return result;\n    }\n  }, {\n    key: \"setACM\",\n    value: function setACM(timeout, close, heartbeat) {\n      if (timeout !== undefined && timeout < 0) {\n        throw new RangeError(\"invalid negative ACM timeout value\");\n      }\n      if (this._monitor === null || this._state >= StateClosed) {\n        return;\n      }\n      if (this._state == StateActive) {\n        this._monitor.remove(this);\n      }\n      this._monitor = this._monitor.acm(timeout, close, heartbeat);\n      if (this._state == StateActive) {\n        this._monitor.add(this);\n      }\n      if (this._monitor.getACM().timeout <= 0) {\n        this._acmLastActivity = -1; // Disable the recording of last activity.\n      } else if (this._state == StateActive && this._acmLastActivity == -1) {\n        this._acmLastActivity = Date.now();\n      }\n    }\n  }, {\n    key: \"getACM\",\n    value: function getACM() {\n      return this._monitor !== null ? this._monitor.getACM() : new ACM(0, ACMClose.CloseOff, ACMHeartbeat.HeartbeatOff);\n    }\n  }, {\n    key: \"asyncRequestCanceled\",\n    value: function asyncRequestCanceled(outAsync, ex) {\n      for (var i = 0; i < this._sendStreams.length; i++) {\n        var o = this._sendStreams[i];\n        if (o.outAsync === outAsync) {\n          if (o.requestId > 0) {\n            this._asyncRequests[\"delete\"](o.requestId);\n          }\n\n          //\n          // If the request is being sent, don't remove it from the send streams,\n          // it will be removed once the sending is finished.\n          //\n          o.canceled();\n          if (i !== 0) {\n            this._sendStreams.splice(i, 1);\n          }\n          outAsync.completedEx(ex);\n          this.checkClose();\n          return; // We're done.\n        }\n      }\n      if (outAsync instanceof Ice.OutgoingAsync) {\n        var _iterator = _createForOfIteratorHelper(this._asyncRequests),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _step$value = _slicedToArray(_step.value, 2),\n              key = _step$value[0],\n              value = _step$value[1];\n            if (value === outAsync) {\n              this._asyncRequests[\"delete\"](key);\n              outAsync.completedEx(ex);\n              this.checkClose();\n              return; // We're done.\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n    }\n  }, {\n    key: \"sendResponse\",\n    value: function sendResponse(os) {\n      Debug.assert(this._state > StateNotValidated);\n      try {\n        if (--this._dispatchCount === 0) {\n          if (this._state === StateFinished) {\n            this.reap();\n          }\n          this.checkState();\n        }\n        if (this._state >= StateClosed) {\n          Debug.assert(this._exception !== null);\n          throw this._exception;\n        }\n        this.sendMessage(OutgoingMessage.createForStream(os, true));\n        if (this._state === StateClosing && this._dispatchCount === 0) {\n          this.initiateShutdown();\n        }\n      } catch (ex) {\n        if (ex instanceof Ice.LocalException) {\n          this.setState(StateClosed, ex);\n        } else {\n          throw ex;\n        }\n      }\n    }\n  }, {\n    key: \"sendNoResponse\",\n    value: function sendNoResponse() {\n      Debug.assert(this._state > StateNotValidated);\n      try {\n        if (--this._dispatchCount === 0) {\n          if (this._state === StateFinished) {\n            this.reap();\n          }\n          this.checkState();\n        }\n        if (this._state >= StateClosed) {\n          Debug.assert(this._exception !== null);\n          throw this._exception;\n        }\n        if (this._state === StateClosing && this._dispatchCount === 0) {\n          this.initiateShutdown();\n        }\n      } catch (ex) {\n        if (ex instanceof Ice.LocalException) {\n          this.setState(StateClosed, ex);\n        } else {\n          throw ex;\n        }\n      }\n    }\n  }, {\n    key: \"endpoint\",\n    value: function endpoint() {\n      return this._endpoint;\n    }\n  }, {\n    key: \"setAdapter\",\n    value: function setAdapter(adapter) {\n      if (adapter !== null) {\n        adapter.checkForDeactivation();\n        if (this._state <= StateNotValidated || this._state >= StateClosing) {\n          return;\n        }\n        this._adapter = adapter;\n        this._servantManager = adapter.getServantManager(); // The OA's servant manager is immutable.\n      } else {\n        if (this._state <= StateNotValidated || this._state >= StateClosing) {\n          return;\n        }\n        this._adapter = null;\n        this._servantManager = null;\n      }\n    }\n  }, {\n    key: \"getAdapter\",\n    value: function getAdapter() {\n      return this._adapter;\n    }\n  }, {\n    key: \"getEndpoint\",\n    value: function getEndpoint() {\n      return this._endpoint;\n    }\n  }, {\n    key: \"createProxy\",\n    value: function createProxy(ident) {\n      //\n      // Create a reference and return a reverse proxy for this\n      // reference.\n      //\n      return this._instance.proxyFactory().referenceToProxy(this._instance.referenceFactory().createFixed(ident, this));\n    }\n  }, {\n    key: \"message\",\n    value: function message(operation) {\n      var _this4 = this;\n      if (this._state >= StateClosed) {\n        return;\n      }\n      this.unscheduleTimeout(operation);\n\n      //\n      // Keep reading until no more data is available.\n      //\n      this._hasMoreData.value = (operation & SocketOperation.Read) !== 0;\n      var info = null;\n      try {\n        if ((operation & SocketOperation.Write) !== 0 && this._writeStream.buffer.remaining > 0) {\n          if (!this.write(this._writeStream.buffer)) {\n            Debug.assert(!this._writeStream.isEmpty());\n            this.scheduleTimeout(SocketOperation.Write);\n            return;\n          }\n          Debug.assert(this._writeStream.buffer.remaining === 0);\n        }\n        if ((operation & SocketOperation.Read) !== 0 && !this._readStream.isEmpty()) {\n          if (this._readHeader)\n            // Read header if necessary.\n            {\n              if (!this.read(this._readStream.buffer)) {\n                //\n                // We didn't get enough data to complete the header.\n                //\n                return;\n              }\n              Debug.assert(this._readStream.buffer.remaining === 0);\n              this._readHeader = false;\n\n              //\n              // Connection is validated on first message. This is only used by\n              // setState() to check wether or not we can print a connection\n              // warning (a client might close the connection forcefully if the\n              // connection isn't validated, we don't want to print a warning\n              // in this case).\n              //\n              this._validated = true;\n              var pos = this._readStream.pos;\n              if (pos < Protocol.headerSize) {\n                //\n                // This situation is possible for small UDP packets.\n                //\n                throw new Ice.IllegalMessageSizeException();\n              }\n              this._readStream.pos = 0;\n              var magic0 = this._readStream.readByte();\n              var magic1 = this._readStream.readByte();\n              var magic2 = this._readStream.readByte();\n              var magic3 = this._readStream.readByte();\n              if (magic0 !== Protocol.magic[0] || magic1 !== Protocol.magic[1] || magic2 !== Protocol.magic[2] || magic3 !== Protocol.magic[3]) {\n                throw new Ice.BadMagicException(\"\", new Uint8Array([magic0, magic1, magic2, magic3]));\n              }\n              this._readProtocol._read(this._readStream);\n              Protocol.checkSupportedProtocol(this._readProtocol);\n              this._readProtocolEncoding._read(this._readStream);\n              Protocol.checkSupportedProtocolEncoding(this._readProtocolEncoding);\n              this._readStream.readByte(); // messageType\n              this._readStream.readByte(); // compress\n              var size = this._readStream.readInt();\n              if (size < Protocol.headerSize) {\n                throw new Ice.IllegalMessageSizeException();\n              }\n              if (size > this._messageSizeMax) {\n                ExUtil.throwMemoryLimitException(size, this._messageSizeMax);\n              }\n              if (size > this._readStream.size) {\n                this._readStream.resize(size);\n              }\n              this._readStream.pos = pos;\n            }\n          if (this._readStream.pos != this._readStream.size) {\n            if (this._endpoint.datagram()) {\n              throw new Ice.DatagramLimitException(); // The message was truncated.\n            } else {\n              if (!this.read(this._readStream.buffer)) {\n                Debug.assert(!this._readStream.isEmpty());\n                this.scheduleTimeout(SocketOperation.Read);\n                return;\n              }\n              Debug.assert(this._readStream.buffer.remaining === 0);\n            }\n          }\n        }\n        if (this._state <= StateNotValidated) {\n          if (this._state === StateNotInitialized && !this.initialize()) {\n            return;\n          }\n          if (this._state <= StateNotValidated && !this.validate()) {\n            return;\n          }\n          this._transceiver.unregister();\n\n          //\n          // We start out in holding state.\n          //\n          this.setState(StateHolding);\n          if (this._startPromise !== null) {\n            ++this._dispatchCount;\n          }\n        } else {\n          Debug.assert(this._state <= StateClosing);\n\n          //\n          // We parse messages first, if we receive a close\n          // connection message we won't send more messages.\n          //\n          if ((operation & SocketOperation.Read) !== 0) {\n            info = this.parseMessage();\n          }\n          if ((operation & SocketOperation.Write) !== 0) {\n            this.sendNextMessage();\n          }\n        }\n      } catch (ex) {\n        if (ex instanceof Ice.DatagramLimitException)\n          // Expected.\n          {\n            if (this._warnUdp) {\n              this._logger.warning(\"maximum datagram size of \" + this._readStream.pos + \" exceeded\");\n            }\n            this._readStream.resize(Protocol.headerSize);\n            this._readStream.pos = 0;\n            this._readHeader = true;\n            return;\n          } else if (ex instanceof Ice.SocketException) {\n          this.setState(StateClosed, ex);\n          return;\n        } else if (ex instanceof Ice.LocalException) {\n          if (this._endpoint.datagram()) {\n            if (this._warn) {\n              this._logger.warning(\"datagram connection exception:\\n\" + ex + '\\n' + this._desc);\n            }\n            this._readStream.resize(Protocol.headerSize);\n            this._readStream.pos = 0;\n            this._readHeader = true;\n          } else {\n            this.setState(StateClosed, ex);\n          }\n          return;\n        } else {\n          throw ex;\n        }\n      }\n      if (this._acmLastActivity > 0) {\n        this._acmLastActivity = Date.now();\n      }\n      this.dispatch(info);\n      if (this._hasMoreData.value) {\n        Timer.setImmediate(function () {\n          return _this4.message(SocketOperation.Read);\n        }); // Don't tie up the thread.\n      }\n    }\n  }, {\n    key: \"dispatch\",\n    value: function dispatch(info) {\n      var count = 0;\n      //\n      // Notify the factory that the connection establishment and\n      // validation has completed.\n      //\n      if (this._startPromise !== null) {\n        this._startPromise.resolve();\n        this._startPromise = null;\n        ++count;\n      }\n      if (info !== null) {\n        if (info.outAsync !== null) {\n          info.outAsync.completed(info.stream);\n          ++count;\n        }\n        if (info.invokeNum > 0) {\n          this.invokeAll(info.stream, info.invokeNum, info.requestId, info.servantManager, info.adapter);\n\n          //\n          // Don't increase count, the dispatch count is\n          // decreased when the incoming reply is sent.\n          //\n        }\n        if (info.heartbeatCallback) {\n          try {\n            info.heartbeatCallback(this);\n          } catch (ex) {\n            this._logger.error(\"connection callback exception:\\n\" + ex + '\\n' + this._desc);\n          }\n          info.heartbeatCallback = null;\n          ++count;\n        }\n      }\n\n      //\n      // Decrease dispatch count.\n      //\n      if (count > 0) {\n        this._dispatchCount -= count;\n        if (this._dispatchCount === 0) {\n          if (this._state === StateClosing) {\n            try {\n              this.initiateShutdown();\n            } catch (ex) {\n              if (ex instanceof Ice.LocalException) {\n                this.setState(StateClosed, ex);\n              } else {\n                throw ex;\n              }\n            }\n          } else if (this._state === StateFinished) {\n            this.reap();\n          }\n          this.checkState();\n        }\n      }\n    }\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      Debug.assert(this._state === StateClosed);\n      this.unscheduleTimeout(SocketOperation.Read | SocketOperation.Write | SocketOperation.Connect);\n      var traceLevels = this._instance.traceLevels();\n      if (!this._initialized) {\n        if (traceLevels.network >= 2) {\n          var s = [];\n          s.push(\"failed to establish \");\n          s.push(this._endpoint.protocol());\n          s.push(\" connection\\n\");\n          s.push(this.toString());\n          s.push(\"\\n\");\n          s.push(this._exception.toString());\n          this._instance.initializationData().logger.trace(traceLevels.networkCat, s.join(\"\"));\n        }\n      } else if (traceLevels.network >= 1) {\n        var _s = [];\n        _s.push(\"closed \");\n        _s.push(this._endpoint.protocol());\n        _s.push(\" connection\\n\");\n        _s.push(this.toString());\n\n        //\n        // Trace the cause of unexpected connection closures\n        //\n        if (!(this._exception instanceof Ice.CloseConnectionException || this._exception instanceof Ice.ConnectionManuallyClosedException || this._exception instanceof Ice.ConnectionTimeoutException || this._exception instanceof Ice.CommunicatorDestroyedException || this._exception instanceof Ice.ObjectAdapterDeactivatedException)) {\n          _s.push(\"\\n\");\n          _s.push(this._exception.toString());\n        }\n        this._instance.initializationData().logger.trace(traceLevels.networkCat, _s.join(\"\"));\n      }\n      if (this._startPromise !== null) {\n        this._startPromise.reject(this._exception);\n        this._startPromise = null;\n      }\n      if (this._sendStreams.length > 0) {\n        if (!this._writeStream.isEmpty()) {\n          //\n          // Return the stream to the outgoing call. This is important for\n          // retriable AMI calls which are not marshalled again.\n          //\n          this._writeStream.swap(this._sendStreams[0].stream);\n        }\n\n        //\n        // NOTE: for twoway requests which are not sent, finished can be called twice: the\n        // first time because the outgoing is in the _sendStreams set and the second time\n        // because it's either in the _requests/_asyncRequests set. This is fine, only the\n        // first call should be taken into account by the implementation of finished.\n        //\n        for (var i = 0; i < this._sendStreams.length; ++i) {\n          var p = this._sendStreams[i];\n          if (p.requestId > 0) {\n            this._asyncRequests[\"delete\"](p.requestId);\n          }\n          p.completed(this._exception);\n        }\n        this._sendStreams = [];\n      }\n      var _iterator2 = _createForOfIteratorHelper(this._asyncRequests.values()),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var value = _step2.value;\n          value.completedEx(this._exception);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      this._asyncRequests.clear();\n      this.checkClose();\n\n      //\n      // Don't wait to be reaped to reclaim memory allocated by read/write streams.\n      //\n      this._readStream.clear();\n      this._readStream.buffer.clear();\n      this._writeStream.clear();\n      this._writeStream.buffer.clear();\n      if (this._closeCallback !== null) {\n        try {\n          this._closeCallback(this);\n        } catch (ex) {\n          this._logger.error(\"connection callback exception:\\n\" + ex + '\\n' + this._desc);\n        }\n        this._closeCallback = null;\n      }\n      this._heartbeatCallback = null;\n\n      //\n      // This must be done last as this will cause waitUntilFinished() to return (and communicator\n      // objects such as the timer might be destroyed too).\n      //\n      if (this._dispatchCount === 0) {\n        this.reap();\n      }\n      this.setState(StateFinished);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this._desc;\n    }\n  }, {\n    key: \"timedOut\",\n    value: function timedOut(event) {\n      if (this._state <= StateNotValidated) {\n        this.setState(StateClosed, new Ice.ConnectTimeoutException());\n      } else if (this._state < StateClosing) {\n        this.setState(StateClosed, new Ice.TimeoutException());\n      } else if (this._state === StateClosing) {\n        this.setState(StateClosed, new Ice.CloseTimeoutException());\n      }\n    }\n  }, {\n    key: \"type\",\n    value: function type() {\n      return this._type;\n    }\n  }, {\n    key: \"timeout\",\n    value: function timeout() {\n      return this._endpoint.timeout();\n    }\n  }, {\n    key: \"getInfo\",\n    value: function getInfo() {\n      if (this._state >= StateClosed) {\n        throw this._exception;\n      }\n      var info = this._transceiver.getInfo();\n      for (var p = info; p !== null; p = p.underlying) {\n        p.adapterName = this._adapter !== null ? this._adapter.getName() : \"\";\n        p.incoming = this._incoming;\n      }\n      return info;\n    }\n  }, {\n    key: \"setBufferSize\",\n    value: function setBufferSize(rcvSize, sndSize) {\n      if (this._state >= StateClosed) {\n        throw this._exception;\n      }\n      this._transceiver.setBufferSize(rcvSize, sndSize);\n    }\n  }, {\n    key: \"exception\",\n    value: function exception(ex) {\n      this.setState(StateClosed, ex);\n    }\n  }, {\n    key: \"invokeException\",\n    value: function invokeException(ex, invokeNum) {\n      //\n      // Fatal exception while invoking a request. Since sendResponse/sendNoResponse isn't\n      // called in case of a fatal exception we decrement this._dispatchCount here.\n      //\n\n      this.setState(StateClosed, ex);\n      if (invokeNum > 0) {\n        Debug.assert(this._dispatchCount > 0);\n        this._dispatchCount -= invokeNum;\n        Debug.assert(this._dispatchCount >= 0);\n        if (this._dispatchCount === 0) {\n          if (this._state === StateFinished) {\n            this.reap();\n          }\n          this.checkState();\n        }\n      }\n    }\n  }, {\n    key: \"setState\",\n    value: function setState(state, ex) {\n      if (ex !== undefined) {\n        Debug.assert(ex instanceof Ice.LocalException);\n\n        //\n        // If setState() is called with an exception, then only closed\n        // and closing states are permissible.\n        //\n        Debug.assert(state >= StateClosing);\n        if (this._state === state)\n          // Don't switch twice.\n          {\n            return;\n          }\n        if (this._exception === null) {\n          this._exception = ex;\n\n          //\n          // We don't warn if we are not validated.\n          //\n          if (this._warn && this._validated) {\n            //\n            // Don't warn about certain expected exceptions.\n            //\n            if (!(this._exception instanceof Ice.CloseConnectionException || this._exception instanceof Ice.ConnectionManuallyClosedException || this._exception instanceof Ice.ConnectionTimeoutException || this._exception instanceof Ice.CommunicatorDestroyedException || this._exception instanceof Ice.ObjectAdapterDeactivatedException || this._exception instanceof Ice.ConnectionLostException && this._state === StateClosing)) {\n              this.warning(\"connection exception\", this._exception);\n            }\n          }\n        }\n\n        //\n        // We must set the new state before we notify requests of any\n        // exceptions. Otherwise new requests may retry on a\n        // connection that is not yet marked as closed or closing.\n        //\n      }\n\n      //\n      // We don't want to send close connection messages if the endpoint\n      // only supports oneway transmission from client to server.\n      //\n      if (this._endpoint.datagram() && state === StateClosing) {\n        state = StateClosed;\n      }\n\n      //\n      // Skip graceful shutdown if we are destroyed before validation.\n      //\n      if (this._state <= StateNotValidated && state === StateClosing) {\n        state = StateClosed;\n      }\n      if (this._state === state)\n        // Don't switch twice.\n        {\n          return;\n        }\n      try {\n        switch (state) {\n          case StateNotInitialized:\n            {\n              Debug.assert(false);\n              break;\n            }\n          case StateNotValidated:\n            {\n              if (this._state !== StateNotInitialized) {\n                Debug.assert(this._state === StateClosed);\n                return;\n              }\n              //\n              // Register to receive validation message.\n              //\n              if (!this._endpoint.datagram() && !this._incoming) {\n                //\n                // Once validation is complete, a new connection starts out in the\n                // Holding state. We only want to register the transceiver now if we\n                // need to receive data in order to validate the connection.\n                //\n                this._transceiver.register();\n              }\n              break;\n            }\n          case StateActive:\n            {\n              //\n              // Can only switch from holding or not validated to\n              // active.\n              //\n              if (this._state !== StateHolding && this._state !== StateNotValidated) {\n                return;\n              }\n              this._transceiver.register();\n              break;\n            }\n          case StateHolding:\n            {\n              //\n              // Can only switch from active or not validated to\n              // holding.\n              //\n              if (this._state !== StateActive && this._state !== StateNotValidated) {\n                return;\n              }\n              if (this._state === StateActive) {\n                this._transceiver.unregister();\n              }\n              break;\n            }\n          case StateClosing:\n            {\n              //\n              // Can't change back from closed.\n              //\n              if (this._state >= StateClosed) {\n                return;\n              }\n              if (this._state === StateHolding) {\n                // We need to continue to read in closing state.\n                this._transceiver.register();\n              }\n              break;\n            }\n          case StateClosed:\n            {\n              if (this._state === StateFinished) {\n                return;\n              }\n              this._batchRequestQueue.destroy(this._exception);\n              this._transceiver.unregister();\n              break;\n            }\n          case StateFinished:\n            {\n              Debug.assert(this._state === StateClosed);\n              this._transceiver.close();\n              this._communicator = null;\n              break;\n            }\n          default:\n            {\n              Debug.assert(false);\n              break;\n            }\n        }\n      } catch (ex) {\n        if (ex instanceof Ice.LocalException) {\n          this._instance.initializationData().logger.error(\"unexpected connection exception:\\n\".concat(this._desc, \"\\n\").concat(ex.toString()));\n        } else {\n          throw ex;\n        }\n      }\n\n      //\n      // We only register with the connection monitor if our new state\n      // is StateActive. Otherwise we unregister with the connection\n      // monitor, but only if we were registered before, i.e., if our\n      // old state was StateActive.\n      //\n      if (this._monitor !== null) {\n        if (state === StateActive) {\n          this._monitor.add(this);\n          if (this._acmLastActivity > 0) {\n            this._acmLastActivity = Date.now();\n          }\n        } else if (this._state === StateActive) {\n          this._monitor.remove(this);\n        }\n      }\n      this._state = state;\n      if (this._state === StateClosing && this._dispatchCount === 0) {\n        try {\n          this.initiateShutdown();\n        } catch (ex) {\n          if (ex instanceof Ice.LocalException) {\n            this.setState(StateClosed, ex);\n          } else {\n            throw ex;\n          }\n        }\n      } else if (this._state === StateClosed) {\n        this.finish();\n      }\n      this.checkState();\n    }\n  }, {\n    key: \"initiateShutdown\",\n    value: function initiateShutdown() {\n      Debug.assert(this._state === StateClosing && this._dispatchCount === 0);\n      if (this._shutdownInitiated) {\n        return;\n      }\n      this._shutdownInitiated = true;\n      if (!this._endpoint.datagram()) {\n        //\n        // Before we shut down, we send a close connection message.\n        //\n        var os = new OutputStream(this._instance, Protocol.currentProtocolEncoding);\n        os.writeBlob(Protocol.magic);\n        Protocol.currentProtocol._write(os);\n        Protocol.currentProtocolEncoding._write(os);\n        os.writeByte(Protocol.closeConnectionMsg);\n        os.writeByte(0); // compression status: always report 0 for CloseConnection.\n        os.writeInt(Protocol.headerSize); // Message size.\n\n        if ((this.sendMessage(OutgoingMessage.createForStream(os, false)) & AsyncStatus.Sent) > 0) {\n          //\n          // Schedule the close timeout to wait for the peer to close the connection.\n          //\n          this.scheduleTimeout(SocketOperation.Read);\n        }\n      }\n    }\n  }, {\n    key: \"sendHeartbeatNow\",\n    value: function sendHeartbeatNow() {\n      Debug.assert(this._state === StateActive);\n      if (!this._endpoint.datagram()) {\n        var os = new OutputStream(this._instance, Protocol.currentProtocolEncoding);\n        os.writeBlob(Protocol.magic);\n        Protocol.currentProtocol._write(os);\n        Protocol.currentProtocolEncoding._write(os);\n        os.writeByte(Protocol.validateConnectionMsg);\n        os.writeByte(0);\n        os.writeInt(Protocol.headerSize); // Message size.\n        try {\n          this.sendMessage(OutgoingMessage.createForStream(os, false));\n        } catch (ex) {\n          this.setState(StateClosed, ex);\n          Debug.assert(this._exception !== null);\n        }\n      }\n    }\n  }, {\n    key: \"initialize\",\n    value: function initialize() {\n      var s = this._transceiver.initialize(this._readStream.buffer, this._writeStream.buffer);\n      if (s != SocketOperation.None) {\n        this.scheduleTimeout(s);\n        return false;\n      }\n\n      //\n      // Update the connection description once the transceiver is initialized.\n      //\n      this._desc = this._transceiver.toString();\n      this._initialized = true;\n      this.setState(StateNotValidated);\n      return true;\n    }\n  }, {\n    key: \"validate\",\n    value: function validate() {\n      if (!this._endpoint.datagram())\n        // Datagram connections are always implicitly validated.\n        {\n          if (this._adapter !== null)\n            // The server side has the active role for connection validation.\n            {\n              if (this._writeStream.size === 0) {\n                this._writeStream.writeBlob(Protocol.magic);\n                Protocol.currentProtocol._write(this._writeStream);\n                Protocol.currentProtocolEncoding._write(this._writeStream);\n                this._writeStream.writeByte(Protocol.validateConnectionMsg);\n                this._writeStream.writeByte(0); // Compression status (always zero for validate connection).\n                this._writeStream.writeInt(Protocol.headerSize); // Message size.\n                TraceUtil.traceSend(this._writeStream, this._logger, this._traceLevels);\n                this._writeStream.prepareWrite();\n              }\n              if (this._writeStream.pos != this._writeStream.size && !this.write(this._writeStream.buffer)) {\n                this.scheduleTimeout(SocketOperation.Write);\n                return false;\n              }\n            } else\n            // The client side has the passive role for connection validation.\n            {\n              if (this._readStream.size === 0) {\n                this._readStream.resize(Protocol.headerSize);\n                this._readStream.pos = 0;\n              }\n              if (this._readStream.pos !== this._readStream.size && !this.read(this._readStream.buffer)) {\n                this.scheduleTimeout(SocketOperation.Read);\n                return false;\n              }\n              this._validated = true;\n              Debug.assert(this._readStream.pos === Protocol.headerSize);\n              this._readStream.pos = 0;\n              var m = this._readStream.readBlob(4);\n              if (m[0] !== Protocol.magic[0] || m[1] !== Protocol.magic[1] || m[2] !== Protocol.magic[2] || m[3] !== Protocol.magic[3]) {\n                throw new Ice.BadMagicException(\"\", m);\n              }\n              this._readProtocol._read(this._readStream);\n              Protocol.checkSupportedProtocol(this._readProtocol);\n              this._readProtocolEncoding._read(this._readStream);\n              Protocol.checkSupportedProtocolEncoding(this._readProtocolEncoding);\n              var messageType = this._readStream.readByte();\n              if (messageType !== Protocol.validateConnectionMsg) {\n                throw new Ice.ConnectionNotValidatedException();\n              }\n              this._readStream.readByte(); // Ignore compression status for validate connection.\n              if (this._readStream.readInt() !== Protocol.headerSize) {\n                throw new Ice.IllegalMessageSizeException();\n              }\n              TraceUtil.traceRecv(this._readStream, this._logger, this._traceLevels);\n            }\n        }\n      this._writeStream.resize(0);\n      this._writeStream.pos = 0;\n      this._readStream.resize(Protocol.headerSize);\n      this._readHeader = true;\n      this._readStream.pos = 0;\n      var traceLevels = this._instance.traceLevels();\n      if (traceLevels.network >= 1) {\n        var s = [];\n        if (this._endpoint.datagram()) {\n          s.push(\"starting to send \");\n          s.push(this._endpoint.protocol());\n          s.push(\" messages\\n\");\n          s.push(this._transceiver.toDetailedString());\n        } else {\n          s.push(\"established \");\n          s.push(this._endpoint.protocol());\n          s.push(\" connection\\n\");\n          s.push(this.toString());\n        }\n        this._instance.initializationData().logger.trace(traceLevels.networkCat, s.join(\"\"));\n      }\n      return true;\n    }\n  }, {\n    key: \"sendNextMessage\",\n    value: function sendNextMessage() {\n      if (this._sendStreams.length === 0) {\n        return;\n      }\n      Debug.assert(!this._writeStream.isEmpty() && this._writeStream.pos === this._writeStream.size);\n      try {\n        while (true) {\n          //\n          // Notify the message that it was sent.\n          //\n          var message = this._sendStreams.shift();\n          this._writeStream.swap(message.stream);\n          message.sent();\n\n          //\n          // If there's nothing left to send, we're done.\n          //\n          if (this._sendStreams.length === 0) {\n            break;\n          }\n\n          //\n          // If we are in the closed state, don't continue sending.\n          //\n          // The connection can be in the closed state if parseMessage\n          // (called before sendNextMessage by message()) closes the\n          // connection.\n          //\n          if (this._state >= StateClosed) {\n            return;\n          }\n\n          //\n          // Otherwise, prepare the next message stream for writing.\n          //\n          message = this._sendStreams[0];\n          Debug.assert(!message.prepared);\n          var stream = message.stream;\n          stream.pos = 10;\n          stream.writeInt(stream.size);\n          stream.prepareWrite();\n          message.prepared = true;\n          TraceUtil.traceSend(stream, this._logger, this._traceLevels);\n          this._writeStream.swap(message.stream);\n\n          //\n          // Send the message.\n          //\n          if (this._writeStream.pos != this._writeStream.size && !this.write(this._writeStream.buffer)) {\n            Debug.assert(!this._writeStream.isEmpty());\n            this.scheduleTimeout(SocketOperation.Write);\n            return;\n          }\n        }\n      } catch (ex) {\n        if (ex instanceof Ice.LocalException) {\n          this.setState(StateClosed, ex);\n          return;\n        } else {\n          throw ex;\n        }\n      }\n      Debug.assert(this._writeStream.isEmpty());\n\n      //\n      // If all the messages were sent and we are in the closing state, we schedule\n      // the close timeout to wait for the peer to close the connection.\n      //\n      if (this._state === StateClosing && this._shutdownInitiated) {\n        this.scheduleTimeout(SocketOperation.Read);\n      }\n    }\n  }, {\n    key: \"sendMessage\",\n    value: function sendMessage(message) {\n      if (this._sendStreams.length > 0) {\n        message.doAdopt();\n        this._sendStreams.push(message);\n        return AsyncStatus.Queued;\n      }\n      Debug.assert(this._state < StateClosed);\n      Debug.assert(!message.prepared);\n      var stream = message.stream;\n      stream.pos = 10;\n      stream.writeInt(stream.size);\n      stream.prepareWrite();\n      message.prepared = true;\n      TraceUtil.traceSend(stream, this._logger, this._traceLevels);\n      if (this.write(stream.buffer)) {\n        //\n        // Entire buffer was written immediately.\n        //\n        message.sent();\n        if (this._acmLastActivity > 0) {\n          this._acmLastActivity = Date.now();\n        }\n        return AsyncStatus.Sent;\n      }\n      message.doAdopt();\n      this._writeStream.swap(message.stream);\n      this._sendStreams.push(message);\n      this.scheduleTimeout(SocketOperation.Write);\n      return AsyncStatus.Queued;\n    }\n  }, {\n    key: \"parseMessage\",\n    value: function parseMessage() {\n      Debug.assert(this._state > StateNotValidated && this._state < StateClosed);\n      var info = new MessageInfo(this._instance);\n      this._readStream.swap(info.stream);\n      this._readStream.resize(Protocol.headerSize);\n      this._readStream.pos = 0;\n      this._readHeader = true;\n      Debug.assert(info.stream.pos === info.stream.size);\n      try {\n        //\n        // We don't need to check magic and version here. This has already\n        // been done by the caller.\n        //\n        info.stream.pos = 8;\n        var messageType = info.stream.readByte();\n        var compress = info.stream.readByte();\n        if (compress === 2) {\n          throw new Ice.FeatureNotSupportedException(\"Cannot uncompress compressed message\");\n        }\n        info.stream.pos = Protocol.headerSize;\n        switch (messageType) {\n          case Protocol.closeConnectionMsg:\n            {\n              TraceUtil.traceRecv(info.stream, this._logger, this._traceLevels);\n              if (this._endpoint.datagram()) {\n                if (this._warn) {\n                  this._logger.warning(\"ignoring close connection message for datagram connection:\\n\" + this._desc);\n                }\n              } else {\n                this.setState(StateClosed, new Ice.CloseConnectionException());\n              }\n              break;\n            }\n          case Protocol.requestMsg:\n            {\n              if (this._state === StateClosing) {\n                TraceUtil.traceIn(\"received request during closing\\n\" + \"(ignored by server, client will retry)\", info.stream, this._logger, this._traceLevels);\n              } else {\n                TraceUtil.traceRecv(info.stream, this._logger, this._traceLevels);\n                info.requestId = info.stream.readInt();\n                info.invokeNum = 1;\n                info.servantManager = this._servantManager;\n                info.adapter = this._adapter;\n                ++this._dispatchCount;\n              }\n              break;\n            }\n          case Protocol.requestBatchMsg:\n            {\n              if (this._state === StateClosing) {\n                TraceUtil.traceIn(\"received batch request during closing\\n\" + \"(ignored by server, client will retry)\", info.stream, this._logger, this._traceLevels);\n              } else {\n                TraceUtil.traceRecv(info.stream, this._logger, this._traceLevels);\n                info.invokeNum = info.stream.readInt();\n                if (info.invokeNum < 0) {\n                  info.invokeNum = 0;\n                  throw new Ice.UnmarshalOutOfBoundsException();\n                }\n                info.servantManager = this._servantManager;\n                info.adapter = this._adapter;\n                this._dispatchCount += info.invokeNum;\n              }\n              break;\n            }\n          case Protocol.replyMsg:\n            {\n              TraceUtil.traceRecv(info.stream, this._logger, this._traceLevels);\n              info.requestId = info.stream.readInt();\n              info.outAsync = this._asyncRequests.get(info.requestId);\n              if (info.outAsync) {\n                this._asyncRequests[\"delete\"](info.requestId);\n                ++this._dispatchCount;\n              } else {\n                info = null;\n              }\n              this.checkClose();\n              break;\n            }\n          case Protocol.validateConnectionMsg:\n            {\n              TraceUtil.traceRecv(info.stream, this._logger, this._traceLevels);\n              if (this._heartbeatCallback !== null) {\n                info.heartbeatCallback = this._heartbeatCallback;\n                ++this._dispatchCount;\n              }\n              break;\n            }\n          default:\n            {\n              TraceUtil.traceIn(\"received unknown message\\n(invalid, closing connection)\", info.stream, this._logger, this._traceLevels);\n              throw new Ice.UnknownMessageException();\n            }\n        }\n      } catch (ex) {\n        if (ex instanceof Ice.LocalException) {\n          if (this._endpoint.datagram()) {\n            if (this._warn) {\n              this._logger.warning(\"datagram connection exception:\\n\" + ex + '\\n' + this._desc);\n            }\n          } else {\n            this.setState(StateClosed, ex);\n          }\n        } else {\n          throw ex;\n        }\n      }\n      return info;\n    }\n  }, {\n    key: \"invokeAll\",\n    value: function invokeAll(stream, invokeNum, requestId, servantManager, adapter) {\n      try {\n        while (invokeNum > 0) {\n          //\n          // Prepare the invocation.\n          //\n          var inc = new IncomingAsync(this._instance, this, adapter, !this._endpoint.datagram() && requestId !== 0,\n          // response\n          requestId);\n\n          //\n          // Dispatch the invocation.\n          //\n          inc.invoke(servantManager, stream);\n          --invokeNum;\n        }\n        stream.clear();\n      } catch (ex) {\n        if (ex instanceof Ice.LocalException) {\n          this.invokeException(ex, invokeNum);\n        } else {\n          //\n          // An Error was raised outside of servant code (i.e., by Ice code).\n          // Attempt to log the error and clean up.\n          //\n          this._logger.error(\"unexpected exception:\\n\" + ex.toString());\n          this.invokeException(new Ice.UnknownException(ex), invokeNum);\n        }\n      }\n    }\n  }, {\n    key: \"scheduleTimeout\",\n    value: function scheduleTimeout(op) {\n      var _this5 = this;\n      var timeout;\n      if (this._state < StateActive) {\n        var defaultsAndOverrides = this._instance.defaultsAndOverrides();\n        if (defaultsAndOverrides.overrideConnectTimeout) {\n          timeout = defaultsAndOverrides.overrideConnectTimeoutValue;\n        } else {\n          timeout = this._endpoint.timeout();\n        }\n      } else if (this._state < StateClosing) {\n        if (this._readHeader)\n          // No timeout for reading the header.\n          {\n            op &= ~SocketOperation.Read;\n          }\n        timeout = this._endpoint.timeout();\n      } else {\n        var _defaultsAndOverrides = this._instance.defaultsAndOverrides();\n        if (_defaultsAndOverrides.overrideCloseTimeout) {\n          timeout = _defaultsAndOverrides.overrideCloseTimeoutValue;\n        } else {\n          timeout = this._endpoint.timeout();\n        }\n      }\n      if (timeout < 0) {\n        return;\n      }\n      if ((op & SocketOperation.Read) !== 0) {\n        if (this._readTimeoutScheduled) {\n          this._timer.cancel(this._readTimeoutId);\n        }\n        this._readTimeoutId = this._timer.schedule(function () {\n          return _this5.timedOut();\n        }, timeout);\n        this._readTimeoutScheduled = true;\n      }\n      if ((op & (SocketOperation.Write | SocketOperation.Connect)) !== 0) {\n        if (this._writeTimeoutScheduled) {\n          this._timer.cancel(this._writeTimeoutId);\n        }\n        this._writeTimeoutId = this._timer.schedule(function () {\n          return _this5.timedOut();\n        }, timeout);\n        this._writeTimeoutScheduled = true;\n      }\n    }\n  }, {\n    key: \"unscheduleTimeout\",\n    value: function unscheduleTimeout(op) {\n      if ((op & SocketOperation.Read) !== 0 && this._readTimeoutScheduled) {\n        this._timer.cancel(this._readTimeoutId);\n        this._readTimeoutScheduled = false;\n      }\n      if ((op & (SocketOperation.Write | SocketOperation.Connect)) !== 0 && this._writeTimeoutScheduled) {\n        this._timer.cancel(this._writeTimeoutId);\n        this._writeTimeoutScheduled = false;\n      }\n    }\n  }, {\n    key: \"warning\",\n    value: function warning(msg, ex) {\n      this._logger.warning(msg + \":\\n\" + this._desc + \"\\n\" + ex.toString());\n    }\n  }, {\n    key: \"checkState\",\n    value: function checkState() {\n      if (this._state < StateHolding || this._dispatchCount > 0) {\n        return;\n      }\n\n      //\n      // We aren't finished until the state is finished and all\n      // outstanding requests are completed. Otherwise we couldn't\n      // guarantee that there are no outstanding calls when deactivate()\n      // is called on the servant locators.\n      //\n      if (this._state === StateFinished && this._finishedPromises.length > 0) {\n        //\n        // Clear the OA. See bug 1673 for the details of why this is necessary.\n        //\n        this._adapter = null;\n        this._finishedPromises.forEach(function (p) {\n          return p.resolve();\n        });\n        this._finishedPromises = [];\n      }\n    }\n  }, {\n    key: \"reap\",\n    value: function reap() {\n      if (this._monitor !== null) {\n        this._monitor.reap(this);\n      }\n    }\n  }, {\n    key: \"read\",\n    value: function read(buf) {\n      var start = buf.position;\n      var ret = this._transceiver.read(buf, this._hasMoreData);\n      if (this._instance.traceLevels().network >= 3 && buf.position != start) {\n        var s = [];\n        s.push(\"received \");\n        if (this._endpoint.datagram()) {\n          s.push(buf.limit);\n        } else {\n          s.push(buf.position - start);\n          s.push(\" of \");\n          s.push(buf.limit - start);\n        }\n        s.push(\" bytes via \");\n        s.push(this._endpoint.protocol());\n        s.push(\"\\n\");\n        s.push(this.toString());\n        this._instance.initializationData().logger.trace(this._instance.traceLevels().networkCat, s.join(\"\"));\n      }\n      return ret;\n    }\n  }, {\n    key: \"write\",\n    value: function write(buf) {\n      var start = buf.position;\n      var ret = this._transceiver.write(buf);\n      if (this._instance.traceLevels().network >= 3 && buf.position != start) {\n        var s = [];\n        s.push(\"sent \");\n        s.push(buf.position - start);\n        if (!this._endpoint.datagram()) {\n          s.push(\" of \");\n          s.push(buf.limit - start);\n        }\n        s.push(\" bytes via \");\n        s.push(this._endpoint.protocol());\n        s.push(\"\\n\");\n        s.push(this.toString());\n        this._instance.initializationData().logger.trace(this._instance.traceLevels().networkCat, s.join(\"\"));\n      }\n      return ret;\n    }\n  }]);\n}(); // DestructionReason.\nConnectionI.ObjectAdapterDeactivated = 0;\nConnectionI.CommunicatorDestroyed = 1;\nIce.ConnectionI = ConnectionI;\nvar OutgoingMessage = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function OutgoingMessage() {\n    _classCallCheck(this, OutgoingMessage);\n    this.stream = null;\n    this.outAsync = null;\n    this.requestId = 0;\n    this.prepared = false;\n  }\n  return _createClass(OutgoingMessage, [{\n    key: \"canceled\",\n    value: function canceled() {\n      Debug.assert(this.outAsync !== null);\n      this.outAsync = null;\n    }\n  }, {\n    key: \"doAdopt\",\n    value: function doAdopt() {\n      if (this.adopt) {\n        var stream = new OutputStream(this.stream.instance, Protocol.currentProtocolEncoding);\n        stream.swap(this.stream);\n        this.stream = stream;\n        this.adopt = false;\n      }\n    }\n  }, {\n    key: \"sent\",\n    value: function sent() {\n      if (this.outAsync !== null) {\n        this.outAsync.sent();\n      }\n    }\n  }, {\n    key: \"completed\",\n    value: function completed(ex) {\n      if (this.outAsync !== null) {\n        this.outAsync.completedEx(ex);\n      }\n    }\n  }], [{\n    key: \"createForStream\",\n    value: function createForStream(stream, adopt) {\n      var m = new OutgoingMessage();\n      m.stream = stream;\n      m.adopt = adopt;\n      m.isSent = false;\n      m.requestId = 0;\n      m.outAsync = null;\n      return m;\n    }\n  }, {\n    key: \"create\",\n    value: function create(out, stream, requestId) {\n      var m = new OutgoingMessage();\n      m.stream = stream;\n      m.outAsync = out;\n      m.requestId = requestId;\n      m.isSent = false;\n      m.adopt = false;\n      return m;\n    }\n  }]);\n}();\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/ConnectionI.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/ConnectionInfo.js":
/*!****************************************************!*\
  !*** ./node_modules/ice/src/Ice/ConnectionInfo.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `ConnectionInfo.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nvar _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\");\n__webpack_require__(/*! ../Ice/ObjectPrx */ \"./node_modules/ice/src/Ice/ObjectPrx.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\n__webpack_require__(/*! ../Ice/Connection */ \"./node_modules/ice/src/Ice/Connection.js\");\nvar Ice = _ModuleRegistry.module(\"Ice\");\nvar Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n/* slice2js browser-bundle-skip */\n\nvar IceSSL = _ModuleRegistry.module(\"IceSSL\");\n/* slice2js browser-bundle-skip-end */\n\n/**\n * Provides access to the connection details of an SSL connection\n *\n **/\nIceSSL.ConnectionInfo = /*#__PURE__*/function (_Ice$ConnectionInfo) {\n  \"use strict\";\n\n  function _class(underlying, incoming, adapterName, connectionId) {\n    var _this;\n    var cipher = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : \"\";\n    var certs = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n    var verified = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n    _classCallCheck(this, _class);\n    _this = _callSuper(this, _class, [underlying, incoming, adapterName, connectionId]);\n    _this.cipher = cipher;\n    _this.certs = certs;\n    _this.verified = verified;\n    return _this;\n  }\n  _inherits(_class, _Ice$ConnectionInfo);\n  return _createClass(_class);\n}(Ice.ConnectionInfo);\n\n/* slice2js browser-bundle-skip */\nexports.IceSSL = IceSSL;\n/* slice2js browser-bundle-skip-end */\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/ConnectionInfo.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/ConnectionRequestHandler.js":
/*!**************************************************************!*\
  !*** ./node_modules/ice/src/Ice/ConnectionRequestHandler.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/ReferenceMode */ \"./node_modules/ice/src/Ice/ReferenceMode.js\").Ice);\nvar ReferenceMode = Ice.ReferenceMode;\nvar ConnectionRequestHandler = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function ConnectionRequestHandler(ref, connection) {\n    _classCallCheck(this, ConnectionRequestHandler);\n    this._reference = ref;\n    this._response = ref.getMode() == ReferenceMode.ModeTwoway;\n    this._connection = connection;\n  }\n  return _createClass(ConnectionRequestHandler, [{\n    key: \"update\",\n    value: function update(previousHandler, newHandler) {\n      try {\n        if (previousHandler === this) {\n          return newHandler;\n        } else if (previousHandler.getConnection() === this._connection) {\n          //\n          // If both request handlers point to the same connection, we also\n          // update the request handler. See bug ICE-5489 for reasons why\n          // this can be useful.\n          //\n          return newHandler;\n        }\n      } catch (ex) {\n        // Ignore\n      }\n      return this;\n    }\n  }, {\n    key: \"sendAsyncRequest\",\n    value: function sendAsyncRequest(out) {\n      return out.invokeRemote(this._connection, this._response);\n    }\n  }, {\n    key: \"asyncRequestCanceled\",\n    value: function asyncRequestCanceled(out) {\n      return this._connection.asyncRequestCanceled(out);\n    }\n  }, {\n    key: \"getReference\",\n    value: function getReference() {\n      return this._reference;\n    }\n  }, {\n    key: \"getConnection\",\n    value: function getConnection() {\n      return this._connection;\n    }\n  }]);\n}();\nIce.ConnectionRequestHandler = ConnectionRequestHandler;\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/ConnectionRequestHandler.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Current.js":
/*!*********************************************!*\
  !*** ./node_modules/ice/src/Ice/Current.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `Current.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nvar _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Struct */ \"./node_modules/ice/src/Ice/Struct.js\");\n__webpack_require__(/*! ../Ice/EnumBase */ \"./node_modules/ice/src/Ice/EnumBase.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\n__webpack_require__(/*! ../Ice/ObjectAdapterF */ \"./node_modules/ice/src/Ice/ObjectAdapterF.js\");\n__webpack_require__(/*! ../Ice/ConnectionF */ \"./node_modules/ice/src/Ice/ConnectionF.js\");\n__webpack_require__(/*! ../Ice/Identity */ \"./node_modules/ice/src/Ice/Identity.js\");\n__webpack_require__(/*! ../Ice/Version */ \"./node_modules/ice/src/Ice/Version.js\");\nvar Ice = _ModuleRegistry.module(\"Ice\");\nvar Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n\nSlice.defineDictionary(Ice, \"Context\", \"ContextHelper\", \"Ice.StringHelper\", \"Ice.StringHelper\", false, undefined, undefined);\n\n/**\n * Determines the retry behavior an invocation in case of a (potentially) recoverable error.\n *\n **/\nIce.OperationMode = Slice.defineEnum([['Normal', 0], ['Nonmutating', 1], ['Idempotent', 2]]);\n\n/**\n * Information about the current method invocation for servers. Each\n * operation on the server has a <code>Current</code> as its implicit final\n * parameter. <code>Current</code> is mostly used for Ice services. Most\n * applications ignore this parameter.\n *\n **/\nIce.Current = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function _class() {\n    var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var con = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Ice.Identity();\n    var facet = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"\";\n    var operation = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : \"\";\n    var mode = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : Ice.OperationMode.Normal;\n    var ctx = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n    var requestId = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;\n    var encoding = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : new Ice.EncodingVersion();\n    _classCallCheck(this, _class);\n    this.adapter = adapter;\n    this.con = con;\n    this.id = id;\n    this.facet = facet;\n    this.operation = operation;\n    this.mode = mode;\n    this.ctx = ctx;\n    this.requestId = requestId;\n    this.encoding = encoding;\n  }\n  return _createClass(_class);\n}();\nSlice.defineStruct(Ice.Current, false, true);\n/* slice2js browser-bundle-skip */\nexports.Ice = Ice;\n/* slice2js browser-bundle-skip-end */\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/Current.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Debug.js":
/*!*******************************************!*\
  !*** ./node_modules/ice/src/Ice/Debug.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _wrapNativeSuper(t) { var r = \"function\" == typeof Map ? new Map() : void 0; return _wrapNativeSuper = function _wrapNativeSuper(t) { if (null === t || !_isNativeFunction(t)) return t; if (\"function\" != typeof t) throw new TypeError(\"Super expression must either be null or a function\"); if (void 0 !== r) { if (r.has(t)) return r.get(t); r.set(t, Wrapper); } function Wrapper() { return _construct(t, arguments, _getPrototypeOf(this).constructor); } return Wrapper.prototype = Object.create(t.prototype, { constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf(Wrapper, t); }, _wrapNativeSuper(t); }\nfunction _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _isNativeFunction(t) { try { return -1 !== Function.toString.call(t).indexOf(\"[native code]\"); } catch (n) { return \"function\" == typeof t; } }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\n/* eslint no-sync: \"off\" */\n/* eslint no-process-exit: \"off\" */\n\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n__webpack_require__(/*! ../Ice/Exception */ \"./node_modules/ice/src/Ice/Exception.js\");\nvar Debug = {};\nif (typeof process !== 'undefined') {\n  var fs = __webpack_require__(/*! fs */ \"?3c7e\");\n  Debug = /*#__PURE__*/function () {\n    \"use strict\";\n\n    function Debug() {\n      _classCallCheck(this, Debug);\n    }\n    return _createClass(Debug, null, [{\n      key: \"assert\",\n      value: function assert(b, msg) {\n        if (!b) {\n          fs.writeSync(process.stderr.fd, msg === undefined ? \"assertion failed\" : msg);\n          fs.writeSync(process.stderr.fd, new Error().stack);\n          process.exit(1);\n        }\n      }\n    }]);\n  }();\n} else {\n  var AssertionFailedException = /*#__PURE__*/function (_Error) {\n    \"use strict\";\n\n    function AssertionFailedException(message) {\n      var _this;\n      _classCallCheck(this, AssertionFailedException);\n      _this = _callSuper(this, AssertionFailedException);\n      Ice.Exception.captureStackTrace(_this);\n      _this.message = message;\n      return _this;\n    }\n    _inherits(AssertionFailedException, _Error);\n    return _createClass(AssertionFailedException);\n  }(/*#__PURE__*/_wrapNativeSuper(Error));\n  Ice.AssertionFailedException = AssertionFailedException;\n  Debug = /*#__PURE__*/function () {\n    \"use strict\";\n\n    function Debug() {\n      _classCallCheck(this, Debug);\n    }\n    return _createClass(Debug, null, [{\n      key: \"assert\",\n      value: function assert(b, msg) {\n        if (!b) {\n          console.log(msg === undefined ? \"assertion failed\" : msg);\n          console.log(new Error().stack);\n          throw new Ice.AssertionFailedException(msg === undefined ? \"assertion failed\" : msg);\n        }\n      }\n    }]);\n  }();\n}\nIce.Debug = Debug;\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/Debug.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/DefaultsAndOverrides.js":
/*!**********************************************************!*\
  !*** ./node_modules/ice/src/Ice/DefaultsAndOverrides.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n__webpack_require__(/*! ../Ice/EndpointTypes */ \"./node_modules/ice/src/Ice/EndpointTypes.js\");\n__webpack_require__(/*! ../Ice/FormatType */ \"./node_modules/ice/src/Ice/FormatType.js\");\n__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\");\n__webpack_require__(/*! ../Ice/Protocol */ \"./node_modules/ice/src/Ice/Protocol.js\");\nvar FormatType = Ice.FormatType;\nvar EndpointSelectionType = Ice.EndpointSelectionType;\nvar Protocol = Ice.Protocol;\nvar DefaultsAndOverrides = /*#__PURE__*/_createClass(function DefaultsAndOverrides(properties, logger) {\n  \"use strict\";\n\n  _classCallCheck(this, DefaultsAndOverrides);\n  this.defaultProtocol = properties.getPropertyWithDefault(\"Ice.Default.Protocol\", Ice.TcpTransceiver !== null ? \"tcp\" : \"ws\");\n  var value = properties.getProperty(\"Ice.Default.Host\");\n  this.defaultHost = value.length > 0 ? value : null;\n  value = properties.getProperty(\"Ice.Default.SourceAddress\");\n  this.defaultSourceAddress = value.length > 0 ? value : null;\n  value = properties.getProperty(\"Ice.Override.Timeout\");\n  if (value.length > 0) {\n    this.overrideTimeout = true;\n    this.overrideTimeoutValue = properties.getPropertyAsInt(\"Ice.Override.Timeout\");\n    if (this.overrideTimeoutValue < 1 && this.overrideTimeoutValue !== -1) {\n      this.overrideTimeoutValue = -1;\n      logger.warning(\"invalid value for Ice.Override.Timeout `\" + properties.getProperty(\"Ice.Override.Timeout\") + \"': defaulting to -1\");\n    }\n  } else {\n    this.overrideTimeout = false;\n    this.overrideTimeoutValue = -1;\n  }\n  value = properties.getProperty(\"Ice.Override.ConnectTimeout\");\n  if (value.length > 0) {\n    this.overrideConnectTimeout = true;\n    this.overrideConnectTimeoutValue = properties.getPropertyAsInt(\"Ice.Override.ConnectTimeout\");\n    if (this.overrideConnectTimeoutValue < 1 && this.overrideConnectTimeoutValue !== -1) {\n      this.overrideConnectTimeoutValue = -1;\n      logger.warning(\"invalid value for Ice.Override.ConnectTimeout `\" + properties.getProperty(\"Ice.Override.ConnectTimeout\") + \"': defaulting to -1\");\n    }\n  } else {\n    this.overrideConnectTimeout = false;\n    this.overrideConnectTimeoutValue = -1;\n  }\n  value = properties.getProperty(\"Ice.Override.CloseTimeout\");\n  if (value.length > 0) {\n    this.overrideCloseTimeout = true;\n    this.overrideCloseTimeoutValue = properties.getPropertyAsInt(\"Ice.Override.CloseTimeout\");\n    if (this.overrideCloseTimeoutValue < 1 && this.overrideCloseTimeoutValue !== -1) {\n      this.overrideCloseTimeoutValue = -1;\n      logger.warning(\"invalid value for Ice.Override.CloseTimeout `\" + properties.getProperty(\"Ice.Override.CloseTimeout\") + \"': defaulting to -1\");\n    }\n  } else {\n    this.overrideCloseTimeout = false;\n    this.overrideCloseTimeoutValue = -1;\n  }\n  this.overrideSecure = false;\n  value = properties.getPropertyWithDefault(\"Ice.Default.EndpointSelection\", \"Random\");\n  if (value === \"Random\") {\n    this.defaultEndpointSelection = EndpointSelectionType.Random;\n  } else if (value === \"Ordered\") {\n    this.defaultEndpointSelection = EndpointSelectionType.Ordered;\n  } else {\n    var ex = new Ice.EndpointSelectionTypeParseException();\n    ex.str = \"illegal value `\" + value + \"'; expected `Random' or `Ordered'\";\n    throw ex;\n  }\n  this.defaultTimeout = properties.getPropertyAsIntWithDefault(\"Ice.Default.Timeout\", 60000);\n  if (this.defaultTimeout < 1 && this.defaultTimeout !== -1) {\n    this.defaultTimeout = 60000;\n    logger.warning(\"invalid value for Ice.Default.Timeout `\" + properties.getProperty(\"Ice.Default.Timeout\") + \"': defaulting to 60000\");\n  }\n  this.defaultLocatorCacheTimeout = properties.getPropertyAsIntWithDefault(\"Ice.Default.LocatorCacheTimeout\", -1);\n  if (this.defaultLocatorCacheTimeout < -1) {\n    this.defaultLocatorCacheTimeout = -1;\n    logger.warning(\"invalid value for Ice.Default.LocatorCacheTimeout `\" + properties.getProperty(\"Ice.Default.LocatorCacheTimeout\") + \"': defaulting to -1\");\n  }\n  this.defaultInvocationTimeout = properties.getPropertyAsIntWithDefault(\"Ice.Default.InvocationTimeout\", -1);\n  if (this.defaultInvocationTimeout < 1 && this.defaultInvocationTimeout !== -1) {\n    this.defaultInvocationTimeout = -1;\n    logger.warning(\"invalid value for Ice.Default.InvocationTimeout `\" + properties.getProperty(\"Ice.Default.InvocationTimeout\") + \"': defaulting to -1\");\n  }\n  this.defaultPreferSecure = properties.getPropertyAsIntWithDefault(\"Ice.Default.PreferSecure\", 0) > 0;\n  value = properties.getPropertyWithDefault(\"Ice.Default.EncodingVersion\", Ice.encodingVersionToString(Protocol.currentEncoding));\n  this.defaultEncoding = Ice.stringToEncodingVersion(value);\n  Protocol.checkSupportedEncoding(this.defaultEncoding);\n  var slicedFormat = properties.getPropertyAsIntWithDefault(\"Ice.Default.SlicedFormat\", 0) > 0;\n  this.defaultFormat = slicedFormat ? FormatType.SlicedFormat : FormatType.CompactFormat;\n});\nIce.DefaultsAndOverrides = DefaultsAndOverrides;\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/DefaultsAndOverrides.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Endpoint.js":
/*!**********************************************!*\
  !*** ./node_modules/ice/src/Ice/Endpoint.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `Endpoint.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nvar _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\");\n__webpack_require__(/*! ../Ice/ObjectPrx */ \"./node_modules/ice/src/Ice/ObjectPrx.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\n__webpack_require__(/*! ../Ice/Version */ \"./node_modules/ice/src/Ice/Version.js\");\n__webpack_require__(/*! ../Ice/BuiltinSequences */ \"./node_modules/ice/src/Ice/BuiltinSequences.js\");\n__webpack_require__(/*! ../Ice/EndpointF */ \"./node_modules/ice/src/Ice/EndpointF.js\");\nvar Ice = _ModuleRegistry.module(\"Ice\");\nvar Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n\nObject.defineProperty(Ice, 'TCPEndpointType', {\n  value: 1\n});\nObject.defineProperty(Ice, 'SSLEndpointType', {\n  value: 2\n});\nObject.defineProperty(Ice, 'UDPEndpointType', {\n  value: 3\n});\nObject.defineProperty(Ice, 'WSEndpointType', {\n  value: 4\n});\nObject.defineProperty(Ice, 'WSSEndpointType', {\n  value: 5\n});\nObject.defineProperty(Ice, 'BTEndpointType', {\n  value: 6\n});\nObject.defineProperty(Ice, 'BTSEndpointType', {\n  value: 7\n});\nObject.defineProperty(Ice, 'iAPEndpointType', {\n  value: 8\n});\nObject.defineProperty(Ice, 'iAPSEndpointType', {\n  value: 9\n});\n\n/**\n * Base class providing access to the endpoint details.\n *\n **/\nIce.EndpointInfo = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function _class() {\n    var underlying = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var compress = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    _classCallCheck(this, _class);\n    this.underlying = underlying;\n    this.timeout = timeout;\n    this.compress = compress;\n  }\n  return _createClass(_class);\n}();\n\n/**\n * Provides access to the address details of a IP endpoint.\n *\n * @see Endpoint\n *\n **/\nIce.IPEndpointInfo = /*#__PURE__*/function (_Ice$EndpointInfo) {\n  \"use strict\";\n\n  function _class2(underlying, timeout, compress) {\n    var _this;\n    var host = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"\";\n    var port = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    var sourceAddress = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : \"\";\n    _classCallCheck(this, _class2);\n    _this = _callSuper(this, _class2, [underlying, timeout, compress]);\n    _this.host = host;\n    _this.port = port;\n    _this.sourceAddress = sourceAddress;\n    return _this;\n  }\n  _inherits(_class2, _Ice$EndpointInfo);\n  return _createClass(_class2);\n}(Ice.EndpointInfo);\n\n/**\n * Provides access to a TCP endpoint information.\n *\n * @see Endpoint\n *\n **/\nIce.TCPEndpointInfo = /*#__PURE__*/function (_Ice$IPEndpointInfo) {\n  \"use strict\";\n\n  function _class3(underlying, timeout, compress, host, port, sourceAddress) {\n    _classCallCheck(this, _class3);\n    return _callSuper(this, _class3, [underlying, timeout, compress, host, port, sourceAddress]);\n  }\n  _inherits(_class3, _Ice$IPEndpointInfo);\n  return _createClass(_class3);\n}(Ice.IPEndpointInfo);\n\n/**\n * Provides access to an UDP endpoint information.\n *\n * @see Endpoint\n *\n **/\nIce.UDPEndpointInfo = /*#__PURE__*/function (_Ice$IPEndpointInfo2) {\n  \"use strict\";\n\n  function _class4(underlying, timeout, compress, host, port, sourceAddress) {\n    var _this2;\n    var mcastInterface = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : \"\";\n    var mcastTtl = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;\n    _classCallCheck(this, _class4);\n    _this2 = _callSuper(this, _class4, [underlying, timeout, compress, host, port, sourceAddress]);\n    _this2.mcastInterface = mcastInterface;\n    _this2.mcastTtl = mcastTtl;\n    return _this2;\n  }\n  _inherits(_class4, _Ice$IPEndpointInfo2);\n  return _createClass(_class4);\n}(Ice.IPEndpointInfo);\n\n/**\n * Provides access to a WebSocket endpoint information.\n *\n **/\nIce.WSEndpointInfo = /*#__PURE__*/function (_Ice$EndpointInfo2) {\n  \"use strict\";\n\n  function _class5(underlying, timeout, compress) {\n    var _this3;\n    var resource = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"\";\n    _classCallCheck(this, _class5);\n    _this3 = _callSuper(this, _class5, [underlying, timeout, compress]);\n    _this3.resource = resource;\n    return _this3;\n  }\n  _inherits(_class5, _Ice$EndpointInfo2);\n  return _createClass(_class5);\n}(Ice.EndpointInfo);\n\n/**\n * Provides access to the details of an opaque endpoint.\n *\n * @see Endpoint\n *\n **/\nIce.OpaqueEndpointInfo = /*#__PURE__*/function (_Ice$EndpointInfo3) {\n  \"use strict\";\n\n  function _class6(underlying, timeout, compress) {\n    var _this4;\n    var rawEncoding = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new Ice.EncodingVersion();\n    var rawBytes = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    _classCallCheck(this, _class6);\n    _this4 = _callSuper(this, _class6, [underlying, timeout, compress]);\n    _this4.rawEncoding = rawEncoding;\n    _this4.rawBytes = rawBytes;\n    return _this4;\n  }\n  _inherits(_class6, _Ice$EndpointInfo3);\n  return _createClass(_class6);\n}(Ice.EndpointInfo);\n\n/* slice2js browser-bundle-skip */\nexports.Ice = Ice;\n/* slice2js browser-bundle-skip-end */\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/Endpoint.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/EndpointF.js":
/*!***********************************************!*\
  !*** ./node_modules/ice/src/Ice/EndpointF.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `EndpointF.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nvar _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\nvar Ice = _ModuleRegistry.module(\"Ice\");\nvar Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n\nSlice.defineSequence(Ice, \"EndpointSeqHelper\", \"Ice.ObjectHelper\", false, \"Ice.Endpoint\");\n/* slice2js browser-bundle-skip */\nexports.Ice = Ice;\n/* slice2js browser-bundle-skip-end */\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/EndpointF.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/EndpointFactoryManager.js":
/*!************************************************************!*\
  !*** ./node_modules/ice/src/Ice/EndpointFactoryManager.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n__webpack_require__(/*! ../Ice/Debug */ \"./node_modules/ice/src/Ice/Debug.js\");\n__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\");\n__webpack_require__(/*! ../Ice/OpaqueEndpointI */ \"./node_modules/ice/src/Ice/OpaqueEndpointI.js\");\n__webpack_require__(/*! ../Ice/Protocol */ \"./node_modules/ice/src/Ice/Protocol.js\");\n__webpack_require__(/*! ../Ice/Stream */ \"./node_modules/ice/src/Ice/Stream.js\");\n__webpack_require__(/*! ../Ice/StringUtil */ \"./node_modules/ice/src/Ice/StringUtil.js\");\n\n//\n// Local aliases.\n//\nvar Debug = Ice.Debug;\nvar InputStream = Ice.InputStream;\nvar OutputStream = Ice.OutputStream;\nvar EndpointParseException = Ice.EndpointParseException;\nvar OpaqueEndpointI = Ice.OpaqueEndpointI;\nvar Protocol = Ice.Protocol;\nvar StringUtil = Ice.StringUtil;\nvar EndpointFactoryManager = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function EndpointFactoryManager(instance) {\n    _classCallCheck(this, EndpointFactoryManager);\n    this._instance = instance;\n    this._factories = [];\n  }\n  return _createClass(EndpointFactoryManager, [{\n    key: \"add\",\n    value: function add(factory) {\n      Debug.assert(this._factories.find(function (f) {\n        return factory.type() == f.type();\n      }) === undefined);\n      this._factories.push(factory);\n    }\n  }, {\n    key: \"get\",\n    value: function get(type) {\n      return this._factories.find(function (f) {\n        return type == f.type();\n      }) || null;\n    }\n  }, {\n    key: \"create\",\n    value: function create(str, oaEndpoint) {\n      var s = str.trim();\n      if (s.length === 0) {\n        throw new EndpointParseException(\"value has no non-whitespace characters\");\n      }\n      var arr = StringUtil.splitString(s, \" \\t\\n\\r\");\n      if (arr.length === 0) {\n        throw new EndpointParseException(\"value has no non-whitespace characters\");\n      }\n      var protocol = arr[0];\n      arr.splice(0, 1);\n      if (protocol === \"default\") {\n        protocol = this._instance.defaultsAndOverrides().defaultProtocol;\n      }\n      for (var i = 0, length = this._factories.length; i < length; ++i) {\n        if (this._factories[i].protocol() === protocol) {\n          var e = this._factories[i].create(arr, oaEndpoint);\n          if (arr.length > 0) {\n            throw new EndpointParseException(\"unrecognized argument `\" + arr[0] + \"' in endpoint `\" + str + \"'\");\n          }\n          return e;\n        }\n      }\n\n      //\n      // If the stringified endpoint is opaque, create an unknown endpoint,\n      // then see whether the type matches one of the known endpoints.\n      //\n      if (protocol === \"opaque\") {\n        var ue = new OpaqueEndpointI();\n        ue.initWithOptions(arr);\n        if (arr.length > 0) {\n          throw new EndpointParseException(\"unrecognized argument `\" + arr[0] + \"' in endpoint `\" + str + \"'\");\n        }\n        for (var _i = 0, _length = this._factories.length; _i < _length; ++_i) {\n          if (this._factories[_i].type() == ue.type()) {\n            //\n            // Make a temporary stream, write the opaque endpoint data into the stream,\n            // and ask the factory to read the endpoint data from that stream to create\n            // the actual endpoint.\n            //\n            var os = new OutputStream(this._instance, Protocol.currentProtocolEncoding);\n            os.writeShort(ue.type());\n            ue.streamWrite(os);\n            var is = new InputStream(this._instance, Protocol.currentProtocolEncoding, os.buffer);\n            is.pos = 0;\n            is.readShort(); // type\n            is.startEncapsulation();\n            var _e = this._factories[_i].read(is);\n            is.endEncapsulation();\n            return _e;\n          }\n        }\n        return ue; // Endpoint is opaque, but we don't have a factory for its type.\n      }\n      return null;\n    }\n  }, {\n    key: \"read\",\n    value: function read(s) {\n      var type = s.readShort();\n      var factory = this.get(type);\n      var e = null;\n      s.startEncapsulation();\n      if (factory) {\n        e = factory.read(s);\n      }\n      //\n      // If the factory failed to read the endpoint, return an opaque endpoint. This can\n      // occur if for example the factory delegates to another factory and this factory\n      // isn't available. In this case, the factory needs to make sure the stream position\n      // is preserved for reading the opaque endpoint.\n      //\n      if (!e) {\n        e = new OpaqueEndpointI(type);\n        e.initWithStream(s);\n      }\n      s.endEncapsulation();\n      return e;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this._factories.forEach(function (factory) {\n        return factory.destroy();\n      });\n      this._factories = [];\n    }\n  }]);\n}();\nIce.EndpointFactoryManager = EndpointFactoryManager;\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/EndpointFactoryManager.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/EndpointI.js":
/*!***********************************************!*\
  !*** ./node_modules/ice/src/Ice/EndpointI.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/Endpoint */ \"./node_modules/ice/src/Ice/Endpoint.js\").Ice);\nvar EndpointI = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function EndpointI() {\n    _classCallCheck(this, EndpointI);\n  }\n  return _createClass(EndpointI, [{\n    key: \"toString\",\n    value: function toString() {\n      //\n      // WARNING: Certain features, such as proxy validation in Glacier2,\n      // depend on the format of proxy strings. Changes to toString() and\n      // methods called to generate parts of the reference string could break\n      // these features. Please review for all features that depend on the\n      // format of proxyToString() before changing this and related code.\n      //\n      return this.protocol() + this.options();\n    }\n  }, {\n    key: \"initWithOptions\",\n    value: function initWithOptions(args) {\n      var unknown = [];\n      var str = \"`\" + this.protocol();\n      for (var i = 0; i < args.length; ++i) {\n        if (args[i].search(/[ \\t\\n\\r]+/) !== -1) {\n          str += \" \\\"\" + args[i] + \"\\\"\";\n        } else {\n          str += \" \" + args[i];\n        }\n      }\n      str += \"'\";\n      for (var _i = 0; _i < args.length;) {\n        var option = args[_i++];\n        if (option.length < 2 || option.charAt(0) != '-') {\n          unknown.push(option);\n          continue;\n        }\n        var argument = null;\n        if (_i < args.length && args[_i].charAt(0) != '-') {\n          argument = args[_i++];\n        }\n        if (!this.checkOption(option, argument, str)) {\n          unknown.push(option);\n          if (argument !== null) {\n            unknown.push(argument);\n          }\n        }\n      }\n      args.length = 0;\n      for (var _i2 = 0; _i2 < unknown.length; _i2++) {\n        args.push(unknown[_i2]);\n      }\n    }\n\n    //\n    // Compare endpoints for sorting purposes\n    //\n  }, {\n    key: \"equals\",\n    value: function equals(p) {\n      if (!(p instanceof EndpointI)) {\n        return false;\n      }\n      return this.compareTo(p) === 0;\n    }\n  }, {\n    key: \"checkOption\",\n    value: function checkOption() {\n      return false;\n    }\n  }]);\n}();\nIce.EndpointI = EndpointI;\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/EndpointI.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/EndpointInfo.js":
/*!**************************************************!*\
  !*** ./node_modules/ice/src/Ice/EndpointInfo.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `EndpointInfo.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nvar _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\");\n__webpack_require__(/*! ../Ice/ObjectPrx */ \"./node_modules/ice/src/Ice/ObjectPrx.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\n__webpack_require__(/*! ../Ice/Endpoint */ \"./node_modules/ice/src/Ice/Endpoint.js\");\nvar Ice = _ModuleRegistry.module(\"Ice\");\nvar Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n/* slice2js browser-bundle-skip */\n\nvar IceSSL = _ModuleRegistry.module(\"IceSSL\");\n/* slice2js browser-bundle-skip-end */\n\n/**\n * Provides access to an SSL endpoint information.\n *\n **/\nIceSSL.EndpointInfo = /*#__PURE__*/function (_Ice$EndpointInfo) {\n  \"use strict\";\n\n  function _class(underlying, timeout, compress) {\n    _classCallCheck(this, _class);\n    return _callSuper(this, _class, [underlying, timeout, compress]);\n  }\n  _inherits(_class, _Ice$EndpointInfo);\n  return _createClass(_class);\n}(Ice.EndpointInfo);\n\n/* slice2js browser-bundle-skip */\nexports.IceSSL = IceSSL;\n/* slice2js browser-bundle-skip-end */\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/EndpointInfo.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/EndpointTypes.js":
/*!***************************************************!*\
  !*** ./node_modules/ice/src/Ice/EndpointTypes.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `EndpointTypes.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nvar _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/EnumBase */ \"./node_modules/ice/src/Ice/EnumBase.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\nvar Ice = _ModuleRegistry.module(\"Ice\");\nvar Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n\n/**\n * Determines the order in which the Ice run time uses the endpoints\n * in a proxy when establishing a connection.\n *\n **/\nIce.EndpointSelectionType = Slice.defineEnum([['Random', 0], ['Ordered', 1]]);\n/* slice2js browser-bundle-skip */\nexports.Ice = Ice;\n/* slice2js browser-bundle-skip-end */\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/EndpointTypes.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/EnumBase.js":
/*!**********************************************!*\
  !*** ./node_modules/ice/src/Ice/EnumBase.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n\n//\n// Ice.EnumBase\n//\nvar EnumBase = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function EnumBase(name, value) {\n    _classCallCheck(this, EnumBase);\n    this._name = name;\n    this._value = value;\n  }\n  return _createClass(EnumBase, [{\n    key: \"equals\",\n    value: function equals(rhs) {\n      if (this === rhs) {\n        return true;\n      }\n      if (!(rhs instanceof Object.getPrototypeOf(this).constructor)) {\n        return false;\n      }\n      return this._value == rhs._value;\n    }\n  }, {\n    key: \"hashCode\",\n    value: function hashCode() {\n      return this._value;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this._name;\n    }\n  }, {\n    key: \"name\",\n    get: function get() {\n      return this._name;\n    }\n  }, {\n    key: \"value\",\n    get: function get() {\n      return this._value;\n    }\n  }]);\n}();\nIce.EnumBase = EnumBase;\nvar EnumHelper = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function EnumHelper(enumType) {\n    _classCallCheck(this, EnumHelper);\n    this._enumType = enumType;\n  }\n  return _createClass(EnumHelper, [{\n    key: \"write\",\n    value: function write(os, v) {\n      this._enumType._write(os, v);\n    }\n  }, {\n    key: \"writeOptional\",\n    value: function writeOptional(os, tag, v) {\n      this._enumType._writeOpt(os, tag, v);\n    }\n  }, {\n    key: \"read\",\n    value: function read(is) {\n      return this._enumType._read(is);\n    }\n  }, {\n    key: \"readOptional\",\n    value: function readOptional(is, tag) {\n      return this._enumType._readOpt(is, tag);\n    }\n  }]);\n}();\nIce.EnumHelper = EnumHelper;\nvar Slice = Ice.Slice;\nSlice.defineEnum = function (enumerators) {\n  var type = /*#__PURE__*/function (_EnumBase) {\n    \"use strict\";\n\n    function type() {\n      _classCallCheck(this, type);\n      return _callSuper(this, type, arguments);\n    }\n    _inherits(type, _EnumBase);\n    return _createClass(type);\n  }(EnumBase);\n  var enums = [];\n  var maxValue = 0;\n  var firstEnum = null;\n  for (var idx in enumerators) {\n    var e = enumerators[idx][0];\n    var value = enumerators[idx][1];\n    var enumerator = new type(e, value);\n    enums[value] = enumerator;\n    if (!firstEnum) {\n      firstEnum = enumerator;\n    }\n    Object.defineProperty(type, e, {\n      enumerable: true,\n      value: enumerator\n    });\n    if (value > maxValue) {\n      maxValue = value;\n    }\n  }\n  Object.defineProperty(type, \"minWireSize\", {\n    get: function get() {\n      return 1;\n    }\n  });\n  type._write = function (os, v) {\n    if (v) {\n      os.writeEnum(v);\n    } else {\n      os.writeEnum(firstEnum);\n    }\n  };\n  type._read = function (is) {\n    return is.readEnum(type);\n  };\n  type._writeOpt = function (os, tag, v) {\n    if (v !== undefined) {\n      if (os.writeOptional(tag, Ice.OptionalFormat.Size)) {\n        type._write(os, v);\n      }\n    }\n  };\n  type._readOpt = function (is, tag) {\n    return is.readOptionalEnum(tag, type);\n  };\n  type._helper = new EnumHelper(type);\n  Object.defineProperty(type, 'valueOf', {\n    value: function value(v) {\n      if (v === undefined) {\n        return type;\n      }\n      return enums[v];\n    }\n  });\n  Object.defineProperty(type, 'maxValue', {\n    value: maxValue\n  });\n  Object.defineProperty(type.prototype, 'maxValue', {\n    value: maxValue\n  });\n  return type;\n};\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/EnumBase.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/ExUtil.js":
/*!********************************************!*\
  !*** ./node_modules/ice/src/Ice/ExUtil.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\").Ice);\n\n//\n// Local aliases.\n//\nvar UnexpectedObjectException = Ice.UnexpectedObjectException;\nvar MemoryLimitException = Ice.MemoryLimitException;\n\n//\n// Exception utilities\n//\n\nIce.ExUtil = {\n  throwUOE: function throwUOE(expectedType, v) {\n    var type = v.ice_id();\n    throw new UnexpectedObjectException(\"expected element of type `\" + expectedType + \"' but received `\" + type + \"'\", type, expectedType);\n  },\n  throwMemoryLimitException: function throwMemoryLimitException(requested, maximum) {\n    throw new MemoryLimitException(\"requested \" + requested + \" bytes, maximum allowed is \" + maximum + \" bytes (see Ice.MessageSizeMax)\");\n  }\n};\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/ExUtil.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Exception.js":
/*!***********************************************!*\
  !*** ./node_modules/ice/src/Ice/Exception.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _wrapNativeSuper(t) { var r = \"function\" == typeof Map ? new Map() : void 0; return _wrapNativeSuper = function _wrapNativeSuper(t) { if (null === t || !_isNativeFunction(t)) return t; if (\"function\" != typeof t) throw new TypeError(\"Super expression must either be null or a function\"); if (void 0 !== r) { if (r.has(t)) return r.get(t); r.set(t, Wrapper); } function Wrapper() { return _construct(t, arguments, _getPrototypeOf(this).constructor); } return Wrapper.prototype = Object.create(t.prototype, { constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf(Wrapper, t); }, _wrapNativeSuper(t); }\nfunction _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _isNativeFunction(t) { try { return -1 !== Function.toString.call(t).indexOf(\"[native code]\"); } catch (n) { return \"function\" == typeof t; } }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\nvar _toString = function toString(key, object, objectTable, ident) {\n  ident += \"  \";\n  if (object === null) {\n    return \"\\n\" + ident + key + \": (null)\";\n  }\n  if (object === undefined) {\n    return \"\\n\" + ident + key + \": (undefined)\";\n  }\n  if (key == \"stack\" || typeof object == \"function\") {\n    return \"\";\n  }\n  if (_typeof(object) != \"object\") {\n    return \"\\n\" + ident + key + \": \\\"\" + object + \"\\\"\";\n  }\n  if (objectTable.indexOf(object) != -1) {\n    return \"\\n\" + ident + key + \": (recursive)\";\n  }\n  objectTable.push(object);\n  var s = \"\\n\" + ident + key + \":\";\n  for (var k in object) {\n    if (key.indexOf(\"_\") === 0) {\n      continue;\n    }\n    if (typeof object[k] == \"function\") {\n      continue;\n    }\n    s += ident + _toString(k, object[k], objectTable, ident);\n  }\n  return s;\n};\n\n//\n// Ice.Exception\n//\nvar Exception = /*#__PURE__*/function (_Error) {\n  \"use strict\";\n\n  function Exception(cause) {\n    var _this;\n    _classCallCheck(this, Exception);\n    _this = _callSuper(this, Exception);\n    if (cause) {\n      _this.ice_cause = cause;\n    }\n    return _this;\n  }\n  _inherits(Exception, _Error);\n  return _createClass(Exception, [{\n    key: \"ice_name\",\n    value: function ice_name() {\n      return this.constructor._id.substr(2);\n    }\n  }, {\n    key: \"ice_id\",\n    value: function ice_id() {\n      return this.constructor._id;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      //\n      // We have a guard here to prevent being re-entered. With some browsers (IE), accessing\n      // the stack property ends up calling toString on the exception to print it out with the\n      // stack.\n      //\n      if (this._inToStringAlready) {\n        return \"\";\n      }\n      this._inToStringAlready = true;\n      var s = this.ice_id();\n      for (var key in this) {\n        if (key != \"_inToStringAlready\") {\n          s += _toString(key, this[key], [], \"\");\n        }\n      }\n      if (Ice._printStackTraces === true && this.stack) {\n        s += \"\\n\" + this.stack;\n      }\n      this._inToStringAlready = false;\n      return s;\n    }\n  }], [{\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::Exception\";\n    }\n  }, {\n    key: \"captureStackTrace\",\n    value: function captureStackTrace(object) {\n      var stack = new Error().stack;\n      //\n      // In IE 10 and greater the stack will be filled once the Error is throw\n      // we don't need to do anything.\n      //\n      if (stack !== undefined) {\n        Object.defineProperty(object, \"stack\", {\n          get: function get() {\n            return stack;\n          }\n        });\n      }\n    }\n  }]);\n}(/*#__PURE__*/_wrapNativeSuper(Error));\nIce.Exception = Exception;\n\n//\n// Ice.LocalException\n//\nvar LocalException = /*#__PURE__*/function (_Exception) {\n  \"use strict\";\n\n  function LocalException(cause) {\n    var _this2;\n    _classCallCheck(this, LocalException);\n    _this2 = _callSuper(this, LocalException, [cause]);\n    Exception.captureStackTrace(_this2);\n    return _this2;\n  }\n  _inherits(LocalException, _Exception);\n  return _createClass(LocalException, null, [{\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::LocalException\";\n    }\n  }]);\n}(Exception);\nIce.LocalException = LocalException;\n\n//\n// Ice.UserException\n//\nvar UserException = /*#__PURE__*/function (_Exception2) {\n  \"use strict\";\n\n  function UserException(cause) {\n    var _this3;\n    _classCallCheck(this, UserException);\n    _this3 = _callSuper(this, UserException, [cause]);\n    Exception.captureStackTrace(_this3);\n    return _this3;\n  }\n  _inherits(UserException, _Exception2);\n  return _createClass(UserException, [{\n    key: \"ice_getSlicedData\",\n    value: function ice_getSlicedData() {\n      return null;\n    }\n  }, {\n    key: \"_write\",\n    value: function _write(os) {\n      os.startException(null);\n      _writeImpl(this, os, this._mostDerivedType());\n      os.endException();\n    }\n  }, {\n    key: \"_read\",\n    value: function _read(is) {\n      is.startException();\n      _readImpl(this, is, this._mostDerivedType());\n      is.endException(false);\n    }\n  }, {\n    key: \"_usesClasses\",\n    value: function _usesClasses() {\n      return false;\n    }\n  }, {\n    key: \"_mostDerivedType\",\n    value: function _mostDerivedType() {\n      return Ice.UserException;\n    }\n  }], [{\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::UserException\";\n    }\n  }]);\n}(Exception);\nIce.UserException = UserException;\n\n//\n// Private methods\n//\n\nvar _writeImpl = function writeImpl(obj, os, type) {\n  //\n  // The writeImpl method is a recursive method that goes down the\n  // class hierarchy to marshal each slice of the class using the\n  // generated _writeMemberImpl method.\n  //\n\n  if (type === undefined || type === UserException) {\n    return; // Don't marshal anything for Ice.UserException\n  }\n  os.startSlice(type._id, -1, type._parent === UserException);\n  if (type.prototype.hasOwnProperty('_writeMemberImpl')) {\n    type.prototype._writeMemberImpl.call(obj, os);\n  }\n  os.endSlice();\n  _writeImpl(obj, os, type._parent);\n};\nvar _readImpl = function readImpl(obj, is, type) {\n  //\n  // The readImpl method is a recursive method that goes down the\n  // class hierarchy to marshal each slice of the class using the\n  // generated _readMemberImpl method.\n  //\n\n  if (type === undefined || type === UserException) {\n    return; // Don't marshal anything for UserException\n  }\n  is.startSlice();\n  if (type.prototype.hasOwnProperty('_readMemberImpl')) {\n    type.prototype._readMemberImpl.call(obj, is);\n  }\n  is.endSlice();\n  _readImpl(obj, is, type._parent);\n};\nvar writePreserved = function writePreserved(os) {\n  //\n  // For Slice exceptions which are marked \"preserved\", the implementation of this method\n  // replaces the Ice.UserException.prototype._write method.\n  //\n  os.startException(this._slicedData);\n  _writeImpl(this, os, this._mostDerivedType());\n  os.endException();\n};\nvar readPreserved = function readPreserved(is) {\n  //\n  // For Slice exceptions which are marked \"preserved\", the implementation of this method\n  // replaces the Ice.UserException.prototype._read method.\n  //\n  is.startException();\n  _readImpl(this, is, this._mostDerivedType());\n  this._slicedData = is.endException(true);\n};\nvar ice_getSlicedData = function ice_getSlicedData() {\n  return this._slicedData;\n};\nIce.Slice.PreservedUserException = function (ex) {\n  ex.prototype.ice_getSlicedData = ice_getSlicedData;\n  ex.prototype._write = writePreserved;\n  ex.prototype._read = readPreserved;\n};\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/Exception.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/FacetMap.js":
/*!**********************************************!*\
  !*** ./node_modules/ice/src/Ice/FacetMap.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `FacetMap.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nvar _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\nvar Ice = _ModuleRegistry.module(\"Ice\");\nvar Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n\nSlice.defineDictionary(Ice, \"FacetMap\", \"FacetMapHelper\", \"Ice.StringHelper\", \"Ice.ObjectHelper\", false, undefined, \"Ice.Value\");\n/* slice2js browser-bundle-skip */\nexports.Ice = Ice;\n/* slice2js browser-bundle-skip-end */\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/FacetMap.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/FormatType.js":
/*!************************************************!*\
  !*** ./node_modules/ice/src/Ice/FormatType.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/EnumBase */ \"./node_modules/ice/src/Ice/EnumBase.js\").Ice);\nIce.FormatType = Ice.Slice.defineEnum([['DefaultFormat', 0], ['CompactFormat', 1], ['SlicedFormat', 2]]);\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/FormatType.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/HashMap.js":
/*!*********************************************!*\
  !*** ./node_modules/ice/src/Ice/HashMap.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = \"function\" == typeof Symbol ? Symbol : {}, n = r.iterator || \"@@iterator\", o = r.toStringTag || \"@@toStringTag\"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, \"_invoke\", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError(\"Generator is already running\"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = \"next\"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError(\"iterator result is not an object\"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i[\"return\"]) && t.call(i), c < 2 && (u = TypeError(\"The iterator does not provide a '\" + o + \"' method\"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, \"GeneratorFunction\")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, \"constructor\", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = \"GeneratorFunction\", _regeneratorDefine2(GeneratorFunctionPrototype, o, \"GeneratorFunction\"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, \"Generator\"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, \"toString\", function () { return \"[object Generator]\"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }\nfunction _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, \"\", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o(\"next\", 0), o(\"throw\", 1), o(\"return\", 2)); }, _regeneratorDefine2(e, r, n, t); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n__webpack_require__(/*! ../Ice/StringUtil */ \"./node_modules/ice/src/Ice/StringUtil.js\");\n__webpack_require__(/*! ../Ice/UUID */ \"./node_modules/ice/src/Ice/UUID.js\");\nvar _ModuleRegistry = Ice._ModuleRegistry;\nvar StringUtil = Ice.StringUtil;\nfunction setInternal(map, key, value, hash, index) {\n  //\n  // Search for an entry with the same key.\n  //\n  for (var e = map._table[index]; e !== null; e = e._nextInBucket) {\n    if (e._hash === hash && map.keysEqual(key, e._key)) {\n      //\n      // Found a match, update the value.\n      //\n      e._value = value;\n      return undefined;\n    }\n  }\n\n  //\n  // No match found, add a new entry.\n  //\n  map.add(key, value, hash, index);\n  return undefined;\n}\nfunction compareEquals(v1, v2) {\n  if (v1 === v2) {\n    return true;\n  }\n  if (v1 === undefined || v1 === null || v2 === undefined || v2 === null) {\n    return false;\n  }\n  return v1.equals(v2);\n}\nfunction compareIdentity(v1, v2) {\n  return v1 === v2;\n}\nvar HashMap = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function HashMap(arg1, arg2) {\n    _classCallCheck(this, HashMap);\n    //\n    // The first argument can be a HashMap or the keyComparator, the second\n    // argument if present is always the value comparator.\n    //\n    var h, keyComparator, valueComparator;\n    if (typeof arg1 == \"function\") {\n      keyComparator = arg1;\n      valueComparator = arg2;\n    } else if (arg1 instanceof HashMap) {\n      h = arg1;\n      keyComparator = h.keyComparator;\n      valueComparator = h.valueComparator;\n    }\n    this._size = 0;\n    this._head = null;\n    this._initialCapacity = 32;\n    this._loadFactor = 0.75;\n    this._table = [];\n    this._keyComparator = typeof keyComparator == \"function\" ? keyComparator : compareIdentity;\n    this._valueComparator = typeof valueComparator == \"function\" ? valueComparator : compareIdentity;\n    if (h instanceof HashMap && h._size > 0) {\n      this._threshold = h._threshold;\n      this._table.length = h._table.length;\n      for (var i = 0; i < h._table.length; i++) {\n        this._table[i] = null;\n      }\n      this.merge(h);\n    } else {\n      this._threshold = this._initialCapacity * this._loadFactor;\n      for (var _i = 0; _i < this._initialCapacity; _i++) {\n        this._table[_i] = null;\n      }\n    }\n  }\n  return _createClass(HashMap, [{\n    key: \"set\",\n    value: function set(key, value) {\n      var r = this.computeHash(key); // Returns an object with key,hash members.\n\n      var index = this.hashIndex(r.hash, this._table.length);\n      return setInternal(this, r.key, value, r.hash, index);\n    }\n  }, {\n    key: \"get\",\n    value: function get(key) {\n      var r = this.computeHash(key); // Returns an object with key,hash members.\n      var e = this.findEntry(r.key, r.hash);\n      return e !== undefined ? e._value : undefined;\n    }\n  }, {\n    key: \"has\",\n    value: function has(key) {\n      var r = this.computeHash(key); // Returns an object with key,hash members.\n      return this.findEntry(r.key, r.hash) !== undefined;\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(key) {\n      var r = this.computeHash(key); // Returns an object with key,hash members.\n\n      var index = this.hashIndex(r.hash, this._table.length);\n\n      //\n      // Search for an entry with the same key.\n      //\n      var prev = null;\n      for (var e = this._table[index]; e !== null; e = e._nextInBucket) {\n        if (e._hash === r.hash && this.keysEqual(r.key, e._key)) {\n          //\n          // Found a match.\n          //\n          this._size--;\n\n          //\n          // Remove from bucket.\n          //\n          if (prev !== null) {\n            prev._nextInBucket = e._nextInBucket;\n          } else {\n            this._table[index] = e._nextInBucket;\n          }\n\n          //\n          // Unlink the entry.\n          //\n          if (e._prev !== null) {\n            e._prev._next = e._next;\n          }\n          if (e._next !== null) {\n            e._next._prev = e._prev;\n          }\n          if (this._head === e) {\n            this._head = e._next;\n          }\n          return e._value;\n        }\n        prev = e;\n      }\n      return undefined;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      for (var i = 0; i < this._table.length; ++i) {\n        this._table[i] = null;\n      }\n      this._head = null;\n      this._size = 0;\n    }\n  }, {\n    key: \"forEach\",\n    value: function forEach(fn, obj) {\n      obj = obj === undefined ? fn : obj;\n      for (var e = this._head; e !== null; e = e._next) {\n        fn.call(obj, e._value, e._key);\n      }\n    }\n  }, {\n    key: \"entries\",\n    value: /*#__PURE__*/_regenerator().m(function entries() {\n      var e;\n      return _regenerator().w(function (_context) {\n        while (1) switch (_context.n) {\n          case 0:\n            e = this._head;\n          case 1:\n            if (!(e !== null)) {\n              _context.n = 3;\n              break;\n            }\n            _context.n = 2;\n            return [e._key, e._value];\n          case 2:\n            e = e._next;\n            _context.n = 1;\n            break;\n          case 3:\n            return _context.a(2);\n        }\n      }, entries, this);\n    })\n  }, {\n    key: \"keys\",\n    value: /*#__PURE__*/_regenerator().m(function keys() {\n      var e;\n      return _regenerator().w(function (_context2) {\n        while (1) switch (_context2.n) {\n          case 0:\n            e = this._head;\n          case 1:\n            if (!(e !== null)) {\n              _context2.n = 3;\n              break;\n            }\n            _context2.n = 2;\n            return e._key;\n          case 2:\n            e = e._next;\n            _context2.n = 1;\n            break;\n          case 3:\n            return _context2.a(2);\n        }\n      }, keys, this);\n    })\n  }, {\n    key: \"values\",\n    value: /*#__PURE__*/_regenerator().m(function values() {\n      var e;\n      return _regenerator().w(function (_context3) {\n        while (1) switch (_context3.n) {\n          case 0:\n            e = this._head;\n          case 1:\n            if (!(e !== null)) {\n              _context3.n = 3;\n              break;\n            }\n            _context3.n = 2;\n            return e._value;\n          case 2:\n            e = e._next;\n            _context3.n = 1;\n            break;\n          case 3:\n            return _context3.a(2);\n        }\n      }, values, this);\n    })\n  }, {\n    key: \"equals\",\n    value: function equals(other, valuesEqual) {\n      var _this = this;\n      if (other === null || !(other instanceof HashMap) || this._size !== other._size) {\n        return false;\n      }\n      var eq;\n      if (valuesEqual) {\n        eq = valuesEqual;\n      } else {\n        eq = function eq(v1, v2) {\n          return _this._valueComparator.call(_this._valueComparator, v1, v2);\n        };\n      }\n      for (var e = this._head; e !== null; e = e._next) {\n        var oe = other.findEntry(e._key, e._hash);\n        if (oe === undefined || !eq(e._value, oe._value)) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }, {\n    key: \"merge\",\n    value: function merge(from) {\n      for (var e = from._head; e !== null; e = e._next) {\n        setInternal(this, e._key, e._value, e._hash, this.hashIndex(e._hash, this._table.length));\n      }\n    }\n  }, {\n    key: \"add\",\n    value: function add(key, value, hash, index) {\n      //\n      // Create a new table entry.\n      //\n      var e = Object.create(null, {\n        key: {\n          enumerable: true,\n          get: function get() {\n            return this._key;\n          }\n        },\n        value: {\n          enumerable: true,\n          get: function get() {\n            return this._value;\n          }\n        },\n        next: {\n          enumerable: true,\n          get: function get() {\n            return this._next;\n          }\n        },\n        _key: {\n          enumerable: false,\n          writable: true,\n          value: key\n        },\n        _value: {\n          enumerable: false,\n          writable: true,\n          value: value\n        },\n        _prev: {\n          enumerable: false,\n          writable: true,\n          value: null\n        },\n        _next: {\n          enumerable: false,\n          writable: true,\n          value: null\n        },\n        _nextInBucket: {\n          enumerable: false,\n          writable: true,\n          value: null\n        },\n        _hash: {\n          enumerable: false,\n          writable: true,\n          value: hash\n        }\n      });\n      e._nextInBucket = this._table[index];\n      this._table[index] = e;\n      e._next = this._head;\n      if (this._head !== null) {\n        this._head._prev = e;\n      }\n      this._head = e;\n      this._size++;\n      if (this._size >= this._threshold) {\n        this.resize(this._table.length * 2);\n      }\n    }\n  }, {\n    key: \"resize\",\n    value: function resize(capacity) {\n      var newTable = new Array(capacity).fill(null);\n\n      //\n      // Re-assign all entries to buckets.\n      //\n      for (var e = this._head; e !== null; e = e._next) {\n        var index = this.hashIndex(e._hash, capacity);\n        e._nextInBucket = newTable[index];\n        newTable[index] = e;\n      }\n      this._table = newTable;\n      this._threshold = capacity * this._loadFactor;\n    }\n  }, {\n    key: \"findEntry\",\n    value: function findEntry(key, hash) {\n      var index = this.hashIndex(hash, this._table.length);\n      //\n      // Search for an entry with the same key.\n      //\n      for (var e = this._table[index]; e !== null; e = e._nextInBucket) {\n        if (e._hash === hash && this.keysEqual(key, e._key)) {\n          return e;\n        }\n      }\n      return undefined;\n    }\n  }, {\n    key: \"hashIndex\",\n    value: function hashIndex(hash, len) {\n      return hash & len - 1;\n    }\n  }, {\n    key: \"computeHash\",\n    value: function computeHash(v) {\n      if (v === 0) {\n        return {\n          key: 0,\n          hash: 0\n        };\n      }\n      if (v === null) {\n        if (HashMap._null === null) {\n          var uuid = Ice.generateUUID();\n          HashMap._null = {\n            key: uuid,\n            hash: StringUtil.hashCode(uuid)\n          };\n        }\n        return HashMap._null;\n      }\n      if (v === undefined) {\n        throw new RangeError(\"cannot compute hash for undefined value\");\n      }\n      if (typeof v.hashCode === \"function\") {\n        return {\n          key: v,\n          hash: v.hashCode()\n        };\n      }\n      var type = _typeof(v);\n      if (type === \"string\" || v instanceof String) {\n        return {\n          key: v,\n          hash: StringUtil.hashCode(v)\n        };\n      } else if (type === \"number\" || v instanceof Number) {\n        if (isNaN(v)) {\n          if (HashMap._nan === null) {\n            var _uuid = Ice.generateUUID();\n            HashMap._nan = {\n              key: _uuid,\n              hash: StringUtil.hashCode(_uuid)\n            };\n          }\n          return HashMap._nan;\n        }\n        return {\n          key: v,\n          hash: v.toFixed(0)\n        };\n      } else if (type === \"boolean\" || v instanceof Boolean) {\n        return {\n          key: v,\n          hash: v ? 1 : 0\n        };\n      }\n      throw new RangeError(\"cannot compute hash for value of type \" + type);\n    }\n  }, {\n    key: \"keysEqual\",\n    value: function keysEqual(k1, k2) {\n      return this._keyComparator.call(this._keyComparator, k1, k2);\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      return this._size;\n    }\n  }]);\n}();\nHashMap.prototype[Symbol.iterator] = HashMap.prototype.entries;\nIce.HashMap = HashMap;\nHashMap.compareEquals = compareEquals;\nHashMap.compareIdentity = compareIdentity;\nHashMap._null = null;\nHashMap._nan = null;\nvar Slice = Ice.Slice;\nSlice.defineDictionary = function (module, name, helperName, keyHelper, valueHelper, fixed, keysEqual, valueType) {\n  if (keysEqual === undefined) {\n    module[name] = Map;\n  } else {\n    //\n    // Define a constructor function for a dictionary whose key type requires\n    // comparison using an equals() method instead of the native comparison\n    // operators.\n    //\n    module[name] = function (h) {\n      return new HashMap(h || keysEqual);\n    };\n  }\n  var helper = null;\n  Object.defineProperty(module, helperName, {\n    get: function get() {\n      if (helper === null) {\n        helper = Ice.StreamHelpers.generateDictHelper(_ModuleRegistry.type(keyHelper), _ModuleRegistry.type(valueHelper), fixed, _ModuleRegistry.type(valueType), module[name]);\n      }\n      return helper;\n    }\n  });\n};\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/HashMap.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/HashUtil.js":
/*!**********************************************!*\
  !*** ./node_modules/ice/src/Ice/HashUtil.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/StringUtil */ \"./node_modules/ice/src/Ice/StringUtil.js\").Ice);\nvar StringUtil = Ice.StringUtil;\nvar HashUtil = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function HashUtil() {\n    _classCallCheck(this, HashUtil);\n  }\n  return _createClass(HashUtil, null, [{\n    key: \"addBoolean\",\n    value: function addBoolean(h, b) {\n      return (h << 5) + h ^ (b ? 0 : 1);\n    }\n  }, {\n    key: \"addString\",\n    value: function addString(h, str) {\n      if (str !== undefined && str !== null) {\n        h = (h << 5) + h ^ StringUtil.hashCode(str);\n      }\n      return h;\n    }\n  }, {\n    key: \"addNumber\",\n    value: function addNumber(h, num) {\n      return (h << 5) + h ^ num;\n    }\n  }, {\n    key: \"addHashable\",\n    value: function addHashable(h, obj) {\n      if (obj !== undefined && obj !== null) {\n        h = (h << 5) + h ^ obj.hashCode();\n      }\n      return h;\n    }\n  }, {\n    key: \"addArray\",\n    value: function addArray(h, arr, hashCode) {\n      if (arr !== undefined && arr !== null) {\n        for (var i = 0; i < arr.length; ++i) {\n          h = hashCode(h, arr[i]);\n        }\n      }\n      return h;\n    }\n  }]);\n}();\nIce.HashUtil = HashUtil;\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/HashUtil.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/IPEndpointI.js":
/*!*************************************************!*\
  !*** ./node_modules/ice/src/Ice/IPEndpointI.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && \"function\" == typeof p ? function (t) { return p.apply(e, t); } : p; }\nfunction _get() { return _get = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }\nfunction _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n__webpack_require__(/*! ../Ice/Address */ \"./node_modules/ice/src/Ice/Address.js\");\n__webpack_require__(/*! ../Ice/EndpointI */ \"./node_modules/ice/src/Ice/EndpointI.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\");\n__webpack_require__(/*! ../Ice/StringUtil */ \"./node_modules/ice/src/Ice/StringUtil.js\");\nvar Address = Ice.Address;\nvar EndpointParseException = Ice.EndpointParseException;\nvar HashUtil = Ice.HashUtil;\nvar StringUtil = Ice.StringUtil;\nvar IPEndpointI = /*#__PURE__*/function (_Ice$EndpointI) {\n  \"use strict\";\n\n  function IPEndpointI(instance, ho, po, sa, conId) {\n    var _this;\n    _classCallCheck(this, IPEndpointI);\n    _this = _callSuper(this, IPEndpointI);\n    _this._instance = instance;\n    _this._host = ho === undefined ? null : ho;\n    _this._port = po === undefined ? 0 : po;\n    _this._sourceAddr = sa === undefined ? null : sa;\n    _this._connectionId = conId === undefined ? \"\" : conId;\n    return _this;\n  }\n\n  //\n  // Marshal the endpoint\n  //\n  _inherits(IPEndpointI, _Ice$EndpointI);\n  return _createClass(IPEndpointI, [{\n    key: \"streamWrite\",\n    value: function streamWrite(s) {\n      s.startEncapsulation();\n      this.streamWriteImpl(s);\n      s.endEncapsulation();\n    }\n  }, {\n    key: \"getInfo\",\n    value: function getInfo() {\n      var info = new Ice.IPEndpointInfo();\n      this.fillEndpointInfo(info);\n      return info;\n    }\n\n    //\n    // Return the endpoint type\n    //\n  }, {\n    key: \"type\",\n    value: function type() {\n      return this._instance.type();\n    }\n\n    //\n    // Return the protocol string\n    //\n  }, {\n    key: \"protocol\",\n    value: function protocol() {\n      return this._instance.protocol();\n    }\n\n    //\n    // Return true if the endpoint is secure.\n    //\n  }, {\n    key: \"secure\",\n    value: function secure() {\n      return this._instance.secure();\n    }\n  }, {\n    key: \"connectionId\",\n    value: function connectionId() {\n      return this._connectionId;\n    }\n\n    //\n    // Return a new endpoint with a different connection id.\n    //\n  }, {\n    key: \"changeConnectionId\",\n    value: function changeConnectionId(connectionId) {\n      if (connectionId === this._connectionId) {\n        return this;\n      } else {\n        return this.createEndpoint(this._host, this._port, connectionId);\n      }\n    }\n\n    //\n    // Return the endpoint information.\n    //\n  }, {\n    key: \"hashCode\",\n    value: function hashCode() {\n      if (this._hashCode === undefined) {\n        this._hashCode = this.hashInit(5381);\n      }\n      return this._hashCode;\n    }\n  }, {\n    key: \"options\",\n    value: function options() {\n      //\n      // WARNING: Certain features, such as proxy validation in Glacier2,\n      // depend on the format of proxy strings. Changes to toString() and\n      // methods called to generate parts of the reference string could break\n      // these features. Please review for all features that depend on the\n      // format of proxyToString() before changing this and related code.\n      //\n      var s = \"\";\n      if (this._host !== null && this._host.length > 0) {\n        s += \" -h \";\n        var addQuote = this._host.indexOf(':') != -1;\n        if (addQuote) {\n          s += \"\\\"\";\n        }\n        s += this._host;\n        if (addQuote) {\n          s += \"\\\"\";\n        }\n      }\n      s += \" -p \" + this._port;\n      if (this._sourceAddr !== null && this._sourceAddr.length > 0) {\n        s += \" --sourceAddress \";\n        var _addQuote = this._sourceAddr.indexOf(':') != -1;\n        if (_addQuote) {\n          s += \"\\\"\";\n        }\n        s += this._sourceAddr;\n        if (_addQuote) {\n          s += \"\\\"\";\n        }\n      }\n      return s;\n    }\n  }, {\n    key: \"compareTo\",\n    value: function compareTo(p) {\n      if (this === p) {\n        return 0;\n      }\n      if (p === null) {\n        return 1;\n      }\n      if (!(p instanceof IPEndpointI)) {\n        return this.type() < p.type() ? -1 : 1;\n      }\n      if (this._port < p._port) {\n        return -1;\n      } else if (p._port < this._port) {\n        return 1;\n      }\n      if (this._host != p._host) {\n        return this._host < p._host ? -1 : 1;\n      }\n      if (this._sourceAddr != p._sourceAddr) {\n        return this._sourceAddr < p._sourceAddr ? -1 : 1;\n      }\n      if (this._connectionId != p._connectionId) {\n        return this._connectionId < p._connectionId ? -1 : 1;\n      }\n      return 0;\n    }\n  }, {\n    key: \"getAddress\",\n    value: function getAddress() {\n      return new Address(this._host, this._port);\n    }\n\n    //\n    // Convert the endpoint to its Connector string form\n    //\n  }, {\n    key: \"toConnectorString\",\n    value: function toConnectorString() {\n      return this._host + \":\" + this._port;\n    }\n  }, {\n    key: \"streamWriteImpl\",\n    value: function streamWriteImpl(s) {\n      s.writeString(this._host);\n      s.writeInt(this._port);\n    }\n  }, {\n    key: \"hashInit\",\n    value: function hashInit(h) {\n      h = HashUtil.addNumber(h, this.type());\n      h = HashUtil.addString(h, this._host);\n      h = HashUtil.addNumber(h, this._port);\n      h = HashUtil.addString(h, this._sourceAddr);\n      h = HashUtil.addString(h, this._connectionId);\n      return h;\n    }\n  }, {\n    key: \"fillEndpointInfo\",\n    value: function fillEndpointInfo(info) {\n      var _this2 = this;\n      info.type = function () {\n        return _this2.type();\n      };\n      info.datagram = function () {\n        return _this2.datagram();\n      };\n      info.secure = function () {\n        return _this2.secure();\n      };\n      info.host = this._host;\n      info.port = this._port;\n      info.sourceAddress = this._sourceAddr;\n    }\n  }, {\n    key: \"initWithOptions\",\n    value: function initWithOptions(args, oaEndpoint) {\n      _superPropGet(IPEndpointI, \"initWithOptions\", this, 3)([args]);\n      if (this._host === null || this._host.length === 0) {\n        this._host = this._instance.defaultHost();\n      } else if (this._host == \"*\") {\n        if (oaEndpoint) {\n          this._host = \"\";\n        } else {\n          throw new EndpointParseException(\"`-h *' not valid for proxy endpoint `\" + this + \"'\");\n        }\n      }\n      if (this._host === null) {\n        this._host = \"\";\n      }\n      if (this._sourceAddr === null) {\n        if (!oaEndpoint) {\n          this._sourceAddr = this._instance.defaultSourceAddress();\n        }\n      } else if (oaEndpoint) {\n        throw new EndpointParseException(\"`--sourceAddress not valid for object adapter endpoint `\" + this + \"'\");\n      }\n    }\n  }, {\n    key: \"initWithStream\",\n    value: function initWithStream(s) {\n      this._host = s.readString();\n      this._port = s.readInt();\n    }\n  }, {\n    key: \"checkOption\",\n    value: function checkOption(option, argument, str) {\n      if (option === \"-h\") {\n        if (argument === null) {\n          throw new EndpointParseException(\"no argument provided for -h option in endpoint \" + str);\n        }\n        this._host = argument;\n      } else if (option === \"-p\") {\n        if (argument === null) {\n          throw new EndpointParseException(\"no argument provided for -p option in endpoint \" + str);\n        }\n        try {\n          this._port = StringUtil.toInt(argument);\n        } catch (ex) {\n          throw new EndpointParseException(\"invalid port value `\" + argument + \"' in endpoint \" + str);\n        }\n        if (this._port < 0 || this._port > 65535) {\n          throw new EndpointParseException(\"port value `\" + argument + \"' out of range in endpoint \" + str);\n        }\n      } else if (option === \"--sourceAddress\") {\n        if (argument === null) {\n          throw new EndpointParseException(\"no argument provided for --sourceAddress option in endpoint \" + str);\n        }\n        this._sourceAddr = argument;\n      } else {\n        return false;\n      }\n      return true;\n    }\n  }]);\n}(Ice.EndpointI);\nIce.IPEndpointI = IPEndpointI;\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/IPEndpointI.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Ice.js":
/*!*****************************************!*\
  !*** ./node_modules/ice/src/Ice/Ice.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/BatchRequestQueue */ \"./node_modules/ice/src/Ice/BatchRequestQueue.js\");\n__webpack_require__(/*! ../Ice/Buffer */ \"./node_modules/ice/src/Ice/Buffer.js\");\n__webpack_require__(/*! ../Ice/BuiltinSequences */ \"./node_modules/ice/src/Ice/BuiltinSequences.js\");\n__webpack_require__(/*! ../Ice/Communicator */ \"./node_modules/ice/src/Ice/Communicator.js\");\n__webpack_require__(/*! ../Ice/CommunicatorI */ \"./node_modules/ice/src/Ice/CommunicatorI.js\");\n__webpack_require__(/*! ../Ice/EndpointTypes */ \"./node_modules/ice/src/Ice/EndpointTypes.js\");\n__webpack_require__(/*! ../Ice/Exception */ \"./node_modules/ice/src/Ice/Exception.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/Identity */ \"./node_modules/ice/src/Ice/Identity.js\");\n__webpack_require__(/*! ../Ice/IdentityUtil */ \"./node_modules/ice/src/Ice/IdentityUtil.js\");\n__webpack_require__(/*! ../Ice/Initialize */ \"./node_modules/ice/src/Ice/Initialize.js\");\n__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\");\n__webpack_require__(/*! ../Ice/Locator */ \"./node_modules/ice/src/Ice/Locator.js\");\n__webpack_require__(/*! ../Ice/Logger */ \"./node_modules/ice/src/Ice/Logger.js\");\n__webpack_require__(/*! ../Ice/LoggerI */ \"./node_modules/ice/src/Ice/LoggerI.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/MapUtil */ \"./node_modules/ice/src/Ice/MapUtil.js\");\n__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\");\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/ObjectPrx */ \"./node_modules/ice/src/Ice/ObjectPrx.js\");\n__webpack_require__(/*! ../Ice/Process */ \"./node_modules/ice/src/Ice/Process.js\");\n__webpack_require__(/*! ../Ice/ProcessLogger */ \"./node_modules/ice/src/Ice/ProcessLogger.js\");\n__webpack_require__(/*! ../Ice/Promise */ \"./node_modules/ice/src/Ice/Promise.js\");\n__webpack_require__(/*! ../Ice/Properties */ \"./node_modules/ice/src/Ice/Properties.js\");\n__webpack_require__(/*! ../Ice/PropertiesI */ \"./node_modules/ice/src/Ice/PropertiesI.js\");\n__webpack_require__(/*! ../Ice/Protocol */ \"./node_modules/ice/src/Ice/Protocol.js\");\n__webpack_require__(/*! ../Ice/Router */ \"./node_modules/ice/src/Ice/Router.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\n__webpack_require__(/*! ../Ice/ToStringMode */ \"./node_modules/ice/src/Ice/ToStringMode.js\");\n__webpack_require__(/*! ../Ice/UnknownSlicedValue */ \"./node_modules/ice/src/Ice/UnknownSlicedValue.js\");\n__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\");\n__webpack_require__(/*! ../Ice/Version */ \"./node_modules/ice/src/Ice/Version.js\");\nmodule.exports.Ice = __webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice;\nmodule.exports.IceMX = __webpack_require__(/*! ../Ice/Metrics */ \"./node_modules/ice/src/Ice/Metrics.js\").IceMX;\nmodule.exports.IceSSL = __webpack_require__(/*! ../Ice/EndpointInfo */ \"./node_modules/ice/src/Ice/EndpointInfo.js\").IceSSL;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/Ice.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Identity.js":
/*!**********************************************!*\
  !*** ./node_modules/ice/src/Ice/Identity.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `Identity.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nvar _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\");\n__webpack_require__(/*! ../Ice/Struct */ \"./node_modules/ice/src/Ice/Struct.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\nvar Ice = _ModuleRegistry.module(\"Ice\");\nvar Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n\n/**\n * The identity of an Ice object. In a proxy, an empty {@link Identity#name} denotes a nil\n * proxy. An identity with an empty {@link Identity#name} and a non-empty {@link Identity#category}\n * is illegal. You cannot add a servant with an empty name to the Active Servant Map.\n *\n * @see ServantLocator\n * @see ObjectAdapter#addServantLocator\n *\n **/\nIce.Identity = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function _class() {\n    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var category = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class);\n    this.name = name;\n    this.category = category;\n  }\n  return _createClass(_class, [{\n    key: \"_write\",\n    value: function _write(ostr) {\n      ostr.writeString(this.name);\n      ostr.writeString(this.category);\n    }\n  }, {\n    key: \"_read\",\n    value: function _read(istr) {\n      this.name = istr.readString();\n      this.category = istr.readString();\n    }\n  }], [{\n    key: \"minWireSize\",\n    get: function get() {\n      return 2;\n    }\n  }]);\n}();\nSlice.defineStruct(Ice.Identity, true, true);\nSlice.defineDictionary(Ice, \"ObjectDict\", \"ObjectDictHelper\", \"Ice.Identity\", \"Ice.ObjectHelper\", false, Ice.HashMap.compareEquals, \"Ice.Value\");\nSlice.defineSequence(Ice, \"IdentitySeqHelper\", \"Ice.Identity\", false);\n/* slice2js browser-bundle-skip */\nexports.Ice = Ice;\n/* slice2js browser-bundle-skip-end */\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/Identity.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/IdentityUtil.js":
/*!**************************************************!*\
  !*** ./node_modules/ice/src/Ice/IdentityUtil.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n__webpack_require__(/*! ../Ice/Identity */ \"./node_modules/ice/src/Ice/Identity.js\");\n__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\");\n__webpack_require__(/*! ../Ice/StringUtil */ \"./node_modules/ice/src/Ice/StringUtil.js\");\nvar Identity = Ice.Identity;\nvar IdentityParseException = Ice.IdentityParseException;\nvar StringUtil = Ice.StringUtil;\n\n/**\n* Converts a string to an object identity.\n*\n* @param s The string to convert.\n*\n* @return The converted object identity.\n**/\nIce.stringToIdentity = function (s) {\n  var ident = new Identity();\n\n  //\n  // Find unescaped separator; note that the string may contain an escaped\n  // backslash before the separator.\n  //\n  var slash = -1;\n  var pos = 0;\n  while ((pos = s.indexOf('/', pos)) !== -1) {\n    var escapes = 0;\n    while (pos - escapes > 0 && s.charAt(pos - escapes - 1) == '\\\\') {\n      escapes++;\n    }\n\n    //\n    // We ignore escaped escapes\n    //\n    if (escapes % 2 === 0) {\n      if (slash == -1) {\n        slash = pos;\n      } else {\n        //\n        // Extra unescaped slash found.\n        //\n        throw new IdentityParseException(\"unescaped backslash in identity `\".concat(s, \"'\"));\n      }\n    }\n    pos++;\n  }\n  if (slash == -1) {\n    ident.category = \"\";\n    try {\n      ident.name = StringUtil.unescapeString(s, 0, s.length, \"/\");\n    } catch (e) {\n      throw new IdentityParseException(\"invalid identity name `\".concat(s, \"': \").concat(e.toString()));\n    }\n  } else {\n    try {\n      ident.category = StringUtil.unescapeString(s, 0, slash, \"/\");\n    } catch (e) {\n      throw new IdentityParseException(\"invalid category in identity `\".concat(s, \"': \").concat(e.toString()));\n    }\n    if (slash + 1 < s.length) {\n      try {\n        ident.name = StringUtil.unescapeString(s, slash + 1, s.length, \"/\");\n      } catch (e) {\n        throw new IdentityParseException(\"invalid name in identity `\".concat(s, \"': \").concat(e.toString()));\n      }\n    } else {\n      ident.name = \"\";\n    }\n  }\n  return ident;\n};\n\n/**\n* Converts an object identity to a string.\n*\n* @param ident The object identity to convert.\n*\n* @param toStringMode Specifies if and how non-printable ASCII characters are escaped in the result.\n*\n* @return The string representation of the object identity.\n**/\nIce.identityToString = function (ident) {\n  var toStringMode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Ice.ToStringMode.Unicode;\n  if (ident.category === null || ident.category.length === 0) {\n    return StringUtil.escapeString(ident.name, \"/\", toStringMode);\n  } else {\n    return StringUtil.escapeString(ident.category, \"/\", toStringMode) + '/' + StringUtil.escapeString(ident.name, \"/\", toStringMode);\n  }\n};\n\n/**\n* Compares the object identities of two proxies.\n*\n* @param lhs A proxy.\n* @param rhs A proxy.\n* @return -1 if the identity in <code>lhs</code> compares\n* less than the identity in <code>rhs</code>; 0 if the identities\n* compare equal; 1, otherwise.\n*\n* @see ProxyIdentityKey\n* @see ProxyIdentityAndFacetKey\n* @see ProxyIdentityAndFacetCompare\n**/\nIce.proxyIdentityCompare = function (lhs, rhs) {\n  if (lhs === rhs) {\n    return 0;\n  } else if (lhs === null && rhs !== null) {\n    return -1;\n  } else if (lhs !== null && rhs === null) {\n    return 1;\n  } else {\n    var lhsIdentity = lhs.ice_getIdentity();\n    var rhsIdentity = rhs.ice_getIdentity();\n    var n = lhsIdentity.name.localeCompare(rhsIdentity.name);\n    return n !== 0 ? n : lhsIdentity.category.localeCompare(rhsIdentity.category);\n  }\n};\n\n/**\n* Compares the object identities and facets of two proxies.\n*\n* @param lhs A proxy.\n* @param rhs A proxy.\n* @return -1 if the identity and facet in <code>lhs</code> compare\n* less than the identity and facet in <code>rhs</code>; 0 if the identities\n* and facets compare equal; 1, otherwise.\n*\n* @see ProxyIdentityAndFacetKey\n* @see ProxyIdentityKey\n* @see ProxyIdentityCompare\n**/\nIce.proxyIdentityAndFacetCompare = function (lhs, rhs) {\n  if (lhs === rhs) {\n    return 0;\n  } else if (lhs === null && rhs !== null) {\n    return -1;\n  } else if (lhs !== null && rhs === null) {\n    return 1;\n  } else {\n    var lhsIdentity = lhs.ice_getIdentity();\n    var rhsIdentity = rhs.ice_getIdentity();\n    var n = lhsIdentity.name.localeCompare(rhsIdentity.name);\n    if (n !== 0) {\n      return n;\n    }\n    n = lhsIdentity.category.localeCompare(rhsIdentity.category);\n    if (n !== 0) {\n      return n;\n    }\n    var lhsFacet = lhs.ice_getFacet();\n    var rhsFacet = rhs.ice_getFacet();\n    if (lhsFacet === null && rhsFacet === null) {\n      return 0;\n    } else if (lhsFacet === null) {\n      return -1;\n    } else if (rhsFacet === null) {\n      return 1;\n    }\n    return lhsFacet.localeCompare(rhsFacet);\n  }\n};\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/IdentityUtil.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/ImplicitContextF.js":
/*!******************************************************!*\
  !*** ./node_modules/ice/src/Ice/ImplicitContextF.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `ImplicitContextF.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nvar _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\nvar Ice = _ModuleRegistry.module(\"Ice\");\nvar Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n/* slice2js browser-bundle-skip */\nexports.Ice = Ice;\n/* slice2js browser-bundle-skip-end */\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/ImplicitContextF.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/ImplicitContextI.js":
/*!******************************************************!*\
  !*** ./node_modules/ice/src/Ice/ImplicitContextI.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n__webpack_require__(/*! ../Ice/Current */ \"./node_modules/ice/src/Ice/Current.js\");\n__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\");\nvar Context = Ice.Context;\nvar InitializationException = Ice.InitializationException;\n\n//\n// The base class for all ImplicitContext implementations\n//\nvar ImplicitContextI = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function ImplicitContextI() {\n    _classCallCheck(this, ImplicitContextI);\n    this._context = new Context();\n  }\n  return _createClass(ImplicitContextI, [{\n    key: \"getContext\",\n    value: function getContext() {\n      return new Context(this._context);\n    }\n  }, {\n    key: \"setContext\",\n    value: function setContext(context) {\n      if (context !== null && context.size > 0) {\n        this._context = new Context(context);\n      } else {\n        this._context.clear();\n      }\n    }\n  }, {\n    key: \"containsKey\",\n    value: function containsKey(key) {\n      if (key === null) {\n        key = \"\";\n      }\n      return this._context.has(key);\n    }\n  }, {\n    key: \"get\",\n    value: function get(key) {\n      if (key === null) {\n        key = \"\";\n      }\n      var val = this._context.get(key);\n      if (val === null) {\n        val = \"\";\n      }\n      return val;\n    }\n  }, {\n    key: \"put\",\n    value: function put(key, value) {\n      if (key === null) {\n        key = \"\";\n      }\n      if (value === null) {\n        value = \"\";\n      }\n      var oldVal = this._context.get(key);\n      if (oldVal === null) {\n        oldVal = \"\";\n      }\n      this._context.set(key, value);\n      return oldVal;\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(key) {\n      if (key === null) {\n        key = \"\";\n      }\n      var val = this._context.get(key);\n      this._context[\"delete\"](key);\n      if (val === null) {\n        val = \"\";\n      }\n      return val;\n    }\n  }, {\n    key: \"write\",\n    value: function write(prxContext, os) {\n      if (prxContext.size === 0) {\n        Ice.ContextHelper.write(os, this._context);\n      } else {\n        var ctx = null;\n        if (this._context.size === 0) {\n          ctx = prxContext;\n        } else {\n          ctx = new Context(this._context);\n          var _iterator = _createForOfIteratorHelper(prxContext),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var _step$value = _slicedToArray(_step.value, 2),\n                key = _step$value[0],\n                value = _step$value[1];\n              ctx.set(key, value);\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        }\n        Ice.ContextHelper.write(os, ctx);\n      }\n    }\n  }], [{\n    key: \"create\",\n    value: function create(kind) {\n      if (kind.length === 0 || kind === \"None\") {\n        return null;\n      } else if (kind === \"Shared\") {\n        return new ImplicitContextI();\n      } else {\n        throw new InitializationException(\"'\" + kind + \"' is not a valid value for Ice.ImplicitContext\");\n      }\n    }\n  }]);\n}();\nIce.ImplicitContextI = ImplicitContextI;\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/ImplicitContextI.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/IncomingAsync.js":
/*!***************************************************!*\
  !*** ./node_modules/ice/src/Ice/IncomingAsync.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n__webpack_require__(/*! ../Ice/BuiltinSequences */ \"./node_modules/ice/src/Ice/BuiltinSequences.js\");\n__webpack_require__(/*! ../Ice/Connection */ \"./node_modules/ice/src/Ice/Connection.js\");\n__webpack_require__(/*! ../Ice/Current */ \"./node_modules/ice/src/Ice/Current.js\");\n__webpack_require__(/*! ../Ice/Debug */ \"./node_modules/ice/src/Ice/Debug.js\");\n__webpack_require__(/*! ../Ice/Exception */ \"./node_modules/ice/src/Ice/Exception.js\");\n__webpack_require__(/*! ../Ice/Identity */ \"./node_modules/ice/src/Ice/Identity.js\");\n__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\");\n__webpack_require__(/*! ../Ice/Protocol */ \"./node_modules/ice/src/Ice/Protocol.js\");\n__webpack_require__(/*! ../Ice/Stream */ \"./node_modules/ice/src/Ice/Stream.js\");\n__webpack_require__(/*! ../Ice/StringUtil */ \"./node_modules/ice/src/Ice/StringUtil.js\");\nvar OutputStream = Ice.OutputStream;\nvar Current = Ice.Current;\nvar Debug = Ice.Debug;\nvar Context = Ice.Context;\nvar Identity = Ice.Identity;\nvar Protocol = Ice.Protocol;\nvar StringUtil = Ice.StringUtil;\nvar IncomingAsync = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function IncomingAsync(instance, connection, adapter, response, requestId) {\n    _classCallCheck(this, IncomingAsync);\n    this._instance = instance;\n    this._response = response;\n    this._connection = connection;\n    this._format = Ice.FormatType.DefaultFormat;\n    this._current = new Current();\n    this._current.id = new Identity();\n    this._current.adapter = adapter;\n    this._current.con = this._connection;\n    this._current.requestId = requestId;\n    this._servant = null;\n    this._locator = null;\n    this._cookie = {\n      value: null\n    };\n    this._os = null;\n    this._is = null;\n  }\n  return _createClass(IncomingAsync, [{\n    key: \"startWriteParams\",\n    value: function startWriteParams() {\n      if (!this._response) {\n        throw new Ice.MarshalException(\"can't marshal out parameters for oneway dispatch\");\n      }\n      Debug.assert(this._current.encoding !== null); // Encoding for reply is known.\n      this._os = new OutputStream(this._instance, Protocol.currentProtocolEncoding);\n      this._os.writeBlob(Protocol.replyHdr);\n      this._os.writeInt(this._current.requestId);\n      this._os.writeByte(0);\n      this._os.startEncapsulation(this._current.encoding, this._format);\n      return this._os;\n    }\n  }, {\n    key: \"endWriteParams\",\n    value: function endWriteParams() {\n      if (this._response) {\n        this._os.endEncapsulation();\n      }\n    }\n  }, {\n    key: \"writeEmptyParams\",\n    value: function writeEmptyParams() {\n      if (this._response) {\n        Debug.assert(this._current.encoding !== null); // Encoding for reply is known.\n        this._os = new OutputStream(this._instance, Protocol.currentProtocolEncoding);\n        this._os.writeBlob(Protocol.replyHdr);\n        this._os.writeInt(this._current.requestId);\n        this._os.writeByte(Protocol.replyOK);\n        this._os.writeEmptyEncapsulation(this._current.encoding);\n      }\n    }\n  }, {\n    key: \"writeParamEncaps\",\n    value: function writeParamEncaps(v, ok) {\n      if (this._response) {\n        Debug.assert(this._current.encoding !== null); // Encoding for reply is known.\n        this._os = new OutputStream(this._instance, Protocol.currentProtocolEncoding);\n        this._os.writeBlob(Protocol.replyHdr);\n        this._os.writeInt(this._current.requestId);\n        this._os.writeByte(ok ? Protocol.replyOK : Protocol.replyUserException);\n        if (v === null || v.length === 0) {\n          this._os.writeEmptyEncapsulation(this._current.encoding);\n        } else {\n          this._os.writeEncapsulation(v);\n        }\n      }\n    }\n  }, {\n    key: \"setFormat\",\n    value: function setFormat(format) {\n      this._format = format;\n    }\n  }, {\n    key: \"warning\",\n    value: function warning(ex) {\n      Debug.assert(this._instance !== null);\n      var s = [];\n      s.push(\"dispatch exception:\");\n      s.push(\"\\nidentity: \" + Ice.identityToString(this._current.id, this._instance.toStringMode()));\n      s.push(\"\\nfacet: \" + StringUtil.escapeString(this._current.facet, \"\", this._instance.toStringMode()));\n      s.push(\"\\noperation: \" + this._current.operation);\n      if (this._connection !== null) {\n        try {\n          for (var p = this._connection.getInfo(); p; p = p.underlying) {\n            if (p instanceof Ice.IPConnectionInfo) {\n              s.push(\"\\nremote host: \" + p.remoteAddress + \" remote port: \" + p.remotePort);\n            }\n          }\n        } catch (exc) {\n          // Ignore.\n        }\n      }\n      if (ex.stack) {\n        s.push(\"\\n\");\n        s.push(ex.stack);\n      }\n      this._instance.initializationData().logger.warning(s.join(\"\"));\n    }\n  }, {\n    key: \"handleException\",\n    value: function handleException(ex, amd) {\n      Debug.assert(this._connection !== null);\n      var props = this._instance.initializationData().properties;\n      if (ex instanceof Ice.RequestFailedException) {\n        if (ex.id === null) {\n          ex.id = this._current.id;\n        }\n        if (ex.facet === null) {\n          ex.facet = this._current.facet;\n        }\n        if (ex.operation === null || ex.operation.length === 0) {\n          ex.operation = this._current.operation;\n        }\n        if (props.getPropertyAsIntWithDefault(\"Ice.Warn.Dispatch\", 1) > 1) {\n          this.warning(ex);\n        }\n        if (this._response) {\n          this._os = new OutputStream(this._instance, Protocol.currentProtocolEncoding);\n          this._os.writeBlob(Protocol.replyHdr);\n          this._os.writeInt(this._current.requestId);\n          if (ex instanceof Ice.ObjectNotExistException) {\n            this._os.writeByte(Protocol.replyObjectNotExist);\n          } else if (ex instanceof Ice.FacetNotExistException) {\n            this._os.writeByte(Protocol.replyFacetNotExist);\n          } else if (ex instanceof Ice.OperationNotExistException) {\n            this._os.writeByte(Protocol.replyOperationNotExist);\n          } else {\n            Debug.assert(false);\n          }\n          ex.id._write(this._os);\n\n          //\n          // For compatibility with the old FacetPath.\n          //\n          if (ex.facet === null || ex.facet.length === 0) {\n            Ice.StringSeqHelper.write(this._os, null);\n          } else {\n            Ice.StringSeqHelper.write(this._os, [ex.facet]);\n          }\n          this._os.writeString(ex.operation);\n          this._connection.sendResponse(this._os);\n        } else {\n          this._connection.sendNoResponse();\n        }\n      } else if (ex instanceof Ice.UnknownLocalException) {\n        if (props.getPropertyAsIntWithDefault(\"Ice.Warn.Dispatch\", 1) > 0) {\n          this.warning(ex);\n        }\n        if (this._response) {\n          this._os = new OutputStream(this._instance, Protocol.currentProtocolEncoding);\n          this._os.writeBlob(Protocol.replyHdr);\n          this._os.writeInt(this._current.requestId);\n          this._os.writeByte(Protocol.replyUnknownLocalException);\n          this._os.writeString(ex.unknown);\n          this._connection.sendResponse(this._os);\n        } else {\n          this._connection.sendNoResponse();\n        }\n      } else if (ex instanceof Ice.UnknownUserException) {\n        if (props.getPropertyAsIntWithDefault(\"Ice.Warn.Dispatch\", 1) > 0) {\n          this.warning(ex);\n        }\n        if (this._response) {\n          this._os = new OutputStream(this._instance, Protocol.currentProtocolEncoding);\n          this._os.writeBlob(Protocol.replyHdr);\n          this._os.writeInt(this._current.requestId);\n          this._os.writeByte(Protocol.replyUnknownUserException);\n          this._os.writeString(ex.unknown);\n          this._connection.sendResponse(this._os);\n        } else {\n          this._connection.sendNoResponse();\n        }\n      } else if (ex instanceof Ice.UnknownException) {\n        if (props.getPropertyAsIntWithDefault(\"Ice.Warn.Dispatch\", 1) > 0) {\n          this.warning(ex);\n        }\n        if (this._response) {\n          this._os = new OutputStream(this._instance, Protocol.currentProtocolEncoding);\n          this._os.writeBlob(Protocol.replyHdr);\n          this._os.writeInt(this._current.requestId);\n          this._os.writeByte(Protocol.replyUnknownException);\n          this._os.writeString(ex.unknown);\n          this._connection.sendResponse(this._os);\n        } else {\n          this._connection.sendNoResponse();\n        }\n      } else if (ex instanceof Ice.LocalException) {\n        if (props.getPropertyAsIntWithDefault(\"Ice.Warn.Dispatch\", 1) > 0) {\n          this.warning(ex);\n        }\n        if (this._response) {\n          this._os = new OutputStream(this._instance, Protocol.currentProtocolEncoding);\n          this._os.writeBlob(Protocol.replyHdr);\n          this._os.writeInt(this._current.requestId);\n          this._os.writeByte(Protocol.replyUnknownLocalException);\n          // this._os.writeString(ex.toString());\n          var s = [ex.ice_id()];\n          if (ex.stack) {\n            s.push(\"\\n\");\n            s.push(ex.stack);\n          }\n          this._os.writeString(s.join(\"\"));\n          this._connection.sendResponse(this._os);\n        } else {\n          this._connection.sendNoResponse();\n        }\n      } else if (ex instanceof Ice.UserException) {\n        if (this._response) {\n          this._os = new OutputStream(this._instance, Protocol.currentProtocolEncoding);\n          this._os.writeBlob(Protocol.replyHdr);\n          this._os.writeInt(this._current.requestId);\n          this._os.writeByte(Protocol.replyUserException);\n          this._os.startEncapsulation(this._current.encoding, this._format);\n          this._os.writeException(ex);\n          this._os.endEncapsulation();\n          this._connection.sendResponse(this._os);\n        } else {\n          this._connection.sendNoResponse();\n        }\n      } else {\n        if (props.getPropertyAsIntWithDefault(\"Ice.Warn.Dispatch\", 1) > 0) {\n          this.warning(ex);\n        }\n        if (this._response) {\n          this._os = new OutputStream(this._instance, Protocol.currentProtocolEncoding);\n          this._os.writeBlob(Protocol.replyHdr);\n          this._os.writeInt(this._current.requestId);\n          this._os.writeByte(Protocol.replyUnknownException);\n          this._os.writeString(ex.toString() + (ex.stack ? \"\\n\" + ex.stack : \"\"));\n          this._connection.sendResponse(this._os);\n        } else {\n          this._connection.sendNoResponse();\n        }\n      }\n      this._connection = null;\n    }\n  }, {\n    key: \"invoke\",\n    value: function invoke(servantManager, stream) {\n      var _this = this;\n      this._is = stream;\n\n      //\n      // Read the current.\n      //\n      this._current.id._read(this._is);\n\n      //\n      // For compatibility with the old FacetPath.\n      //\n      var facetPath = Ice.StringSeqHelper.read(this._is);\n      if (facetPath.length > 0) {\n        if (facetPath.length > 1) {\n          throw new Ice.MarshalException();\n        }\n        this._current.facet = facetPath[0];\n      } else {\n        this._current.facet = \"\";\n      }\n      this._current.operation = this._is.readString();\n      this._current.mode = Ice.OperationMode.valueOf(this._is.readByte());\n      this._current.ctx = new Context();\n      var sz = this._is.readSize();\n      while (sz-- > 0) {\n        this._current.ctx.set(this._is.readString(), this._is.readString());\n      }\n\n      //\n      // Don't put the code above into the try block below. Exceptions\n      // in the code above are considered fatal, and must propagate to\n      // the caller of this operation.\n      //\n      if (servantManager !== null) {\n        this._servant = servantManager.findServant(this._current.id, this._current.facet);\n        if (this._servant === null) {\n          this._locator = servantManager.findServantLocator(this._current.id.category);\n          if (this._locator === null && this._current.id.category.length > 0) {\n            this._locator = servantManager.findServantLocator(\"\");\n          }\n          if (this._locator !== null) {\n            try {\n              this._servant = this._locator.locate(this._current, this._cookie);\n            } catch (ex) {\n              this.skipReadParams(); // Required for batch requests.\n              this.handleException(ex, false);\n              return;\n            }\n          }\n        }\n      }\n      if (this._servant === null) {\n        try {\n          if (servantManager !== null && servantManager.hasServant(this._current.id)) {\n            throw new Ice.FacetNotExistException(this._current.id, this._current.facet, this._current.operation);\n          } else {\n            throw new Ice.ObjectNotExistException(this._current.id, this._current.facet, this._current.operation);\n          }\n        } catch (ex) {\n          this.skipReadParams(); // Required for batch requests.\n          this.handleException(ex, false);\n          return;\n        }\n      }\n      try {\n        Debug.assert(this._servant !== null);\n        var promise = this._servant._iceDispatch(this, this._current);\n        if (promise !== null) {\n          promise.then(function () {\n            return _this.completed(null, true);\n          }, function (ex) {\n            return _this.completed(ex, true);\n          });\n          return;\n        }\n        Debug.assert(!this._response || this._os !== null);\n        this.completed(null, false);\n      } catch (ex) {\n        this.completed(ex, false);\n      }\n    }\n  }, {\n    key: \"startReadParams\",\n    value: function startReadParams() {\n      //\n      // Remember the encoding used by the input parameters, we'll\n      // encode the response parameters with the same encoding.\n      //\n      this._current.encoding = this._is.startEncapsulation();\n      return this._is;\n    }\n  }, {\n    key: \"endReadParams\",\n    value: function endReadParams() {\n      this._is.endEncapsulation();\n    }\n  }, {\n    key: \"readEmptyParams\",\n    value: function readEmptyParams() {\n      this._current.encoding = this._is.skipEmptyEncapsulation();\n    }\n  }, {\n    key: \"readParamEncaps\",\n    value: function readParamEncaps() {\n      this._current.encoding = new Ice.EncodingVersion();\n      return this._is.readEncapsulation(this._current.encoding);\n    }\n  }, {\n    key: \"skipReadParams\",\n    value: function skipReadParams() {\n      this._current.encoding = this._is.skipEncapsulation();\n    }\n  }, {\n    key: \"completed\",\n    value: function completed(exc, amd) {\n      try {\n        if (this._locator !== null) {\n          Debug.assert(this._locator !== null && this._servant !== null);\n          try {\n            this._locator.finished(this._current, this._servant, this._cookie.value);\n          } catch (ex) {\n            this.handleException(ex, amd);\n            return;\n          }\n        }\n        Debug.assert(this._connection !== null);\n        if (exc !== null) {\n          this.handleException(exc, amd);\n        } else if (this._response) {\n          this._connection.sendResponse(this._os);\n        } else {\n          this._connection.sendNoResponse();\n        }\n      } catch (ex) {\n        if (ex instanceof Ice.LocalException) {\n          this._connection.invokeException(ex, 1);\n        } else {\n          throw ex;\n        }\n      }\n      this._connection = null;\n    }\n  }]);\n}();\nIce.IncomingAsync = IncomingAsync;\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/IncomingAsync.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Initialize.js":
/*!************************************************!*\
  !*** ./node_modules/ice/src/Ice/Initialize.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n__webpack_require__(/*! ../Ice/Communicator */ \"./node_modules/ice/src/Ice/Communicator.js\");\n__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\");\n__webpack_require__(/*! ../Ice/Properties */ \"./node_modules/ice/src/Ice/Properties.js\");\n__webpack_require__(/*! ../Ice/Protocol */ \"./node_modules/ice/src/Ice/Protocol.js\");\nvar Protocol = Ice.Protocol;\n\n//\n// Ice.InitializationData\n//\nIce.InitializationData = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function _class() {\n    _classCallCheck(this, _class);\n    this.properties = null;\n    this.logger = null;\n    this.valueFactoryManager = null;\n  }\n  return _createClass(_class, [{\n    key: \"clone\",\n    value: function clone() {\n      var r = new Ice.InitializationData();\n      r.properties = this.properties;\n      r.logger = this.logger;\n      r.valueFactoryManager = this.valueFactoryManager;\n      return r;\n    }\n  }]);\n}();\n\n//\n// Ice.initialize()\n//\nIce.initialize = function (arg1, arg2) {\n  var args = null;\n  var initData = null;\n  if (arg1 instanceof Array) {\n    args = arg1;\n  } else if (arg1 instanceof Ice.InitializationData) {\n    initData = arg1;\n  } else if (arg1 !== undefined && arg1 !== null) {\n    throw new Ice.InitializationException(\"invalid argument to initialize\");\n  }\n  if (arg2 !== undefined && arg2 !== null) {\n    if (arg2 instanceof Ice.InitializationData && initData === null) {\n      initData = arg2;\n    } else {\n      throw new Ice.InitializationException(\"invalid argument to initialize\");\n    }\n  }\n  if (initData === null) {\n    initData = new Ice.InitializationData();\n  } else {\n    initData = initData.clone();\n  }\n  initData.properties = Ice.createProperties(args, initData.properties);\n  var result = new Ice.Communicator(initData);\n  result.finishSetup(null);\n  return result;\n};\n\n//\n// Ice.createProperties()\n//\nIce.createProperties = function (args, defaults) {\n  return new Ice.Properties(args, defaults);\n};\nIce.currentProtocol = function () {\n  return Protocol.currentProtocol.clone();\n};\nIce.currentEncoding = function () {\n  return Protocol.currentEncoding.clone();\n};\nIce.stringVersion = function () {\n  return \"3.7.10\"; // \"A.B.C\", with A=major, B=minor, C=patch\n};\nIce.intVersion = function () {\n  return 30710; // AABBCC, with AA=major, BB=minor, CC=patch\n};\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/Initialize.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Instance.js":
/*!**********************************************!*\
  !*** ./node_modules/ice/src/Ice/Instance.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n__webpack_require__(/*! ../Ice/ACM */ \"./node_modules/ice/src/Ice/ACM.js\");\n__webpack_require__(/*! ../Ice/AsyncResultBase */ \"./node_modules/ice/src/Ice/AsyncResultBase.js\");\n__webpack_require__(/*! ../Ice/Debug */ \"./node_modules/ice/src/Ice/Debug.js\");\n__webpack_require__(/*! ../Ice/DefaultsAndOverrides */ \"./node_modules/ice/src/Ice/DefaultsAndOverrides.js\");\n__webpack_require__(/*! ../Ice/EndpointFactoryManager */ \"./node_modules/ice/src/Ice/EndpointFactoryManager.js\");\n__webpack_require__(/*! ../Ice/EndpointInfo */ \"./node_modules/ice/src/Ice/EndpointInfo.js\");\n__webpack_require__(/*! ../Ice/Exception */ \"./node_modules/ice/src/Ice/Exception.js\");\n__webpack_require__(/*! ../Ice/IdentityUtil */ \"./node_modules/ice/src/Ice/IdentityUtil.js\");\n__webpack_require__(/*! ../Ice/ImplicitContextI */ \"./node_modules/ice/src/Ice/ImplicitContextI.js\");\n__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\");\n__webpack_require__(/*! ../Ice/LocatorManager */ \"./node_modules/ice/src/Ice/LocatorManager.js\");\n__webpack_require__(/*! ../Ice/ObjectAdapterFactory */ \"./node_modules/ice/src/Ice/ObjectAdapterFactory.js\");\n__webpack_require__(/*! ../Ice/OutgoingConnectionFactory */ \"./node_modules/ice/src/Ice/OutgoingConnectionFactory.js\");\n__webpack_require__(/*! ../Ice/ProcessLogger */ \"./node_modules/ice/src/Ice/ProcessLogger.js\");\n__webpack_require__(/*! ../Ice/Promise */ \"./node_modules/ice/src/Ice/Promise.js\");\n__webpack_require__(/*! ../Ice/Properties */ \"./node_modules/ice/src/Ice/Properties.js\");\n__webpack_require__(/*! ../Ice/ProtocolInstance */ \"./node_modules/ice/src/Ice/ProtocolInstance.js\");\n__webpack_require__(/*! ../Ice/ProxyFactory */ \"./node_modules/ice/src/Ice/ProxyFactory.js\");\n__webpack_require__(/*! ../Ice/Reference */ \"./node_modules/ice/src/Ice/Reference.js\");\n__webpack_require__(/*! ../Ice/RequestHandlerFactory */ \"./node_modules/ice/src/Ice/RequestHandlerFactory.js\");\n__webpack_require__(/*! ../Ice/RetryQueue */ \"./node_modules/ice/src/Ice/RetryQueue.js\");\n__webpack_require__(/*! ../Ice/RouterManager */ \"./node_modules/ice/src/Ice/RouterManager.js\");\n__webpack_require__(/*! ../Ice/TcpEndpointFactory */ \"./node_modules/ice/src/Ice/TcpEndpointFactory.js\");\n__webpack_require__(/*! ../Ice/Timer */ \"./node_modules/ice/src/Ice/Timer.js\");\n__webpack_require__(/*! ../Ice/ToStringMode */ \"./node_modules/ice/src/Ice/ToStringMode.js\");\n__webpack_require__(/*! ../Ice/TraceLevels */ \"./node_modules/ice/src/Ice/TraceLevels.js\");\n__webpack_require__(/*! ../Ice/ValueFactoryManagerI */ \"./node_modules/ice/src/Ice/ValueFactoryManagerI.js\");\n__webpack_require__(/*! ../Ice/WSEndpointFactory */ \"./node_modules/ice/src/Ice/WSEndpointFactory.js\");\nvar ACMConfig = Ice.ACMConfig;\nvar AsyncResultBase = Ice.AsyncResultBase;\nvar Debug = Ice.Debug;\nvar DefaultsAndOverrides = Ice.DefaultsAndOverrides;\nvar EndpointFactoryManager = Ice.EndpointFactoryManager;\nvar ImplicitContextI = Ice.ImplicitContextI;\nvar LocatorManager = Ice.LocatorManager;\nvar ObjectAdapterFactory = Ice.ObjectAdapterFactory;\nvar OutgoingConnectionFactory = Ice.OutgoingConnectionFactory;\nvar Properties = Ice.Properties;\nvar ProxyFactory = Ice.ProxyFactory;\nvar ReferenceFactory = Ice.ReferenceFactory;\nvar RequestHandlerFactory = Ice.RequestHandlerFactory;\nvar RetryQueue = Ice.RetryQueue;\nvar RouterManager = Ice.RouterManager;\nvar Timer = Ice.Timer;\nvar TraceLevels = Ice.TraceLevels;\nvar ValueFactoryManagerI = Ice.ValueFactoryManagerI;\nvar StateActive = 0;\nvar StateDestroyInProgress = 1;\nvar StateDestroyed = 2;\n\n//\n// Instance - only for use by Communicator\n//\nvar Instance = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function Instance(initData) {\n    _classCallCheck(this, Instance);\n    this._state = StateActive;\n    this._initData = initData;\n    this._traceLevels = null;\n    this._defaultsAndOverrides = null;\n    this._messageSizeMax = 0;\n    this._batchAutoFlushSize = 0;\n    this._clientACM = null;\n    this._toStringMode = Ice.ToStringMode.Unicode;\n    this._implicitContext = null;\n    this._routerManager = null;\n    this._locatorManager = null;\n    this._referenceFactory = null;\n    this._requestHandlerFactory = null;\n    this._proxyFactory = null;\n    this._outgoingConnectionFactory = null;\n    this._objectAdapterFactory = null;\n    this._retryQueue = null;\n    this._endpointHostResolver = null;\n    this._endpointFactoryManager = null;\n    this._objectFactoryMap = null;\n  }\n  return _createClass(Instance, [{\n    key: \"initializationData\",\n    value: function initializationData() {\n      //\n      // No check for destruction. It must be possible to access the\n      // initialization data after destruction.\n      //\n      // This value is immutable.\n      //\n      return this._initData;\n    }\n  }, {\n    key: \"traceLevels\",\n    value: function traceLevels() {\n      // This value is immutable.\n      Debug.assert(this._traceLevels !== null);\n      return this._traceLevels;\n    }\n  }, {\n    key: \"defaultsAndOverrides\",\n    value: function defaultsAndOverrides() {\n      // This value is immutable.\n      Debug.assert(this._defaultsAndOverrides !== null);\n      return this._defaultsAndOverrides;\n    }\n  }, {\n    key: \"routerManager\",\n    value: function routerManager() {\n      if (this._state === StateDestroyed) {\n        throw new Ice.CommunicatorDestroyedException();\n      }\n      Debug.assert(this._routerManager !== null);\n      return this._routerManager;\n    }\n  }, {\n    key: \"locatorManager\",\n    value: function locatorManager() {\n      if (this._state === StateDestroyed) {\n        throw new Ice.CommunicatorDestroyedException();\n      }\n      Debug.assert(this._locatorManager !== null);\n      return this._locatorManager;\n    }\n  }, {\n    key: \"referenceFactory\",\n    value: function referenceFactory() {\n      if (this._state === StateDestroyed) {\n        throw new Ice.CommunicatorDestroyedException();\n      }\n      Debug.assert(this._referenceFactory !== null);\n      return this._referenceFactory;\n    }\n  }, {\n    key: \"requestHandlerFactory\",\n    value: function requestHandlerFactory() {\n      if (this._state === StateDestroyed) {\n        throw new Ice.CommunicatorDestroyedException();\n      }\n      Debug.assert(this._requestHandlerFactory !== null);\n      return this._requestHandlerFactory;\n    }\n  }, {\n    key: \"proxyFactory\",\n    value: function proxyFactory() {\n      if (this._state === StateDestroyed) {\n        throw new Ice.CommunicatorDestroyedException();\n      }\n      Debug.assert(this._proxyFactory !== null);\n      return this._proxyFactory;\n    }\n  }, {\n    key: \"outgoingConnectionFactory\",\n    value: function outgoingConnectionFactory() {\n      if (this._state === StateDestroyed) {\n        throw new Ice.CommunicatorDestroyedException();\n      }\n      Debug.assert(this._outgoingConnectionFactory !== null);\n      return this._outgoingConnectionFactory;\n    }\n  }, {\n    key: \"objectAdapterFactory\",\n    value: function objectAdapterFactory() {\n      if (this._state === StateDestroyed) {\n        throw new Ice.CommunicatorDestroyedException();\n      }\n      Debug.assert(this._objectAdapterFactory !== null);\n      return this._objectAdapterFactory;\n    }\n  }, {\n    key: \"retryQueue\",\n    value: function retryQueue() {\n      if (this._state === StateDestroyed) {\n        throw new Ice.CommunicatorDestroyedException();\n      }\n      Debug.assert(this._retryQueue !== null);\n      return this._retryQueue;\n    }\n  }, {\n    key: \"timer\",\n    value: function timer() {\n      if (this._state === StateDestroyed) {\n        throw new Ice.CommunicatorDestroyedException();\n      }\n      Debug.assert(this._timer !== null);\n      return this._timer;\n    }\n  }, {\n    key: \"endpointFactoryManager\",\n    value: function endpointFactoryManager() {\n      if (this._state === StateDestroyed) {\n        throw new Ice.CommunicatorDestroyedException();\n      }\n      Debug.assert(this._endpointFactoryManager !== null);\n      return this._endpointFactoryManager;\n    }\n  }, {\n    key: \"messageSizeMax\",\n    value: function messageSizeMax() {\n      // This value is immutable.\n      return this._messageSizeMax;\n    }\n  }, {\n    key: \"batchAutoFlushSize\",\n    value: function batchAutoFlushSize() {\n      // This value is immutable.\n      return this._batchAutoFlushSize;\n    }\n  }, {\n    key: \"clientACM\",\n    value: function clientACM() {\n      // This value is immutable.\n      return this._clientACM;\n    }\n  }, {\n    key: \"toStringMode\",\n    value: function toStringMode() {\n      // this value is immutable\n      return this._toStringMode;\n    }\n  }, {\n    key: \"getImplicitContext\",\n    value: function getImplicitContext() {\n      return this._implicitContext;\n    }\n  }, {\n    key: \"setDefaultLocator\",\n    value: function setDefaultLocator(locator) {\n      if (this._state == StateDestroyed) {\n        throw new Ice.CommunicatorDestroyedException();\n      }\n      this._referenceFactory = this._referenceFactory.setDefaultLocator(locator);\n    }\n  }, {\n    key: \"setDefaultRouter\",\n    value: function setDefaultRouter(router) {\n      if (this._state == StateDestroyed) {\n        throw new Ice.CommunicatorDestroyedException();\n      }\n      this._referenceFactory = this._referenceFactory.setDefaultRouter(router);\n    }\n  }, {\n    key: \"setLogger\",\n    value: function setLogger(logger) {\n      this._initData.logger = logger;\n    }\n  }, {\n    key: \"finishSetup\",\n    value: function finishSetup(communicator, promise) {\n      //\n      // If promise == null, it means the caller is requesting a synchronous setup.\n      // Otherwise, we resolve the promise after all initialization is complete.\n      //\n      try {\n        if (this._initData.properties === null) {\n          this._initData.properties = Properties.createProperties();\n        }\n        if (Ice._oneOfDone === undefined) {\n          Ice._printStackTraces = this._initData.properties.getPropertyAsIntWithDefault(\"Ice.PrintStackTraces\", 0) > 0;\n          Ice._oneOfDone = true;\n        }\n        if (this._initData.logger === null) {\n          this._initData.logger = Ice.getProcessLogger();\n        }\n        this._traceLevels = new TraceLevels(this._initData.properties);\n        this._defaultsAndOverrides = new DefaultsAndOverrides(this._initData.properties, this._initData.logger);\n        var defMessageSizeMax = 1024;\n        var num = this._initData.properties.getPropertyAsIntWithDefault(\"Ice.MessageSizeMax\", defMessageSizeMax);\n        if (num < 1 || num > 0x7fffffff / 1024) {\n          this._messageSizeMax = 0x7fffffff;\n        } else {\n          this._messageSizeMax = num * 1024; // Property is in kilobytes, _messageSizeMax in bytes\n        }\n        if (this._initData.properties.getProperty(\"Ice.BatchAutoFlushSize\").length === 0 && this._initData.properties.getProperty(\"Ice.BatchAutoFlush\").length > 0) {\n          if (this._initData.properties.getPropertyAsInt(\"Ice.BatchAutoFlush\") > 0) {\n            this._batchAutoFlushSize = this._messageSizeMax;\n          }\n        } else {\n          num = this._initData.properties.getPropertyAsIntWithDefault(\"Ice.BatchAutoFlushSize\", 1024); // 1MB\n          if (num < 1) {\n            this._batchAutoFlushSize = num;\n          } else if (num > 0x7fffffff / 1024) {\n            this._batchAutoFlushSize = 0x7fffffff;\n          } else {\n            this._batchAutoFlushSize = num * 1024; // Property is in kilobytes, _batchAutoFlushSize in bytes\n          }\n        }\n        this._clientACM = new ACMConfig(this._initData.properties, this._initData.logger, \"Ice.ACM.Client\", new ACMConfig(this._initData.properties, this._initData.logger, \"Ice.ACM\", new ACMConfig()));\n        var toStringModeStr = this._initData.properties.getPropertyWithDefault(\"Ice.ToStringMode\", \"Unicode\");\n        if (toStringModeStr === \"ASCII\") {\n          this._toStringMode = Ice.ToStringMode.ASCII;\n        } else if (toStringModeStr === \"Compat\") {\n          this._toStringMode = Ice.ToStringMode.Compat;\n        } else if (toStringModeStr !== \"Unicode\") {\n          throw new Ice.InitializationException(\"The value for Ice.ToStringMode must be Unicode, ASCII or Compat\");\n        }\n        this._implicitContext = ImplicitContextI.create(this._initData.properties.getProperty(\"Ice.ImplicitContext\"));\n        this._routerManager = new RouterManager();\n        this._locatorManager = new LocatorManager(this._initData.properties);\n        this._referenceFactory = new ReferenceFactory(this, communicator);\n        this._requestHandlerFactory = new RequestHandlerFactory(this, communicator);\n        this._proxyFactory = new ProxyFactory(this);\n        this._endpointFactoryManager = new EndpointFactoryManager(this);\n        var tcpInstance = new Ice.ProtocolInstance(this, Ice.TCPEndpointType, \"tcp\", false);\n        var tcpEndpointFactory = new Ice.TcpEndpointFactory(tcpInstance);\n        this._endpointFactoryManager.add(tcpEndpointFactory);\n        var wsInstance = new Ice.ProtocolInstance(this, Ice.WSEndpointType, \"ws\", false);\n        var wsEndpointFactory = new Ice.WSEndpointFactory(wsInstance, tcpEndpointFactory.clone(wsInstance));\n        this._endpointFactoryManager.add(wsEndpointFactory);\n        var sslInstance = new Ice.ProtocolInstance(this, Ice.SSLEndpointType, \"ssl\", true);\n        var sslEndpointFactory = new Ice.TcpEndpointFactory(sslInstance);\n        this._endpointFactoryManager.add(sslEndpointFactory);\n        var wssInstance = new Ice.ProtocolInstance(this, Ice.WSSEndpointType, \"wss\", true);\n        var wssEndpointFactory = new Ice.WSEndpointFactory(wssInstance, sslEndpointFactory.clone(wssInstance));\n        this._endpointFactoryManager.add(wssEndpointFactory);\n        this._outgoingConnectionFactory = new OutgoingConnectionFactory(communicator, this);\n        if (this._initData.valueFactoryManager === null) {\n          this._initData.valueFactoryManager = new ValueFactoryManagerI();\n        }\n        this._objectAdapterFactory = new ObjectAdapterFactory(this, communicator);\n        this._retryQueue = new RetryQueue(this);\n        this._timer = new Timer(this._initData.logger);\n        var router = Ice.RouterPrx.uncheckedCast(this._proxyFactory.propertyToProxy(\"Ice.Default.Router\"));\n        if (router !== null) {\n          this._referenceFactory = this._referenceFactory.setDefaultRouter(router);\n        }\n        var loc = Ice.LocatorPrx.uncheckedCast(this._proxyFactory.propertyToProxy(\"Ice.Default.Locator\"));\n        if (loc !== null) {\n          this._referenceFactory = this._referenceFactory.setDefaultLocator(loc);\n        }\n        if (promise !== null) {\n          promise.resolve(communicator);\n        }\n      } catch (ex) {\n        if (promise !== null) {\n          if (ex instanceof Ice.LocalException) {\n            this.destroy()[\"finally\"](function () {\n              return promise.reject(ex);\n            });\n          } else {\n            promise.reject(ex);\n          }\n        } else {\n          if (ex instanceof Ice.LocalException) {\n            this.destroy();\n          }\n          throw ex;\n        }\n      }\n    }\n\n    //\n    // Only for use by Ice.CommunicatorI\n    //\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var _this = this;\n      var promise = new AsyncResultBase(null, \"destroy\", null, this, null);\n\n      //\n      // If destroy is in progress, wait for it to be done. This is\n      // necessary in case destroy() is called concurrently by\n      // multiple threads.\n      //\n      if (this._state == StateDestroyInProgress) {\n        if (!this._destroyPromises) {\n          this._destroyPromises = [];\n        }\n        this._destroyPromises.push(promise);\n        return promise;\n      }\n      this._state = StateDestroyInProgress;\n\n      //\n      // Shutdown and destroy all the incoming and outgoing Ice\n      // connections and wait for the connections to be finished.\n      //\n      Ice.Promise[\"try\"](function () {\n        if (_this._objectAdapterFactory) {\n          return _this._objectAdapterFactory.shutdown();\n        }\n      }).then(function () {\n        if (_this._outgoingConnectionFactory !== null) {\n          _this._outgoingConnectionFactory.destroy();\n        }\n        if (_this._objectAdapterFactory !== null) {\n          return _this._objectAdapterFactory.destroy();\n        }\n      }).then(function () {\n        if (_this._outgoingConnectionFactory !== null) {\n          return _this._outgoingConnectionFactory.waitUntilFinished();\n        }\n      }).then(function () {\n        if (_this._retryQueue) {\n          _this._retryQueue.destroy();\n        }\n        if (_this._timer) {\n          _this._timer.destroy();\n        }\n        if (_this._objectFactoryMap !== null) {\n          _this._objectFactoryMap.forEach(function (factory) {\n            return factory.destroy();\n          });\n          _this._objectFactoryMap.clear();\n        }\n        if (_this._routerManager) {\n          _this._routerManager.destroy();\n        }\n        if (_this._locatorManager) {\n          _this._locatorManager.destroy();\n        }\n        if (_this._endpointFactoryManager) {\n          _this._endpointFactoryManager.destroy();\n        }\n        if (_this._initData.properties.getPropertyAsInt(\"Ice.Warn.UnusedProperties\") > 0) {\n          var unusedProperties = _this._initData.properties.getUnusedProperties();\n          if (unusedProperties.length > 0) {\n            var message = [];\n            message.push(\"The following properties were set but never read:\");\n            unusedProperties.forEach(function (p) {\n              return message.push(\"\\n    \", p);\n            });\n            _this._initData.logger.warning(message.join(\"\"));\n          }\n        }\n        _this._objectAdapterFactory = null;\n        _this._outgoingConnectionFactory = null;\n        _this._retryQueue = null;\n        _this._timer = null;\n        _this._referenceFactory = null;\n        _this._requestHandlerFactory = null;\n        _this._proxyFactory = null;\n        _this._routerManager = null;\n        _this._locatorManager = null;\n        _this._endpointFactoryManager = null;\n        _this._state = StateDestroyed;\n        if (_this._destroyPromises) {\n          _this._destroyPromises.forEach(function (p) {\n            return p.resolve();\n          });\n        }\n        promise.resolve();\n      })[\"catch\"](function (ex) {\n        if (_this._destroyPromises) {\n          _this._destroyPromises.forEach(function (p) {\n            return p.reject(ex);\n          });\n        }\n        promise.reject(ex);\n      });\n      return promise;\n    }\n  }, {\n    key: \"addObjectFactory\",\n    value: function addObjectFactory(factory, id) {\n      //\n      // Create a ValueFactory wrapper around the given ObjectFactory and register the wrapper\n      // with the value factory manager. This may raise AlreadyRegisteredException.\n      //\n      this._initData.valueFactoryManager.add(function (typeId) {\n        return factory.create(typeId);\n      }, id);\n      if (this._objectFactoryMap === null) {\n        this._objectFactoryMap = new Map();\n      }\n      this._objectFactoryMap.set(id, factory);\n    }\n  }, {\n    key: \"findObjectFactory\",\n    value: function findObjectFactory(id) {\n      var factory = null;\n      if (this._objectFactoryMap !== null) {\n        factory = this._objectFactoryMap.get(id);\n      }\n      return factory !== undefined ? factory : null;\n    }\n  }]);\n}();\nIce.Instance = Instance;\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/Instance.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/InstrumentationF.js":
/*!******************************************************!*\
  !*** ./node_modules/ice/src/Ice/InstrumentationF.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `InstrumentationF.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nvar _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\nvar Ice = _ModuleRegistry.module(\"Ice\");\nvar Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n/* slice2js browser-bundle-skip */\n\nIce.Instrumentation = _ModuleRegistry.module(\"Ice.Instrumentation\");\n/* slice2js browser-bundle-skip-end */\n/* slice2js browser-bundle-skip */\nexports.Ice = Ice;\n/* slice2js browser-bundle-skip-end */\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/InstrumentationF.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/LocalException.js":
/*!****************************************************!*\
  !*** ./node_modules/ice/src/Ice/LocalException.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `LocalException.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nvar _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Exception */ \"./node_modules/ice/src/Ice/Exception.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\n__webpack_require__(/*! ../Ice/Identity */ \"./node_modules/ice/src/Ice/Identity.js\");\n__webpack_require__(/*! ../Ice/Version */ \"./node_modules/ice/src/Ice/Version.js\");\n__webpack_require__(/*! ../Ice/BuiltinSequences */ \"./node_modules/ice/src/Ice/BuiltinSequences.js\");\nvar Ice = _ModuleRegistry.module(\"Ice\");\nvar Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n\n/**\n * This exception is raised when a failure occurs during initialization.\n *\n **/\nIce.InitializationException = /*#__PURE__*/function (_Ice$LocalException) {\n  \"use strict\";\n\n  function _class() {\n    var _this;\n    var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class);\n    _this = _callSuper(this, _class, [_cause]);\n    _this.reason = reason;\n    return _this;\n  }\n  _inherits(_class, _Ice$LocalException);\n  return _createClass(_class, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.LocalException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::InitializationException\";\n    }\n  }]);\n}(Ice.LocalException);\n\n/**\n * This exception indicates that a failure occurred while initializing\n * a plug-in.\n *\n **/\nIce.PluginInitializationException = /*#__PURE__*/function (_Ice$LocalException2) {\n  \"use strict\";\n\n  function _class2() {\n    var _this2;\n    var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class2);\n    _this2 = _callSuper(this, _class2, [_cause]);\n    _this2.reason = reason;\n    return _this2;\n  }\n  _inherits(_class2, _Ice$LocalException2);\n  return _createClass(_class2, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.LocalException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::PluginInitializationException\";\n    }\n  }]);\n}(Ice.LocalException);\n\n/**\n * This exception is raised if a feature is requested that is not\n * supported with collocation optimization.\n *\n * @deprecated This exception is no longer used by the Ice run time\n **/\nIce.CollocationOptimizationException = /*#__PURE__*/function (_Ice$LocalException3) {\n  \"use strict\";\n\n  function _class3() {\n    var _cause = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    _classCallCheck(this, _class3);\n    return _callSuper(this, _class3, [_cause]);\n  }\n  _inherits(_class3, _Ice$LocalException3);\n  return _createClass(_class3, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.LocalException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::CollocationOptimizationException\";\n    }\n  }]);\n}(Ice.LocalException);\n\n/**\n * An attempt was made to register something more than once with\n * the Ice run time.\n *\n * This exception is raised if an attempt is made to register a\n * servant, servant locator, facet, value factory, plug-in, object\n * adapter, object, or user exception factory more than once for the\n * same ID.\n *\n **/\nIce.AlreadyRegisteredException = /*#__PURE__*/function (_Ice$LocalException4) {\n  \"use strict\";\n\n  function _class4() {\n    var _this3;\n    var kindOfObject = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    var _cause = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n    _classCallCheck(this, _class4);\n    _this3 = _callSuper(this, _class4, [_cause]);\n    _this3.kindOfObject = kindOfObject;\n    _this3.id = id;\n    return _this3;\n  }\n  _inherits(_class4, _Ice$LocalException4);\n  return _createClass(_class4, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.LocalException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::AlreadyRegisteredException\";\n    }\n  }]);\n}(Ice.LocalException);\n\n/**\n * An attempt was made to find or deregister something that is not\n * registered with the Ice run time or Ice locator.\n *\n * This exception is raised if an attempt is made to remove a servant,\n * servant locator, facet, value factory, plug-in, object adapter,\n * object, or user exception factory that is not currently registered.\n *\n * It's also raised if the Ice locator can't find an object or object\n * adapter when resolving an indirect proxy or when an object adapter\n * is activated.\n *\n **/\nIce.NotRegisteredException = /*#__PURE__*/function (_Ice$LocalException5) {\n  \"use strict\";\n\n  function _class5() {\n    var _this4;\n    var kindOfObject = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    var _cause = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n    _classCallCheck(this, _class5);\n    _this4 = _callSuper(this, _class5, [_cause]);\n    _this4.kindOfObject = kindOfObject;\n    _this4.id = id;\n    return _this4;\n  }\n  _inherits(_class5, _Ice$LocalException5);\n  return _createClass(_class5, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.LocalException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::NotRegisteredException\";\n    }\n  }]);\n}(Ice.LocalException);\n\n/**\n * The operation can only be invoked with a twoway request.\n *\n * This exception is raised if an attempt is made to invoke an\n * operation with <code>ice_oneway</code>, <code>ice_batchOneway</code>, <code>ice_datagram</code>,\n * or <code>ice_batchDatagram</code> and the operation has a return value,\n * out-parameters, or an exception specification.\n *\n **/\nIce.TwowayOnlyException = /*#__PURE__*/function (_Ice$LocalException6) {\n  \"use strict\";\n\n  function _class6() {\n    var _this5;\n    var operation = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class6);\n    _this5 = _callSuper(this, _class6, [_cause]);\n    _this5.operation = operation;\n    return _this5;\n  }\n  _inherits(_class6, _Ice$LocalException6);\n  return _createClass(_class6, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.LocalException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::TwowayOnlyException\";\n    }\n  }]);\n}(Ice.LocalException);\n\n/**\n * An attempt was made to clone a class that does not support\n * cloning.\n *\n * This exception is raised if <code>ice_clone</code> is called on\n * a class that is derived from an abstract Slice class (that is,\n * a class containing operations), and the derived class does not\n * provide an implementation of the <code>ice_clone</code> operation (C++ only).\n *\n **/\nIce.CloneNotImplementedException = /*#__PURE__*/function (_Ice$LocalException7) {\n  \"use strict\";\n\n  function _class7() {\n    var _cause = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    _classCallCheck(this, _class7);\n    return _callSuper(this, _class7, [_cause]);\n  }\n  _inherits(_class7, _Ice$LocalException7);\n  return _createClass(_class7, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.LocalException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::CloneNotImplementedException\";\n    }\n  }]);\n}(Ice.LocalException);\n\n/**\n * This exception is raised if an operation call on a server raises an\n * unknown exception. For example, for C++, this exception is raised\n * if the server throws a C++ exception that is not directly or\n * indirectly derived from <code>Ice::LocalException</code> or\n * <code>Ice::UserException</code>.\n *\n **/\nIce.UnknownException = /*#__PURE__*/function (_Ice$LocalException8) {\n  \"use strict\";\n\n  function _class8() {\n    var _this6;\n    var unknown = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class8);\n    _this6 = _callSuper(this, _class8, [_cause]);\n    _this6.unknown = unknown;\n    return _this6;\n  }\n  _inherits(_class8, _Ice$LocalException8);\n  return _createClass(_class8, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.LocalException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::UnknownException\";\n    }\n  }]);\n}(Ice.LocalException);\n\n/**\n * This exception is raised if an operation call on a server raises a\n * local exception. Because local exceptions are not transmitted by\n * the Ice protocol, the client receives all local exceptions raised\n * by the server as {@link UnknownLocalException}. The only exception to this\n * rule are all exceptions derived from {@link RequestFailedException},\n * which are transmitted by the Ice protocol even though they are\n * declared <code>local</code>.\n *\n **/\nIce.UnknownLocalException = /*#__PURE__*/function (_Ice$UnknownException) {\n  \"use strict\";\n\n  function _class9(unknown) {\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class9);\n    return _callSuper(this, _class9, [unknown, _cause]);\n  }\n  _inherits(_class9, _Ice$UnknownException);\n  return _createClass(_class9, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.UnknownException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::UnknownLocalException\";\n    }\n  }]);\n}(Ice.UnknownException);\n\n/**\n * An operation raised an incorrect user exception.\n *\n * This exception is raised if an operation raises a\n * user exception that is not declared in the exception's\n * <code>throws</code> clause. Such undeclared exceptions are\n * not transmitted from the server to the client by the Ice\n * protocol, but instead the client just gets an\n * {@link UnknownUserException}. This is necessary in order to not violate\n * the contract established by an operation's signature: Only local\n * exceptions and user exceptions declared in the\n * <code>throws</code> clause can be raised.\n *\n **/\nIce.UnknownUserException = /*#__PURE__*/function (_Ice$UnknownException2) {\n  \"use strict\";\n\n  function _class0(unknown) {\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class0);\n    return _callSuper(this, _class0, [unknown, _cause]);\n  }\n  _inherits(_class0, _Ice$UnknownException2);\n  return _createClass(_class0, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.UnknownException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::UnknownUserException\";\n    }\n  }]);\n}(Ice.UnknownException);\n\n/**\n * This exception is raised if the Ice library version does not match\n * the version in the Ice header files.\n *\n **/\nIce.VersionMismatchException = /*#__PURE__*/function (_Ice$LocalException9) {\n  \"use strict\";\n\n  function _class1() {\n    var _cause = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    _classCallCheck(this, _class1);\n    return _callSuper(this, _class1, [_cause]);\n  }\n  _inherits(_class1, _Ice$LocalException9);\n  return _createClass(_class1, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.LocalException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::VersionMismatchException\";\n    }\n  }]);\n}(Ice.LocalException);\n\n/**\n * This exception is raised if the {@link Communicator} has been destroyed.\n *\n * @see Communicator#destroy\n *\n **/\nIce.CommunicatorDestroyedException = /*#__PURE__*/function (_Ice$LocalException0) {\n  \"use strict\";\n\n  function _class10() {\n    var _cause = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    _classCallCheck(this, _class10);\n    return _callSuper(this, _class10, [_cause]);\n  }\n  _inherits(_class10, _Ice$LocalException0);\n  return _createClass(_class10, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.LocalException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::CommunicatorDestroyedException\";\n    }\n  }]);\n}(Ice.LocalException);\n\n/**\n * This exception is raised if an attempt is made to use a deactivated\n * {@link ObjectAdapter}.\n *\n * @see ObjectAdapter#deactivate\n * @see Communicator#shutdown\n *\n **/\nIce.ObjectAdapterDeactivatedException = /*#__PURE__*/function (_Ice$LocalException1) {\n  \"use strict\";\n\n  function _class11() {\n    var _this7;\n    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class11);\n    _this7 = _callSuper(this, _class11, [_cause]);\n    _this7.name = name;\n    return _this7;\n  }\n  _inherits(_class11, _Ice$LocalException1);\n  return _createClass(_class11, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.LocalException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::ObjectAdapterDeactivatedException\";\n    }\n  }]);\n}(Ice.LocalException);\n\n/**\n * This exception is raised if an {@link ObjectAdapter} cannot be activated.\n *\n * This happens if the {@link Locator} detects another active {@link ObjectAdapter} with\n * the same adapter id.\n *\n **/\nIce.ObjectAdapterIdInUseException = /*#__PURE__*/function (_Ice$LocalException10) {\n  \"use strict\";\n\n  function _class12() {\n    var _this8;\n    var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class12);\n    _this8 = _callSuper(this, _class12, [_cause]);\n    _this8.id = id;\n    return _this8;\n  }\n  _inherits(_class12, _Ice$LocalException10);\n  return _createClass(_class12, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.LocalException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::ObjectAdapterIdInUseException\";\n    }\n  }]);\n}(Ice.LocalException);\n\n/**\n * This exception is raised if no suitable endpoint is available.\n *\n **/\nIce.NoEndpointException = /*#__PURE__*/function (_Ice$LocalException11) {\n  \"use strict\";\n\n  function _class13() {\n    var _this9;\n    var proxy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class13);\n    _this9 = _callSuper(this, _class13, [_cause]);\n    _this9.proxy = proxy;\n    return _this9;\n  }\n  _inherits(_class13, _Ice$LocalException11);\n  return _createClass(_class13, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.LocalException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::NoEndpointException\";\n    }\n  }]);\n}(Ice.LocalException);\n\n/**\n * This exception is raised if there was an error while parsing an\n * endpoint.\n *\n **/\nIce.EndpointParseException = /*#__PURE__*/function (_Ice$LocalException12) {\n  \"use strict\";\n\n  function _class14() {\n    var _this0;\n    var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class14);\n    _this0 = _callSuper(this, _class14, [_cause]);\n    _this0.str = str;\n    return _this0;\n  }\n  _inherits(_class14, _Ice$LocalException12);\n  return _createClass(_class14, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.LocalException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::EndpointParseException\";\n    }\n  }]);\n}(Ice.LocalException);\n\n/**\n * This exception is raised if there was an error while parsing an\n * endpoint selection type.\n *\n **/\nIce.EndpointSelectionTypeParseException = /*#__PURE__*/function (_Ice$LocalException13) {\n  \"use strict\";\n\n  function _class15() {\n    var _this1;\n    var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class15);\n    _this1 = _callSuper(this, _class15, [_cause]);\n    _this1.str = str;\n    return _this1;\n  }\n  _inherits(_class15, _Ice$LocalException13);\n  return _createClass(_class15, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.LocalException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::EndpointSelectionTypeParseException\";\n    }\n  }]);\n}(Ice.LocalException);\n\n/**\n * This exception is raised if there was an error while parsing a\n * version.\n *\n **/\nIce.VersionParseException = /*#__PURE__*/function (_Ice$LocalException14) {\n  \"use strict\";\n\n  function _class16() {\n    var _this10;\n    var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class16);\n    _this10 = _callSuper(this, _class16, [_cause]);\n    _this10.str = str;\n    return _this10;\n  }\n  _inherits(_class16, _Ice$LocalException14);\n  return _createClass(_class16, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.LocalException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::VersionParseException\";\n    }\n  }]);\n}(Ice.LocalException);\n\n/**\n * This exception is raised if there was an error while parsing a\n * stringified identity.\n *\n **/\nIce.IdentityParseException = /*#__PURE__*/function (_Ice$LocalException15) {\n  \"use strict\";\n\n  function _class17() {\n    var _this11;\n    var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class17);\n    _this11 = _callSuper(this, _class17, [_cause]);\n    _this11.str = str;\n    return _this11;\n  }\n  _inherits(_class17, _Ice$LocalException15);\n  return _createClass(_class17, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.LocalException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::IdentityParseException\";\n    }\n  }]);\n}(Ice.LocalException);\n\n/**\n * This exception is raised if there was an error while parsing a\n * stringified proxy.\n *\n **/\nIce.ProxyParseException = /*#__PURE__*/function (_Ice$LocalException16) {\n  \"use strict\";\n\n  function _class18() {\n    var _this12;\n    var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class18);\n    _this12 = _callSuper(this, _class18, [_cause]);\n    _this12.str = str;\n    return _this12;\n  }\n  _inherits(_class18, _Ice$LocalException16);\n  return _createClass(_class18, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.LocalException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::ProxyParseException\";\n    }\n  }]);\n}(Ice.LocalException);\n\n/**\n * This exception is raised if an illegal identity is encountered.\n *\n **/\nIce.IllegalIdentityException = /*#__PURE__*/function (_Ice$LocalException17) {\n  \"use strict\";\n\n  function _class19() {\n    var _this13;\n    var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Ice.Identity();\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class19);\n    _this13 = _callSuper(this, _class19, [_cause]);\n    _this13.id = id;\n    return _this13;\n  }\n  _inherits(_class19, _Ice$LocalException17);\n  return _createClass(_class19, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.LocalException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::IllegalIdentityException\";\n    }\n  }]);\n}(Ice.LocalException);\n\n/**\n * This exception is raised to reject an illegal servant (typically\n * a null servant)\n *\n **/\nIce.IllegalServantException = /*#__PURE__*/function (_Ice$LocalException18) {\n  \"use strict\";\n\n  function _class20() {\n    var _this14;\n    var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class20);\n    _this14 = _callSuper(this, _class20, [_cause]);\n    _this14.reason = reason;\n    return _this14;\n  }\n  _inherits(_class20, _Ice$LocalException18);\n  return _createClass(_class20, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.LocalException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::IllegalServantException\";\n    }\n  }]);\n}(Ice.LocalException);\n\n/**\n * This exception is raised if a request failed. This exception, and\n * all exceptions derived from {@link RequestFailedException}, are\n * transmitted by the Ice protocol, even though they are declared\n * <code>local</code>.\n *\n **/\nIce.RequestFailedException = /*#__PURE__*/function (_Ice$LocalException19) {\n  \"use strict\";\n\n  function _class21() {\n    var _this15;\n    var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Ice.Identity();\n    var facet = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    var operation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n    var _cause = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"\";\n    _classCallCheck(this, _class21);\n    _this15 = _callSuper(this, _class21, [_cause]);\n    _this15.id = id;\n    _this15.facet = facet;\n    _this15.operation = operation;\n    return _this15;\n  }\n  _inherits(_class21, _Ice$LocalException19);\n  return _createClass(_class21, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.LocalException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::RequestFailedException\";\n    }\n  }]);\n}(Ice.LocalException);\n\n/**\n * This exception is raised if an object does not exist on the server,\n * that is, if no facets with the given identity exist.\n *\n **/\nIce.ObjectNotExistException = /*#__PURE__*/function (_Ice$RequestFailedExc) {\n  \"use strict\";\n\n  function _class22(id, facet, operation) {\n    var _cause = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"\";\n    _classCallCheck(this, _class22);\n    return _callSuper(this, _class22, [id, facet, operation, _cause]);\n  }\n  _inherits(_class22, _Ice$RequestFailedExc);\n  return _createClass(_class22, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.RequestFailedException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::ObjectNotExistException\";\n    }\n  }]);\n}(Ice.RequestFailedException);\n\n/**\n * This exception is raised if no facet with the given name exists,\n * but at least one facet with the given identity exists.\n *\n **/\nIce.FacetNotExistException = /*#__PURE__*/function (_Ice$RequestFailedExc2) {\n  \"use strict\";\n\n  function _class23(id, facet, operation) {\n    var _cause = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"\";\n    _classCallCheck(this, _class23);\n    return _callSuper(this, _class23, [id, facet, operation, _cause]);\n  }\n  _inherits(_class23, _Ice$RequestFailedExc2);\n  return _createClass(_class23, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.RequestFailedException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::FacetNotExistException\";\n    }\n  }]);\n}(Ice.RequestFailedException);\n\n/**\n * This exception is raised if an operation for a given object does\n * not exist on the server. Typically this is caused by either the\n * client or the server using an outdated Slice specification.\n *\n **/\nIce.OperationNotExistException = /*#__PURE__*/function (_Ice$RequestFailedExc3) {\n  \"use strict\";\n\n  function _class24(id, facet, operation) {\n    var _cause = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"\";\n    _classCallCheck(this, _class24);\n    return _callSuper(this, _class24, [id, facet, operation, _cause]);\n  }\n  _inherits(_class24, _Ice$RequestFailedExc3);\n  return _createClass(_class24, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.RequestFailedException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::OperationNotExistException\";\n    }\n  }]);\n}(Ice.RequestFailedException);\n\n/**\n * This exception is raised if a system error occurred in the server\n * or client process. There are many possible causes for such a system\n * exception. For details on the cause, {@link SyscallException#error}\n * should be inspected.\n *\n **/\nIce.SyscallException = /*#__PURE__*/function (_Ice$LocalException20) {\n  \"use strict\";\n\n  function _class25() {\n    var _this16;\n    var error = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class25);\n    _this16 = _callSuper(this, _class25, [_cause]);\n    _this16.error = error;\n    return _this16;\n  }\n  _inherits(_class25, _Ice$LocalException20);\n  return _createClass(_class25, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.LocalException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::SyscallException\";\n    }\n  }]);\n}(Ice.LocalException);\n\n/**\n * This exception indicates socket errors.\n *\n **/\nIce.SocketException = /*#__PURE__*/function (_Ice$SyscallException) {\n  \"use strict\";\n\n  function _class26(error) {\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class26);\n    return _callSuper(this, _class26, [error, _cause]);\n  }\n  _inherits(_class26, _Ice$SyscallException);\n  return _createClass(_class26, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.SyscallException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::SocketException\";\n    }\n  }]);\n}(Ice.SyscallException);\n\n/**\n * This exception indicates CFNetwork errors.\n *\n **/\nIce.CFNetworkException = /*#__PURE__*/function (_Ice$SocketException) {\n  \"use strict\";\n\n  function _class27(error) {\n    var _this17;\n    var domain = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    var _cause = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n    _classCallCheck(this, _class27);\n    _this17 = _callSuper(this, _class27, [error, _cause]);\n    _this17.domain = domain;\n    return _this17;\n  }\n  _inherits(_class27, _Ice$SocketException);\n  return _createClass(_class27, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.SocketException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::CFNetworkException\";\n    }\n  }]);\n}(Ice.SocketException);\n\n/**\n * This exception indicates file errors.\n *\n **/\nIce.FileException = /*#__PURE__*/function (_Ice$SyscallException2) {\n  \"use strict\";\n\n  function _class28(error) {\n    var _this18;\n    var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    var _cause = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n    _classCallCheck(this, _class28);\n    _this18 = _callSuper(this, _class28, [error, _cause]);\n    _this18.path = path;\n    return _this18;\n  }\n  _inherits(_class28, _Ice$SyscallException2);\n  return _createClass(_class28, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.SyscallException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::FileException\";\n    }\n  }]);\n}(Ice.SyscallException);\n\n/**\n * This exception indicates connection failures.\n *\n **/\nIce.ConnectFailedException = /*#__PURE__*/function (_Ice$SocketException2) {\n  \"use strict\";\n\n  function _class29(error) {\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class29);\n    return _callSuper(this, _class29, [error, _cause]);\n  }\n  _inherits(_class29, _Ice$SocketException2);\n  return _createClass(_class29, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.SocketException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::ConnectFailedException\";\n    }\n  }]);\n}(Ice.SocketException);\n\n/**\n * This exception indicates a connection failure for which\n * the server host actively refuses a connection.\n *\n **/\nIce.ConnectionRefusedException = /*#__PURE__*/function (_Ice$ConnectFailedExc) {\n  \"use strict\";\n\n  function _class30(error) {\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class30);\n    return _callSuper(this, _class30, [error, _cause]);\n  }\n  _inherits(_class30, _Ice$ConnectFailedExc);\n  return _createClass(_class30, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.ConnectFailedException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::ConnectionRefusedException\";\n    }\n  }]);\n}(Ice.ConnectFailedException);\n\n/**\n * This exception indicates a lost connection.\n *\n **/\nIce.ConnectionLostException = /*#__PURE__*/function (_Ice$SocketException3) {\n  \"use strict\";\n\n  function _class31(error) {\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class31);\n    return _callSuper(this, _class31, [error, _cause]);\n  }\n  _inherits(_class31, _Ice$SocketException3);\n  return _createClass(_class31, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.SocketException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::ConnectionLostException\";\n    }\n  }]);\n}(Ice.SocketException);\n\n/**\n * This exception indicates a DNS problem. For details on the cause,\n * {@link DNSException#error} should be inspected.\n *\n **/\nIce.DNSException = /*#__PURE__*/function (_Ice$LocalException21) {\n  \"use strict\";\n\n  function _class32() {\n    var _this19;\n    var error = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var host = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    var _cause = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n    _classCallCheck(this, _class32);\n    _this19 = _callSuper(this, _class32, [_cause]);\n    _this19.error = error;\n    _this19.host = host;\n    return _this19;\n  }\n  _inherits(_class32, _Ice$LocalException21);\n  return _createClass(_class32, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.LocalException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::DNSException\";\n    }\n  }]);\n}(Ice.LocalException);\n\n/**\n * This exception indicates a request was interrupted.\n *\n **/\nIce.OperationInterruptedException = /*#__PURE__*/function (_Ice$LocalException22) {\n  \"use strict\";\n\n  function _class33() {\n    var _cause = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    _classCallCheck(this, _class33);\n    return _callSuper(this, _class33, [_cause]);\n  }\n  _inherits(_class33, _Ice$LocalException22);\n  return _createClass(_class33, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.LocalException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::OperationInterruptedException\";\n    }\n  }]);\n}(Ice.LocalException);\n\n/**\n * This exception indicates a timeout condition.\n *\n **/\nIce.TimeoutException = /*#__PURE__*/function (_Ice$LocalException23) {\n  \"use strict\";\n\n  function _class34() {\n    var _cause = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    _classCallCheck(this, _class34);\n    return _callSuper(this, _class34, [_cause]);\n  }\n  _inherits(_class34, _Ice$LocalException23);\n  return _createClass(_class34, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.LocalException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::TimeoutException\";\n    }\n  }]);\n}(Ice.LocalException);\n\n/**\n * This exception indicates a connection establishment timeout condition.\n *\n **/\nIce.ConnectTimeoutException = /*#__PURE__*/function (_Ice$TimeoutException) {\n  \"use strict\";\n\n  function _class35() {\n    var _cause = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    _classCallCheck(this, _class35);\n    return _callSuper(this, _class35, [_cause]);\n  }\n  _inherits(_class35, _Ice$TimeoutException);\n  return _createClass(_class35, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.TimeoutException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::ConnectTimeoutException\";\n    }\n  }]);\n}(Ice.TimeoutException);\n\n/**\n * This exception indicates a connection closure timeout condition.\n *\n **/\nIce.CloseTimeoutException = /*#__PURE__*/function (_Ice$TimeoutException2) {\n  \"use strict\";\n\n  function _class36() {\n    var _cause = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    _classCallCheck(this, _class36);\n    return _callSuper(this, _class36, [_cause]);\n  }\n  _inherits(_class36, _Ice$TimeoutException2);\n  return _createClass(_class36, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.TimeoutException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::CloseTimeoutException\";\n    }\n  }]);\n}(Ice.TimeoutException);\n\n/**\n * This exception indicates that a connection has been shut down because it has been\n * idle for some time.\n *\n **/\nIce.ConnectionTimeoutException = /*#__PURE__*/function (_Ice$TimeoutException3) {\n  \"use strict\";\n\n  function _class37() {\n    var _cause = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    _classCallCheck(this, _class37);\n    return _callSuper(this, _class37, [_cause]);\n  }\n  _inherits(_class37, _Ice$TimeoutException3);\n  return _createClass(_class37, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.TimeoutException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::ConnectionTimeoutException\";\n    }\n  }]);\n}(Ice.TimeoutException);\n\n/**\n * This exception indicates that an invocation failed because it timed\n * out.\n *\n **/\nIce.InvocationTimeoutException = /*#__PURE__*/function (_Ice$TimeoutException4) {\n  \"use strict\";\n\n  function _class38() {\n    var _cause = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    _classCallCheck(this, _class38);\n    return _callSuper(this, _class38, [_cause]);\n  }\n  _inherits(_class38, _Ice$TimeoutException4);\n  return _createClass(_class38, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.TimeoutException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::InvocationTimeoutException\";\n    }\n  }]);\n}(Ice.TimeoutException);\n\n/**\n * This exception indicates that an asynchronous invocation failed\n * because it was canceled explicitly by the user.\n *\n **/\nIce.InvocationCanceledException = /*#__PURE__*/function (_Ice$LocalException24) {\n  \"use strict\";\n\n  function _class39() {\n    var _cause = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    _classCallCheck(this, _class39);\n    return _callSuper(this, _class39, [_cause]);\n  }\n  _inherits(_class39, _Ice$LocalException24);\n  return _createClass(_class39, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.LocalException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::InvocationCanceledException\";\n    }\n  }]);\n}(Ice.LocalException);\n\n/**\n * A generic exception base for all kinds of protocol error\n * conditions.\n *\n **/\nIce.ProtocolException = /*#__PURE__*/function (_Ice$LocalException25) {\n  \"use strict\";\n\n  function _class40() {\n    var _this20;\n    var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class40);\n    _this20 = _callSuper(this, _class40, [_cause]);\n    _this20.reason = reason;\n    return _this20;\n  }\n  _inherits(_class40, _Ice$LocalException25);\n  return _createClass(_class40, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.LocalException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::ProtocolException\";\n    }\n  }]);\n}(Ice.LocalException);\n\n/**\n * This exception indicates that a message did not start with the expected\n * magic number ('I', 'c', 'e', 'P').\n *\n **/\nIce.BadMagicException = /*#__PURE__*/function (_Ice$ProtocolExceptio) {\n  \"use strict\";\n\n  function _class41(reason) {\n    var _this21;\n    var badMagic = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var _cause = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n    _classCallCheck(this, _class41);\n    _this21 = _callSuper(this, _class41, [reason, _cause]);\n    _this21.badMagic = badMagic;\n    return _this21;\n  }\n  _inherits(_class41, _Ice$ProtocolExceptio);\n  return _createClass(_class41, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.ProtocolException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::BadMagicException\";\n    }\n  }]);\n}(Ice.ProtocolException);\n\n/**\n * This exception indicates an unsupported protocol version.\n *\n **/\nIce.UnsupportedProtocolException = /*#__PURE__*/function (_Ice$ProtocolExceptio2) {\n  \"use strict\";\n\n  function _class42(reason) {\n    var _this22;\n    var bad = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Ice.ProtocolVersion();\n    var supported = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Ice.ProtocolVersion();\n    var _cause = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"\";\n    _classCallCheck(this, _class42);\n    _this22 = _callSuper(this, _class42, [reason, _cause]);\n    _this22.bad = bad;\n    _this22.supported = supported;\n    return _this22;\n  }\n  _inherits(_class42, _Ice$ProtocolExceptio2);\n  return _createClass(_class42, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.ProtocolException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::UnsupportedProtocolException\";\n    }\n  }]);\n}(Ice.ProtocolException);\n\n/**\n * This exception indicates an unsupported data encoding version.\n *\n **/\nIce.UnsupportedEncodingException = /*#__PURE__*/function (_Ice$ProtocolExceptio3) {\n  \"use strict\";\n\n  function _class43(reason) {\n    var _this23;\n    var bad = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Ice.EncodingVersion();\n    var supported = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Ice.EncodingVersion();\n    var _cause = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"\";\n    _classCallCheck(this, _class43);\n    _this23 = _callSuper(this, _class43, [reason, _cause]);\n    _this23.bad = bad;\n    _this23.supported = supported;\n    return _this23;\n  }\n  _inherits(_class43, _Ice$ProtocolExceptio3);\n  return _createClass(_class43, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.ProtocolException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::UnsupportedEncodingException\";\n    }\n  }]);\n}(Ice.ProtocolException);\n\n/**\n * This exception indicates that an unknown protocol message has been received.\n *\n **/\nIce.UnknownMessageException = /*#__PURE__*/function (_Ice$ProtocolExceptio4) {\n  \"use strict\";\n\n  function _class44(reason) {\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class44);\n    return _callSuper(this, _class44, [reason, _cause]);\n  }\n  _inherits(_class44, _Ice$ProtocolExceptio4);\n  return _createClass(_class44, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.ProtocolException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::UnknownMessageException\";\n    }\n  }]);\n}(Ice.ProtocolException);\n\n/**\n * This exception is raised if a message is received over a connection\n * that is not yet validated.\n *\n **/\nIce.ConnectionNotValidatedException = /*#__PURE__*/function (_Ice$ProtocolExceptio5) {\n  \"use strict\";\n\n  function _class45(reason) {\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class45);\n    return _callSuper(this, _class45, [reason, _cause]);\n  }\n  _inherits(_class45, _Ice$ProtocolExceptio5);\n  return _createClass(_class45, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.ProtocolException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::ConnectionNotValidatedException\";\n    }\n  }]);\n}(Ice.ProtocolException);\n\n/**\n * This exception indicates that a response for an unknown request ID has been\n * received.\n *\n **/\nIce.UnknownRequestIdException = /*#__PURE__*/function (_Ice$ProtocolExceptio6) {\n  \"use strict\";\n\n  function _class46(reason) {\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class46);\n    return _callSuper(this, _class46, [reason, _cause]);\n  }\n  _inherits(_class46, _Ice$ProtocolExceptio6);\n  return _createClass(_class46, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.ProtocolException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::UnknownRequestIdException\";\n    }\n  }]);\n}(Ice.ProtocolException);\n\n/**\n * This exception indicates that an unknown reply status has been received.\n *\n **/\nIce.UnknownReplyStatusException = /*#__PURE__*/function (_Ice$ProtocolExceptio7) {\n  \"use strict\";\n\n  function _class47(reason) {\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class47);\n    return _callSuper(this, _class47, [reason, _cause]);\n  }\n  _inherits(_class47, _Ice$ProtocolExceptio7);\n  return _createClass(_class47, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.ProtocolException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::UnknownReplyStatusException\";\n    }\n  }]);\n}(Ice.ProtocolException);\n\n/**\n * This exception indicates that the connection has been gracefully shut down by the\n * server. The operation call that caused this exception has not been\n * executed by the server. In most cases you will not get this\n * exception, because the client will automatically retry the\n * operation call in case the server shut down the connection. However,\n * if upon retry the server shuts down the connection again, and the\n * retry limit has been reached, then this exception is propagated to\n * the application code.\n *\n **/\nIce.CloseConnectionException = /*#__PURE__*/function (_Ice$ProtocolExceptio8) {\n  \"use strict\";\n\n  function _class48(reason) {\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class48);\n    return _callSuper(this, _class48, [reason, _cause]);\n  }\n  _inherits(_class48, _Ice$ProtocolExceptio8);\n  return _createClass(_class48, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.ProtocolException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::CloseConnectionException\";\n    }\n  }]);\n}(Ice.ProtocolException);\n\n/**\n * This exception is raised by an operation call if the application\n * closes the connection locally using {@link Connection#close}.\n *\n * @see Connection#close\n *\n **/\nIce.ConnectionManuallyClosedException = /*#__PURE__*/function (_Ice$LocalException26) {\n  \"use strict\";\n\n  function _class49() {\n    var _this24;\n    var graceful = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class49);\n    _this24 = _callSuper(this, _class49, [_cause]);\n    _this24.graceful = graceful;\n    return _this24;\n  }\n  _inherits(_class49, _Ice$LocalException26);\n  return _createClass(_class49, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.LocalException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::ConnectionManuallyClosedException\";\n    }\n  }]);\n}(Ice.LocalException);\n\n/**\n * This exception indicates that a message size is less\n * than the minimum required size.\n *\n **/\nIce.IllegalMessageSizeException = /*#__PURE__*/function (_Ice$ProtocolExceptio9) {\n  \"use strict\";\n\n  function _class50(reason) {\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class50);\n    return _callSuper(this, _class50, [reason, _cause]);\n  }\n  _inherits(_class50, _Ice$ProtocolExceptio9);\n  return _createClass(_class50, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.ProtocolException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::IllegalMessageSizeException\";\n    }\n  }]);\n}(Ice.ProtocolException);\n\n/**\n * This exception indicates a problem with compressing or uncompressing data.\n *\n **/\nIce.CompressionException = /*#__PURE__*/function (_Ice$ProtocolExceptio0) {\n  \"use strict\";\n\n  function _class51(reason) {\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class51);\n    return _callSuper(this, _class51, [reason, _cause]);\n  }\n  _inherits(_class51, _Ice$ProtocolExceptio0);\n  return _createClass(_class51, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.ProtocolException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::CompressionException\";\n    }\n  }]);\n}(Ice.ProtocolException);\n\n/**\n * A datagram exceeds the configured size.\n *\n * This exception is raised if a datagram exceeds the configured send or receive buffer\n * size, or exceeds the maximum payload size of a UDP packet (65507 bytes).\n *\n **/\nIce.DatagramLimitException = /*#__PURE__*/function (_Ice$ProtocolExceptio1) {\n  \"use strict\";\n\n  function _class52(reason) {\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class52);\n    return _callSuper(this, _class52, [reason, _cause]);\n  }\n  _inherits(_class52, _Ice$ProtocolExceptio1);\n  return _createClass(_class52, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.ProtocolException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::DatagramLimitException\";\n    }\n  }]);\n}(Ice.ProtocolException);\n\n/**\n * This exception is raised for errors during marshaling or unmarshaling data.\n *\n **/\nIce.MarshalException = /*#__PURE__*/function (_Ice$ProtocolExceptio10) {\n  \"use strict\";\n\n  function _class53(reason) {\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class53);\n    return _callSuper(this, _class53, [reason, _cause]);\n  }\n  _inherits(_class53, _Ice$ProtocolExceptio10);\n  return _createClass(_class53, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.ProtocolException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::MarshalException\";\n    }\n  }]);\n}(Ice.ProtocolException);\n\n/**\n * This exception is raised if inconsistent data is received while unmarshaling a proxy.\n *\n **/\nIce.ProxyUnmarshalException = /*#__PURE__*/function (_Ice$MarshalException) {\n  \"use strict\";\n\n  function _class54(reason) {\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class54);\n    return _callSuper(this, _class54, [reason, _cause]);\n  }\n  _inherits(_class54, _Ice$MarshalException);\n  return _createClass(_class54, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.MarshalException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::ProxyUnmarshalException\";\n    }\n  }]);\n}(Ice.MarshalException);\n\n/**\n * This exception is raised if an out-of-bounds condition occurs during unmarshaling.\n *\n **/\nIce.UnmarshalOutOfBoundsException = /*#__PURE__*/function (_Ice$MarshalException2) {\n  \"use strict\";\n\n  function _class55(reason) {\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class55);\n    return _callSuper(this, _class55, [reason, _cause]);\n  }\n  _inherits(_class55, _Ice$MarshalException2);\n  return _createClass(_class55, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.MarshalException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::UnmarshalOutOfBoundsException\";\n    }\n  }]);\n}(Ice.MarshalException);\n\n/**\n * This exception is raised if no suitable value factory was found during\n * unmarshaling of a Slice class instance.\n *\n * @see ValueFactory\n * @see Communicator#getValueFactoryManager\n * @see ValueFactoryManager#add\n * @see ValueFactoryManager#find\n *\n **/\nIce.NoValueFactoryException = /*#__PURE__*/function (_Ice$MarshalException3) {\n  \"use strict\";\n\n  function _class56(reason) {\n    var _this25;\n    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    var _cause = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n    _classCallCheck(this, _class56);\n    _this25 = _callSuper(this, _class56, [reason, _cause]);\n    _this25.type = type;\n    return _this25;\n  }\n  _inherits(_class56, _Ice$MarshalException3);\n  return _createClass(_class56, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.MarshalException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::NoValueFactoryException\";\n    }\n  }]);\n}(Ice.MarshalException);\n\n/**\n * This exception is raised if the type of an unmarshaled Slice class instance does\n * not match its expected type.\n * This can happen if client and server are compiled with mismatched Slice\n * definitions or if a class of the wrong type is passed as a parameter\n * or return value using dynamic invocation. This exception can also be\n * raised if IceStorm is used to send Slice class instances and\n * an operation is subscribed to the wrong topic.\n *\n **/\nIce.UnexpectedObjectException = /*#__PURE__*/function (_Ice$MarshalException4) {\n  \"use strict\";\n\n  function _class57(reason) {\n    var _this26;\n    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    var expectedType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n    var _cause = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"\";\n    _classCallCheck(this, _class57);\n    _this26 = _callSuper(this, _class57, [reason, _cause]);\n    _this26.type = type;\n    _this26.expectedType = expectedType;\n    return _this26;\n  }\n  _inherits(_class57, _Ice$MarshalException4);\n  return _createClass(_class57, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.MarshalException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::UnexpectedObjectException\";\n    }\n  }]);\n}(Ice.MarshalException);\n\n/**\n * This exception is raised when Ice receives a request or reply\n * message whose size exceeds the limit specified by the\n * <code>Ice.MessageSizeMax</code> property.\n *\n **/\nIce.MemoryLimitException = /*#__PURE__*/function (_Ice$MarshalException5) {\n  \"use strict\";\n\n  function _class58(reason) {\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class58);\n    return _callSuper(this, _class58, [reason, _cause]);\n  }\n  _inherits(_class58, _Ice$MarshalException5);\n  return _createClass(_class58, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.MarshalException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::MemoryLimitException\";\n    }\n  }]);\n}(Ice.MarshalException);\n\n/**\n * This exception is raised when a string conversion to or from UTF-8\n * fails during marshaling or unmarshaling.\n *\n **/\nIce.StringConversionException = /*#__PURE__*/function (_Ice$MarshalException6) {\n  \"use strict\";\n\n  function _class59(reason) {\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class59);\n    return _callSuper(this, _class59, [reason, _cause]);\n  }\n  _inherits(_class59, _Ice$MarshalException6);\n  return _createClass(_class59, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.MarshalException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::StringConversionException\";\n    }\n  }]);\n}(Ice.MarshalException);\n\n/**\n * This exception indicates a malformed data encapsulation.\n *\n **/\nIce.EncapsulationException = /*#__PURE__*/function (_Ice$MarshalException7) {\n  \"use strict\";\n\n  function _class60(reason) {\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class60);\n    return _callSuper(this, _class60, [reason, _cause]);\n  }\n  _inherits(_class60, _Ice$MarshalException7);\n  return _createClass(_class60, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.MarshalException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::EncapsulationException\";\n    }\n  }]);\n}(Ice.MarshalException);\n\n/**\n * This exception is raised if an unsupported feature is used. The\n * unsupported feature string contains the name of the unsupported\n * feature\n *\n **/\nIce.FeatureNotSupportedException = /*#__PURE__*/function (_Ice$LocalException27) {\n  \"use strict\";\n\n  function _class61() {\n    var _this27;\n    var unsupportedFeature = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class61);\n    _this27 = _callSuper(this, _class61, [_cause]);\n    _this27.unsupportedFeature = unsupportedFeature;\n    return _this27;\n  }\n  _inherits(_class61, _Ice$LocalException27);\n  return _createClass(_class61, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.LocalException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::FeatureNotSupportedException\";\n    }\n  }]);\n}(Ice.LocalException);\n\n/**\n * This exception indicates a failure in a security subsystem,\n * such as the IceSSL plug-in.\n *\n **/\nIce.SecurityException = /*#__PURE__*/function (_Ice$LocalException28) {\n  \"use strict\";\n\n  function _class62() {\n    var _this28;\n    var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class62);\n    _this28 = _callSuper(this, _class62, [_cause]);\n    _this28.reason = reason;\n    return _this28;\n  }\n  _inherits(_class62, _Ice$LocalException28);\n  return _createClass(_class62, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.LocalException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::SecurityException\";\n    }\n  }]);\n}(Ice.LocalException);\n\n/**\n * This exception indicates that an attempt has been made to\n * change the connection properties of a fixed proxy.\n *\n **/\nIce.FixedProxyException = /*#__PURE__*/function (_Ice$LocalException29) {\n  \"use strict\";\n\n  function _class63() {\n    var _cause = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    _classCallCheck(this, _class63);\n    return _callSuper(this, _class63, [_cause]);\n  }\n  _inherits(_class63, _Ice$LocalException29);\n  return _createClass(_class63, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.LocalException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::FixedProxyException\";\n    }\n  }]);\n}(Ice.LocalException);\n\n/**\n * Indicates that the response to a request has already been sent;\n * re-dispatching such a request is not possible.\n *\n **/\nIce.ResponseSentException = /*#__PURE__*/function (_Ice$LocalException30) {\n  \"use strict\";\n\n  function _class64() {\n    var _cause = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    _classCallCheck(this, _class64);\n    return _callSuper(this, _class64, [_cause]);\n  }\n  _inherits(_class64, _Ice$LocalException30);\n  return _createClass(_class64, null, [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.LocalException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::ResponseSentException\";\n    }\n  }]);\n}(Ice.LocalException);\n/* slice2js browser-bundle-skip */\nexports.Ice = Ice;\n/* slice2js browser-bundle-skip-end */\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/LocalException.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Locator.js":
/*!*********************************************!*\
  !*** ./node_modules/ice/src/Ice/Locator.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `Locator.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nvar _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\");\n__webpack_require__(/*! ../Ice/ObjectPrx */ \"./node_modules/ice/src/Ice/ObjectPrx.js\");\n__webpack_require__(/*! ../Ice/Operation */ \"./node_modules/ice/src/Ice/Operation.js\");\n__webpack_require__(/*! ../Ice/Exception */ \"./node_modules/ice/src/Ice/Exception.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\n__webpack_require__(/*! ../Ice/Identity */ \"./node_modules/ice/src/Ice/Identity.js\");\n__webpack_require__(/*! ../Ice/Process */ \"./node_modules/ice/src/Ice/Process.js\");\nvar Ice = _ModuleRegistry.module(\"Ice\");\nvar Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n\n/**\n * This exception is raised if an adapter cannot be found.\n *\n **/\nIce.AdapterNotFoundException = /*#__PURE__*/function (_Ice$UserException) {\n  \"use strict\";\n\n  function _class() {\n    var _cause = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    _classCallCheck(this, _class);\n    return _callSuper(this, _class, [_cause]);\n  }\n  _inherits(_class, _Ice$UserException);\n  return _createClass(_class, [{\n    key: \"_mostDerivedType\",\n    value: function _mostDerivedType() {\n      return Ice.AdapterNotFoundException;\n    }\n  }], [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.UserException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::AdapterNotFoundException\";\n    }\n  }]);\n}(Ice.UserException);\n\n/**\n * This exception is raised if the replica group provided by the\n * server is invalid.\n *\n **/\nIce.InvalidReplicaGroupIdException = /*#__PURE__*/function (_Ice$UserException2) {\n  \"use strict\";\n\n  function _class2() {\n    var _cause = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    _classCallCheck(this, _class2);\n    return _callSuper(this, _class2, [_cause]);\n  }\n  _inherits(_class2, _Ice$UserException2);\n  return _createClass(_class2, [{\n    key: \"_mostDerivedType\",\n    value: function _mostDerivedType() {\n      return Ice.InvalidReplicaGroupIdException;\n    }\n  }], [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.UserException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::InvalidReplicaGroupIdException\";\n    }\n  }]);\n}(Ice.UserException);\n\n/**\n * This exception is raised if a server tries to set endpoints for\n * an adapter that is already active.\n *\n **/\nIce.AdapterAlreadyActiveException = /*#__PURE__*/function (_Ice$UserException3) {\n  \"use strict\";\n\n  function _class3() {\n    var _cause = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    _classCallCheck(this, _class3);\n    return _callSuper(this, _class3, [_cause]);\n  }\n  _inherits(_class3, _Ice$UserException3);\n  return _createClass(_class3, [{\n    key: \"_mostDerivedType\",\n    value: function _mostDerivedType() {\n      return Ice.AdapterAlreadyActiveException;\n    }\n  }], [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.UserException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::AdapterAlreadyActiveException\";\n    }\n  }]);\n}(Ice.UserException);\n\n/**\n * This exception is raised if an object cannot be found.\n *\n **/\nIce.ObjectNotFoundException = /*#__PURE__*/function (_Ice$UserException4) {\n  \"use strict\";\n\n  function _class4() {\n    var _cause = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    _classCallCheck(this, _class4);\n    return _callSuper(this, _class4, [_cause]);\n  }\n  _inherits(_class4, _Ice$UserException4);\n  return _createClass(_class4, [{\n    key: \"_mostDerivedType\",\n    value: function _mostDerivedType() {\n      return Ice.ObjectNotFoundException;\n    }\n  }], [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.UserException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::ObjectNotFoundException\";\n    }\n  }]);\n}(Ice.UserException);\n\n/**\n * This exception is raised if a server cannot be found.\n *\n **/\nIce.ServerNotFoundException = /*#__PURE__*/function (_Ice$UserException5) {\n  \"use strict\";\n\n  function _class5() {\n    var _cause = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    _classCallCheck(this, _class5);\n    return _callSuper(this, _class5, [_cause]);\n  }\n  _inherits(_class5, _Ice$UserException5);\n  return _createClass(_class5, [{\n    key: \"_mostDerivedType\",\n    value: function _mostDerivedType() {\n      return Ice.ServerNotFoundException;\n    }\n  }], [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.UserException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::Ice::ServerNotFoundException\";\n    }\n  }]);\n}(Ice.UserException);\nvar iceC_Ice_Locator_ids = [\"::Ice::Locator\", \"::Ice::Object\"];\n\n/**\n * The Ice locator interface. This interface is used by clients to\n * lookup adapters and objects. It is also used by servers to get the\n * locator registry proxy.\n *\n * <p class=\"Note\">The {@link Locator} interface is intended to be used by\n * Ice internals and by locator implementations. Regular user code\n * should not attempt to use any functionality of this interface\n * directly.\n *\n **/\nIce.Locator = /*#__PURE__*/function (_Ice$Object) {\n  \"use strict\";\n\n  function _class6() {\n    _classCallCheck(this, _class6);\n    return _callSuper(this, _class6, arguments);\n  }\n  _inherits(_class6, _Ice$Object);\n  return _createClass(_class6);\n}(Ice.Object);\nIce.LocatorPrx = /*#__PURE__*/function (_Ice$ObjectPrx) {\n  \"use strict\";\n\n  function _class7() {\n    _classCallCheck(this, _class7);\n    return _callSuper(this, _class7, arguments);\n  }\n  _inherits(_class7, _Ice$ObjectPrx);\n  return _createClass(_class7);\n}(Ice.ObjectPrx);\nSlice.defineOperations(Ice.Locator, Ice.LocatorPrx, iceC_Ice_Locator_ids, 0, {\n  \"findObjectById\": [, 2, 1,, [9], [[Ice.Identity]],, [Ice.ObjectNotFoundException],,],\n  \"findAdapterById\": [, 2, 1,, [9], [[7]],, [Ice.AdapterNotFoundException],,],\n  \"getRegistry\": [, 2, 1,, [\"Ice.LocatorRegistryPrx\"],,,,,]\n});\nvar iceC_Ice_LocatorRegistry_ids = [\"::Ice::LocatorRegistry\", \"::Ice::Object\"];\n\n/**\n * The Ice locator registry interface. This interface is used by\n * servers to register adapter endpoints with the locator.\n *\n * <p class=\"Note\"> The {@link LocatorRegistry} interface is intended to be used\n * by Ice internals and by locator implementations. Regular user\n * code should not attempt to use any functionality of this interface\n * directly.\n *\n **/\nIce.LocatorRegistry = /*#__PURE__*/function (_Ice$Object2) {\n  \"use strict\";\n\n  function _class8() {\n    _classCallCheck(this, _class8);\n    return _callSuper(this, _class8, arguments);\n  }\n  _inherits(_class8, _Ice$Object2);\n  return _createClass(_class8);\n}(Ice.Object);\nIce.LocatorRegistryPrx = /*#__PURE__*/function (_Ice$ObjectPrx2) {\n  \"use strict\";\n\n  function _class9() {\n    _classCallCheck(this, _class9);\n    return _callSuper(this, _class9, arguments);\n  }\n  _inherits(_class9, _Ice$ObjectPrx2);\n  return _createClass(_class9);\n}(Ice.ObjectPrx);\nSlice.defineOperations(Ice.LocatorRegistry, Ice.LocatorRegistryPrx, iceC_Ice_LocatorRegistry_ids, 0, {\n  \"setAdapterDirectProxy\": [, 2, 2,,, [[7], [9]],, [Ice.AdapterAlreadyActiveException, Ice.AdapterNotFoundException],,],\n  \"setReplicatedAdapterDirectProxy\": [, 2, 2,,, [[7], [7], [9]],, [Ice.AdapterAlreadyActiveException, Ice.AdapterNotFoundException, Ice.InvalidReplicaGroupIdException],,],\n  \"setServerProcessProxy\": [, 2, 2,,, [[7], [\"Ice.ProcessPrx\"]],, [Ice.ServerNotFoundException],,]\n});\nvar iceC_Ice_LocatorFinder_ids = [\"::Ice::LocatorFinder\", \"::Ice::Object\"];\n\n/**\n * This inferface should be implemented by services implementing the\n * Ice::Locator interface. It should be advertised through an Ice\n * object with the identity `Ice/LocatorFinder'. This allows clients\n * to retrieve the locator proxy with just the endpoint information of\n * the service.\n *\n **/\nIce.LocatorFinder = /*#__PURE__*/function (_Ice$Object3) {\n  \"use strict\";\n\n  function _class0() {\n    _classCallCheck(this, _class0);\n    return _callSuper(this, _class0, arguments);\n  }\n  _inherits(_class0, _Ice$Object3);\n  return _createClass(_class0);\n}(Ice.Object);\nIce.LocatorFinderPrx = /*#__PURE__*/function (_Ice$ObjectPrx3) {\n  \"use strict\";\n\n  function _class1() {\n    _classCallCheck(this, _class1);\n    return _callSuper(this, _class1, arguments);\n  }\n  _inherits(_class1, _Ice$ObjectPrx3);\n  return _createClass(_class1);\n}(Ice.ObjectPrx);\nSlice.defineOperations(Ice.LocatorFinder, Ice.LocatorFinderPrx, iceC_Ice_LocatorFinder_ids, 0, {\n  \"getLocator\": [,,,, [\"Ice.LocatorPrx\"],,,,,]\n});\n/* slice2js browser-bundle-skip */\nexports.Ice = Ice;\n/* slice2js browser-bundle-skip-end */\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/Locator.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/LocatorInfo.js":
/*!*************************************************!*\
  !*** ./node_modules/ice/src/Ice/LocatorInfo.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n__webpack_require__(/*! ../Ice/Debug */ \"./node_modules/ice/src/Ice/Debug.js\");\n__webpack_require__(/*! ../Ice/Exception */ \"./node_modules/ice/src/Ice/Exception.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/IdentityUtil */ \"./node_modules/ice/src/Ice/IdentityUtil.js\");\n__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\");\n__webpack_require__(/*! ../Ice/Locator */ \"./node_modules/ice/src/Ice/Locator.js\");\n__webpack_require__(/*! ../Ice/Promise */ \"./node_modules/ice/src/Ice/Promise.js\");\n__webpack_require__(/*! ../Ice/Protocol */ \"./node_modules/ice/src/Ice/Protocol.js\");\nvar Debug = Ice.Debug;\nvar HashMap = Ice.HashMap;\nvar LocatorRegistryPrx = Ice.LocatorRegisterPrx;\nvar Protocol = Ice.Protocol;\nvar LocatorInfo = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function LocatorInfo(locator, table, background) {\n    _classCallCheck(this, LocatorInfo);\n    this._locator = locator;\n    this._locatorRegistry = null;\n    this._table = table;\n    this._background = background;\n    this._adapterRequests = new Map(); // Map<String, Request>\n    this._objectRequests = new HashMap(HashMap.compareEquals); // Map<Ice.Identity, Request>\n  }\n  return _createClass(LocatorInfo, [{\n    key: \"destroy\",\n    value: function destroy() {\n      this._locatorRegistry = null;\n      this._table.clear();\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(rhs) {\n      if (this === rhs) {\n        return true;\n      }\n      if (rhs instanceof LocatorInfo) {\n        return this._locator.equals(rhs._locator);\n      }\n      return false;\n    }\n  }, {\n    key: \"hashCode\",\n    value: function hashCode() {\n      return this._locator.hashCode();\n    }\n  }, {\n    key: \"getLocator\",\n    value: function getLocator() {\n      return this._locator;\n    }\n  }, {\n    key: \"getLocatorRegistry\",\n    value: function getLocatorRegistry() {\n      var _this = this;\n      if (this._locatorRegistry !== null) {\n        return Ice.Promise.resolve(this._locatorRegistry);\n      }\n      return this._locator.getRegistry().then(function (reg) {\n        //\n        // The locator registry can't be located. We use ordered\n        // endpoint selection in case the locator returned a proxy\n        // with some endpoints which are prefered to be tried first.\n        //\n        _this._locatorRegistry = LocatorRegistryPrx.uncheckedCast(reg.ice_locator(null).ice_endpointSelection(Ice.EndpointSelectionType.Ordered));\n        return _this._locatorRegistry;\n      });\n    }\n  }, {\n    key: \"getEndpoints\",\n    value: function getEndpoints(ref, wellKnownRef, ttl, p) {\n      var promise = p || new Ice.Promise(); // success callback receives (endpoints, cached)\n\n      Debug.assert(ref.isIndirect());\n      var endpoints = null;\n      var cached = {\n        value: false\n      };\n      if (!ref.isWellKnown()) {\n        endpoints = this._table.getAdapterEndpoints(ref.getAdapterId(), ttl, cached);\n        if (!cached.value) {\n          if (this._background && endpoints !== null) {\n            this.getAdapterRequest(ref).addCallback(ref, wellKnownRef, ttl, null);\n          } else {\n            this.getAdapterRequest(ref).addCallback(ref, wellKnownRef, ttl, promise);\n            return promise;\n          }\n        }\n      } else {\n        var r = this._table.getObjectReference(ref.getIdentity(), ttl, cached);\n        if (!cached.value) {\n          if (this._background && r !== null) {\n            this.getObjectRequest(ref).addCallback(ref, null, ttl, null);\n          } else {\n            this.getObjectRequest(ref).addCallback(ref, null, ttl, promise);\n            return promise;\n          }\n        }\n        if (!r.isIndirect()) {\n          endpoints = r.getEndpoints();\n        } else if (!r.isWellKnown()) {\n          if (ref.getInstance().traceLevels().location >= 1) {\n            this.traceWellKnown(\"found adapter for well-known object in locator cache\", ref, r);\n          }\n          this.getEndpoints(r, ref, ttl, promise);\n          return promise;\n        }\n      }\n      Debug.assert(endpoints !== null);\n      if (ref.getInstance().traceLevels().location >= 1) {\n        this.getEndpointsTrace(ref, endpoints, true);\n      }\n      promise.resolve([endpoints, true]);\n      return promise;\n    }\n  }, {\n    key: \"clearCache\",\n    value: function clearCache(ref) {\n      Debug.assert(ref.isIndirect());\n      if (!ref.isWellKnown()) {\n        var endpoints = this._table.removeAdapterEndpoints(ref.getAdapterId());\n        if (endpoints !== null && ref.getInstance().traceLevels().location >= 2) {\n          this.trace(\"removed endpoints for adapter from locator cache\", ref, endpoints);\n        }\n      } else {\n        var r = this._table.removeObjectReference(ref.getIdentity());\n        if (r !== null) {\n          if (!r.isIndirect()) {\n            if (ref.getInstance().traceLevels().location >= 2) {\n              this.trace(\"removed endpoints for well-known object from locator cache\", ref, r.getEndpoints());\n            }\n          } else if (!r.isWellKnown()) {\n            if (ref.getInstance().traceLevels().location >= 2) {\n              this.traceWellKnown(\"removed adapter for well-known object from locator cache\", ref, r);\n            }\n            this.clearCache(r);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"trace\",\n    value: function trace(msg, ref, endpoints) {\n      Debug.assert(ref.isIndirect());\n      var s = [];\n      s.push(msg);\n      s.push(\"\\n\");\n      if (!ref.isWellKnown()) {\n        s.push(\"adapter = \");\n        s.push(ref.getAdapterId());\n        s.push(\"\\n\");\n      } else {\n        s.push(\"well-known proxy = \");\n        s.push(ref.toString());\n        s.push(\"\\n\");\n      }\n      s.push(\"endpoints = \");\n      s.push(endpoints.map(function (e) {\n        return e.toString();\n      }).join(\":\"));\n      ref.getInstance().initializationData().logger.trace(ref.getInstance().traceLevels().locationCat, s.join(\"\"));\n    }\n  }, {\n    key: \"traceWellKnown\",\n    value: function traceWellKnown(msg, ref, resolved) {\n      Debug.assert(ref.isWellKnown());\n      var s = [];\n      s.push(msg);\n      s.push(\"\\n\");\n      s.push(\"well-known proxy = \");\n      s.push(ref.toString());\n      s.push(\"\\n\");\n      s.push(\"adapter = \");\n      s.push(resolved.getAdapterId());\n      ref.getInstance().initializationData().logger.trace(ref.getInstance().traceLevels().locationCat, s.join(\"\"));\n    }\n  }, {\n    key: \"getEndpointsException\",\n    value: function getEndpointsException(ref, exc) {\n      Debug.assert(ref.isIndirect());\n      var instance = ref.getInstance();\n      try {\n        throw exc;\n      } catch (ex) {\n        if (ex instanceof Ice.AdapterNotFoundException) {\n          if (instance.traceLevels().location >= 1) {\n            var s = [];\n            s.push(\"adapter not found\\n\");\n            s.push(\"adapter = \");\n            s.push(ref.getAdapterId());\n            instance.initializationData().logger.trace(instance.traceLevels().locationCat, s.join(\"\"));\n          }\n          var e = new Ice.NotRegisteredException();\n          e.kindOfObject = \"object adapter\";\n          e.id = ref.getAdapterId();\n          throw e;\n        } else if (ex instanceof Ice.ObjectNotFoundException) {\n          if (instance.traceLevels().location >= 1) {\n            var _s = [];\n            _s.push(\"object not found\\n\");\n            _s.push(\"object = \");\n            _s.push(Ice.identityToString(ref.getIdentity(), instance.toStringMode()));\n            instance.initializationData().logger.trace(instance.traceLevels().locationCat, _s.join(\"\"));\n          }\n          var _e = new Ice.NotRegisteredException();\n          _e.kindOfObject = \"object\";\n          _e.id = Ice.identityToString(ref.getIdentity(), instance.toStringMode());\n          throw _e;\n        } else if (ex instanceof Ice.NotRegisteredException) {\n          throw ex;\n        } else if (ex instanceof Ice.LocalException) {\n          if (instance.traceLevels().location >= 1) {\n            var _s2 = [];\n            _s2.push(\"couldn't contact the locator to retrieve endpoints\\n\");\n            if (ref.getAdapterId().length > 0) {\n              _s2.push(\"adapter = \");\n              _s2.push(ref.getAdapterId());\n              _s2.push(\"\\n\");\n            } else {\n              _s2.push(\"well-known proxy = \");\n              _s2.push(ref.toString());\n              _s2.push(\"\\n\");\n            }\n            _s2.push(\"reason = \" + ex.toString());\n            instance.initializationData().logger.trace(instance.traceLevels().locationCat, _s2.join(\"\"));\n          }\n          throw ex;\n        } else {\n          Debug.assert(false);\n        }\n      }\n    }\n  }, {\n    key: \"getEndpointsTrace\",\n    value: function getEndpointsTrace(ref, endpoints, cached) {\n      if (endpoints !== null && endpoints.length > 0) {\n        if (cached) {\n          if (ref.isWellKnown()) {\n            this.trace(\"found endpoints for well-known proxy in locator cache\", ref, endpoints);\n          } else {\n            this.trace(\"found endpoints for adapter in locator cache\", ref, endpoints);\n          }\n        } else if (ref.isWellKnown()) {\n          this.trace(\"retrieved endpoints for well-known proxy from locator, adding to locator cache\", ref, endpoints);\n        } else {\n          this.trace(\"retrieved endpoints for adapter from locator, adding to locator cache\", ref, endpoints);\n        }\n      } else {\n        var instance = ref.getInstance();\n        var s = [];\n        s.push(\"no endpoints configured for \");\n        if (ref.getAdapterId().length > 0) {\n          s.push(\"adapter\\n\");\n          s.push(\"adapter = \");\n          s.push(ref.getAdapterId());\n          s.push(\"\\n\");\n        } else {\n          s.push(\"well-known object\\n\");\n          s.push(\"well-known proxy = \");\n          s.push(ref.toString());\n          s.push(\"\\n\");\n        }\n        instance.initializationData().logger.trace(instance.traceLevels().locationCat, s.join(\"\"));\n      }\n    }\n  }, {\n    key: \"getAdapterRequest\",\n    value: function getAdapterRequest(ref) {\n      if (ref.getInstance().traceLevels().location >= 1) {\n        var instance = ref.getInstance();\n        var s = [];\n        s.push(\"searching for adapter by id\\n\");\n        s.push(\"adapter = \");\n        s.push(ref.getAdapterId());\n        instance.initializationData().logger.trace(instance.traceLevels().locationCat, s.join(\"\"));\n      }\n      var request = this._adapterRequests.get(ref.getAdapterId());\n      if (request !== undefined) {\n        return request;\n      }\n      request = new AdapterRequest(this, ref);\n      this._adapterRequests.set(ref.getAdapterId(), request);\n      return request;\n    }\n  }, {\n    key: \"getObjectRequest\",\n    value: function getObjectRequest(ref) {\n      if (ref.getInstance().traceLevels().location >= 1) {\n        var instance = ref.getInstance();\n        var s = [];\n        s.push(\"searching for well-known object\\n\");\n        s.push(\"well-known proxy = \");\n        s.push(ref.toString());\n        instance.initializationData().logger.trace(instance.traceLevels().locationCat, s.join(\"\"));\n      }\n      var request = this._objectRequests.get(ref.getIdentity());\n      if (request !== undefined) {\n        return request;\n      }\n      request = new ObjectRequest(this, ref);\n      this._objectRequests.set(ref.getIdentity(), request);\n      return request;\n    }\n  }, {\n    key: \"finishRequest\",\n    value: function finishRequest(ref, wellKnownRefs, proxy, notRegistered) {\n      if (proxy === null || proxy._getReference().isIndirect()) {\n        //\n        // Remove the cached references of well-known objects for which we tried\n        // to resolved the endpoints if these endpoints are empty.\n        //\n        for (var i = 0; i < wellKnownRefs.length; ++i) {\n          this._table.removeObjectReference(wellKnownRefs[i].getIdentity());\n        }\n      }\n      if (!ref.isWellKnown()) {\n        if (proxy !== null && !proxy._getReference().isIndirect()) {\n          // Cache the adapter endpoints.\n          this._table.addAdapterEndpoints(ref.getAdapterId(), proxy._getReference().getEndpoints());\n        } else if (notRegistered)\n          // If the adapter isn't registered anymore, remove it from the cache.\n          {\n            this._table.removeAdapterEndpoints(ref.getAdapterId());\n          }\n        Debug.assert(this._adapterRequests.has(ref.getAdapterId()));\n        this._adapterRequests[\"delete\"](ref.getAdapterId());\n      } else {\n        if (proxy !== null && !proxy._getReference().isWellKnown()) {\n          // Cache the well-known object reference.\n          this._table.addObjectReference(ref.getIdentity(), proxy._getReference());\n        } else if (notRegistered)\n          // If the well-known object isn't registered anymore, remove it from the cache.\n          {\n            this._table.removeObjectReference(ref.getIdentity());\n          }\n        Debug.assert(this._objectRequests.has(ref.getIdentity()));\n        this._objectRequests[\"delete\"](ref.getIdentity());\n      }\n    }\n  }]);\n}();\nIce.LocatorInfo = LocatorInfo;\nvar RequestCallback = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function RequestCallback(ref, ttl, promise) {\n    _classCallCheck(this, RequestCallback);\n    this._ref = ref;\n    this._ttl = ttl;\n    this._promise = promise;\n  }\n  return _createClass(RequestCallback, [{\n    key: \"response\",\n    value: function response(locatorInfo, proxy) {\n      var _this2 = this;\n      var endpoints = null;\n      if (proxy !== null) {\n        var r = proxy._getReference();\n        if (this._ref.isWellKnown() && !Protocol.isSupported(this._ref.getEncoding(), r.getEncoding())) {\n          //\n          // If a well-known proxy and the returned proxy\n          // encoding isn't supported, we're done: there's\n          // no compatible endpoint we can use.\n          //\n        } else if (!r.isIndirect()) {\n          endpoints = r.getEndpoints();\n        } else if (this._ref.isWellKnown() && !r.isWellKnown()) {\n          //\n          // We're resolving the endpoints of a well-known object and the proxy returned\n          // by the locator is an indirect proxy. We now need to resolve the endpoints\n          // of this indirect proxy.\n          //\n          if (this._ref.getInstance().traceLevels().location >= 1) {\n            locatorInfo.traceWellKnown(\"retrieved adapter for well-known object from locator, \" + \"adding to locator cache\", this._ref, r);\n          }\n          locatorInfo.getEndpoints(r, this._ref, this._ttl).then(function (values) {\n            if (_this2._promise !== null) {\n              _this2._promise.resolve(values);\n            }\n          }, function (ex) {\n            if (_this2._promise !== null) {\n              _this2._promise.reject(ex);\n            }\n          });\n          return;\n        }\n      }\n      if (this._ref.getInstance().traceLevels().location >= 1) {\n        locatorInfo.getEndpointsTrace(this._ref, endpoints, false);\n      }\n      if (this._promise !== null) {\n        this._promise.resolve(endpoints === null ? [[], false] : [endpoints, false]);\n      }\n    }\n  }, {\n    key: \"exception\",\n    value: function exception(locatorInfo, exc) {\n      try {\n        locatorInfo.getEndpointsException(this._ref, exc); // This throws.\n      } catch (ex) {\n        if (this._promise !== null) {\n          this._promise.reject(ex);\n        }\n      }\n    }\n  }]);\n}();\nvar Request = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function Request(locatorInfo, ref) {\n    _classCallCheck(this, Request);\n    this._locatorInfo = locatorInfo;\n    this._ref = ref;\n    this._callbacks = []; // Array<RequestCallback>\n    this._wellKnownRefs = []; // Array<Reference>\n    this._sent = false;\n    this._response = false;\n    this._proxy = null;\n    this._exception = null;\n  }\n  return _createClass(Request, [{\n    key: \"addCallback\",\n    value: function addCallback(ref, wellKnownRef, ttl, promise) {\n      var callback = new RequestCallback(ref, ttl, promise);\n      if (this._response) {\n        callback.response(this._locatorInfo, this._proxy);\n      } else if (this._exception !== null) {\n        callback.exception(this._locatorInfo, this._exception);\n      } else {\n        this._callbacks.push(callback);\n        if (wellKnownRef !== null)\n          // This request is to resolve the endpoints of a cached well-known object ref\n          {\n            this._wellKnownRefs.push(wellKnownRef);\n          }\n        if (!this._sent) {\n          this._sent = true;\n          this.send();\n        }\n      }\n    }\n  }, {\n    key: \"response\",\n    value: function response(proxy) {\n      this._locatorInfo.finishRequest(this._ref, this._wellKnownRefs, proxy, false);\n      this._response = true;\n      this._proxy = proxy;\n      for (var i = 0; i < this._callbacks.length; ++i) {\n        this._callbacks[i].response(this._locatorInfo, proxy);\n      }\n    }\n  }, {\n    key: \"exception\",\n    value: function exception(ex) {\n      this._locatorInfo.finishRequest(this._ref, this._wellKnownRefs, null, ex instanceof Ice.UserException);\n      this._exception = ex;\n      for (var i = 0; i < this._callbacks.length; ++i) {\n        this._callbacks[i].exception(this._locatorInfo, ex);\n      }\n    }\n  }]);\n}();\nvar ObjectRequest = /*#__PURE__*/function (_Request) {\n  \"use strict\";\n\n  function ObjectRequest(locatorInfo, reference) {\n    var _this3;\n    _classCallCheck(this, ObjectRequest);\n    _this3 = _callSuper(this, ObjectRequest, [locatorInfo, reference]);\n    Debug.assert(reference.isWellKnown());\n    return _this3;\n  }\n  _inherits(ObjectRequest, _Request);\n  return _createClass(ObjectRequest, [{\n    key: \"send\",\n    value: function send() {\n      var _this4 = this;\n      try {\n        this._locatorInfo.getLocator().findObjectById(this._ref.getIdentity()).then(function (proxy) {\n          return _this4.response(proxy);\n        }, function (ex) {\n          return _this4.exception(ex);\n        });\n      } catch (ex) {\n        this.exception(ex);\n      }\n    }\n  }]);\n}(Request);\nvar AdapterRequest = /*#__PURE__*/function (_Request2) {\n  \"use strict\";\n\n  function AdapterRequest(locatorInfo, reference) {\n    var _this5;\n    _classCallCheck(this, AdapterRequest);\n    _this5 = _callSuper(this, AdapterRequest, [locatorInfo, reference]);\n    Debug.assert(reference.isIndirect());\n    return _this5;\n  }\n  _inherits(AdapterRequest, _Request2);\n  return _createClass(AdapterRequest, [{\n    key: \"send\",\n    value: function send() {\n      var _this6 = this;\n      try {\n        this._locatorInfo.getLocator().findAdapterById(this._ref.getAdapterId()).then(function (proxy) {\n          return _this6.response(proxy);\n        }, function (ex) {\n          return _this6.exception(ex);\n        });\n      } catch (ex) {\n        this.exception(ex);\n      }\n    }\n  }]);\n}(Request);\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/LocatorInfo.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/LocatorManager.js":
/*!****************************************************!*\
  !*** ./node_modules/ice/src/Ice/LocatorManager.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/Locator */ \"./node_modules/ice/src/Ice/Locator.js\");\n__webpack_require__(/*! ../Ice/LocatorInfo */ \"./node_modules/ice/src/Ice/LocatorInfo.js\");\n__webpack_require__(/*! ../Ice/LocatorTable */ \"./node_modules/ice/src/Ice/LocatorTable.js\");\nvar HashMap = Ice.HashMap;\nvar LocatorInfo = Ice.LocatorInfo;\nvar LocatorPrx = Ice.LocatorPrx;\nvar LocatorTable = Ice.LocatorTable;\nvar LocatorManager = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function LocatorManager(properties) {\n    _classCallCheck(this, LocatorManager);\n    this._background = properties.getPropertyAsInt(\"Ice.BackgroundLocatorCacheUpdates\") > 0;\n    this._table = new HashMap(HashMap.compareEquals); // Map<Ice.LocatorPrx, LocatorInfo>\n    this._locatorTables = new HashMap(HashMap.compareEquals); // Map<Ice.Identity, LocatorTable>\n  }\n  return _createClass(LocatorManager, [{\n    key: \"destroy\",\n    value: function destroy() {\n      var _iterator = _createForOfIteratorHelper(this._table.values()),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var locator = _step.value;\n          locator.destroy();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      this._table.clear();\n      this._locatorTables.clear();\n    }\n\n    //\n    // Returns locator info for a given locator. Automatically creates\n    // the locator info if it doesn't exist yet.\n    //\n  }, {\n    key: \"find\",\n    value: function find(loc) {\n      if (loc === null) {\n        return null;\n      }\n\n      //\n      // The locator can't be located.\n      //\n      var locator = LocatorPrx.uncheckedCast(loc.ice_locator(null));\n\n      //\n      // TODO: reap unused locator info objects?\n      //\n      var info = this._table.get(locator);\n      if (info === undefined) {\n        //\n        // Rely on locator identity for the adapter table. We want to\n        // have only one table per locator (not one per locator\n        // proxy).\n        //\n        var table = this._locatorTables.get(locator.ice_getIdentity());\n        if (table === undefined) {\n          table = new LocatorTable();\n          this._locatorTables.set(locator.ice_getIdentity(), table);\n        }\n        info = new LocatorInfo(locator, table, this._background);\n        this._table.set(locator, info);\n      }\n      return info;\n    }\n  }]);\n}();\nIce.LocatorManager = LocatorManager;\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/LocatorManager.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/LocatorTable.js":
/*!**************************************************!*\
  !*** ./node_modules/ice/src/Ice/LocatorTable.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n__webpack_require__(/*! ../Ice/Debug */ \"./node_modules/ice/src/Ice/Debug.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/IdentityUtil */ \"./node_modules/ice/src/Ice/IdentityUtil.js\");\nvar Debug = Ice.Debug;\nvar HashMap = Ice.HashMap;\nvar EndpointTableEntry = /*#__PURE__*/_createClass(function EndpointTableEntry(time, endpoints) {\n  \"use strict\";\n\n  _classCallCheck(this, EndpointTableEntry);\n  this.time = time;\n  this.endpoints = endpoints;\n});\nvar ReferenceTableEntry = /*#__PURE__*/_createClass(function ReferenceTableEntry(time, reference) {\n  \"use strict\";\n\n  _classCallCheck(this, ReferenceTableEntry);\n  this.time = time;\n  this.reference = reference;\n});\nvar LocatorTable = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function LocatorTable() {\n    _classCallCheck(this, LocatorTable);\n    this._adapterEndpointsTable = new Map(); // Map<String, EndpointTableEntry>\n    this._objectTable = new HashMap(HashMap.compareEquals); // Map<Ice.Identity, ReferenceTableEntry>\n  }\n  return _createClass(LocatorTable, [{\n    key: \"clear\",\n    value: function clear() {\n      this._adapterEndpointsTable.clear();\n      this._objectTable.clear();\n    }\n  }, {\n    key: \"getAdapterEndpoints\",\n    value: function getAdapterEndpoints(adapter, ttl, cached) {\n      if (ttl === 0)\n        // Locator cache disabled.\n        {\n          cached.value = false;\n          return null;\n        }\n      var entry = this._adapterEndpointsTable.get(adapter);\n      if (entry !== undefined) {\n        cached.value = this.checkTTL(entry.time, ttl);\n        return entry.endpoints;\n      }\n      cached.value = false;\n      return null;\n    }\n  }, {\n    key: \"addAdapterEndpoints\",\n    value: function addAdapterEndpoints(adapter, endpoints) {\n      this._adapterEndpointsTable.set(adapter, new EndpointTableEntry(Date.now(), endpoints));\n    }\n  }, {\n    key: \"removeAdapterEndpoints\",\n    value: function removeAdapterEndpoints(adapter) {\n      var entry = this._adapterEndpointsTable.get(adapter);\n      this._adapterEndpointsTable[\"delete\"](adapter);\n      return entry !== undefined ? entry.endpoints : null;\n    }\n  }, {\n    key: \"getObjectReference\",\n    value: function getObjectReference(id, ttl, cached) {\n      if (ttl === 0)\n        // Locator cache disabled.\n        {\n          cached.value = false;\n          return null;\n        }\n      var entry = this._objectTable.get(id);\n      if (entry !== undefined) {\n        cached.value = this.checkTTL(entry.time, ttl);\n        return entry.reference;\n      }\n      cached.value = false;\n      return null;\n    }\n  }, {\n    key: \"addObjectReference\",\n    value: function addObjectReference(id, ref) {\n      this._objectTable.set(id, new ReferenceTableEntry(Date.now(), ref));\n    }\n  }, {\n    key: \"removeObjectReference\",\n    value: function removeObjectReference(id) {\n      var entry = this._objectTable.get(id);\n      this._objectTable[\"delete\"](id);\n      return entry !== undefined ? entry.reference : null;\n    }\n  }, {\n    key: \"checkTTL\",\n    value: function checkTTL(time, ttl) {\n      Debug.assert(ttl !== 0);\n      if (ttl < 0)\n        // TTL = infinite\n        {\n          return true;\n        } else {\n        return Date.now() - time <= ttl * 1000;\n      }\n    }\n  }]);\n}();\nIce.LocatorTable = LocatorTable;\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/LocatorTable.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Logger.js":
/*!********************************************!*\
  !*** ./node_modules/ice/src/Ice/Logger.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `Logger.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nvar _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\");\n__webpack_require__(/*! ../Ice/ObjectPrx */ \"./node_modules/ice/src/Ice/ObjectPrx.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\nvar Ice = _ModuleRegistry.module(\"Ice\");\nvar Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n/* slice2js browser-bundle-skip */\nexports.Ice = Ice;\n/* slice2js browser-bundle-skip-end */\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/Logger.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/LoggerF.js":
/*!*********************************************!*\
  !*** ./node_modules/ice/src/Ice/LoggerF.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `LoggerF.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nvar _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\nvar Ice = _ModuleRegistry.module(\"Ice\");\nvar Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n/* slice2js browser-bundle-skip */\nexports.Ice = Ice;\n/* slice2js browser-bundle-skip-end */\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/LoggerF.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/LoggerI.js":
/*!*********************************************!*\
  !*** ./node_modules/ice/src/Ice/LoggerI.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\nvar Logger = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function Logger(prefix) {\n    _classCallCheck(this, Logger);\n    if (prefix !== undefined && prefix.length > 0) {\n      this._prefix = prefix + \": \";\n    } else {\n      this._prefix = \"\";\n    }\n    this._dateformat = {\n      year: 'numeric',\n      month: 'numeric',\n      day: 'numeric',\n      hour: 'numeric',\n      minute: 'numeric',\n      second: 'numeric',\n      hour12: false\n    };\n  }\n  return _createClass(Logger, [{\n    key: \"print\",\n    value: function print(message) {\n      this.write(message, false);\n    }\n  }, {\n    key: \"trace\",\n    value: function trace(category, message) {\n      var s = [];\n      s.push(\"-- \");\n      s.push(this.timestamp());\n      s.push(' ');\n      s.push(this._prefix);\n      s.push(category);\n      s.push(\": \");\n      s.push(message);\n      this.write(s.join(\"\"), true);\n    }\n  }, {\n    key: \"warning\",\n    value: function warning(message) {\n      var s = [];\n      s.push(\"-! \");\n      s.push(this.timestamp());\n      s.push(' ');\n      s.push(this._prefix);\n      s.push(\"warning: \");\n      s.push(message);\n      this.write(s.join(\"\"), true);\n    }\n  }, {\n    key: \"error\",\n    value: function error(message) {\n      var s = [];\n      s.push(\"!! \");\n      s.push(this.timestamp());\n      s.push(' ');\n      s.push(this._prefix);\n      s.push(\"error: \");\n      s.push(message);\n      this.write(s.join(\"\"), true);\n    }\n  }, {\n    key: \"cloneWithPrefix\",\n    value: function cloneWithPrefix(prefix) {\n      return new Logger(prefix);\n    }\n  }, {\n    key: \"write\",\n    value: function write(message, indent) {\n      if (indent) {\n        message = message.replace(/\\n/g, \"\\n   \");\n      }\n      console.log(message);\n    }\n  }, {\n    key: \"timestamp\",\n    value: function timestamp() {\n      var d = new Date();\n      return d.toLocaleString(\"en-US\", this._dateformat) + \".\" + d.getMilliseconds();\n    }\n  }]);\n}();\nIce.Logger = Logger;\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/LoggerI.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Long.js":
/*!******************************************!*\
  !*** ./node_modules/ice/src/Ice/Long.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n\n//\n// The Long type represents a signed 64-bit integer as two 32-bit values\n// corresponding to the high and low words.\n//\nvar Long = /*#__PURE__*/function () {\n  \"use strict\";\n\n  //\n  // If only one argument is provide we assume it is a JavaScript Number,\n  // and we convert it to two 32 bit words to fit in the Ice.Long internal\n  // representation.\n  //\n  // If two arguments are provided we asume these are the high and low words\n  // respectively.\n  //\n  function Long() {\n    var high = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var low = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n    _classCallCheck(this, Long);\n    if (!Number.isSafeInteger(high)) {\n      throw new RangeError(low === undefined ? \"Number must be a safe integer\" : \"High word must be a safe integer\");\n    }\n    if (low === undefined) {\n      this.low = high >>> 0;\n      this.high = (high - this.low) / Long.HIGH_MASK >>> 0;\n    } else {\n      if (!Number.isSafeInteger(low)) {\n        throw new RangeError(\"Low word must be a safe integer\");\n      }\n      if (low < 0 || low > Long.MAX_UINT32) {\n        throw new RangeError(\"Low word must be between 0 and 0xFFFFFFFF\");\n      }\n      if (high < 0 || high > Long.MAX_UINT32) {\n        throw new RangeError(\"High word must be between 0 and 0xFFFFFFFF\");\n      }\n      this.high = high;\n      this.low = low;\n    }\n  }\n  return _createClass(Long, [{\n    key: \"hashCode\",\n    value: function hashCode() {\n      return this.low;\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(rhs) {\n      if (this === rhs) {\n        return true;\n      }\n      if (!(rhs instanceof Long)) {\n        return false;\n      }\n      return this.high === rhs.high && this.low === rhs.low;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.high + \":\" + this.low;\n    }\n  }, {\n    key: \"toNumber\",\n    value: function toNumber() {\n      if ((this.high & Long.SIGN_MASK) !== 0) {\n        var l = ~this.low >>> 0;\n        var h = ~this.high >>> 0;\n        if (h > Long.HIGH_MAX || h == Long.HIGH_MAX && l == Long.MAX_UINT32) {\n          return Number.NEGATIVE_INFINITY;\n        }\n        return -(h * Long.HIGH_MASK + l + 1);\n      } else {\n        if (this.high > Long.HIGH_MAX) {\n          return Number.POSITIVE_INFINITY;\n        }\n        return this.high * Long.HIGH_MASK + this.low;\n      }\n    }\n  }]);\n}(); //\n// 2^32\n//\nLong.MAX_UINT32 = 0xFFFFFFFF;\n\n//\n// (high & SIGN_MASK) != 0 denotes a negative number;\n// that is, the most significant bit is set.\n//\nLong.SIGN_MASK = 0x80000000;\n\n//\n// When converting to a JavaScript Number we left shift the\n// high word by 32 bits. As that isn't possible using JavaScript's\n// left shift operator, we multiply the value by 2^32 which will\n// produce the same result.\n//\nLong.HIGH_MASK = 0x100000000;\n\n//\n// The maximum value for the high word when coverting to\n// a JavaScript Number is 2^21 - 1, in which case all\n// 53 bits are used.\n//\nLong.HIGH_MAX = 0x1FFFFF;\nIce.Long = Long;\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/Long.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/MapUtil.js":
/*!*********************************************!*\
  !*** ./node_modules/ice/src/Ice/MapUtil.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\nvar MapUtil = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function MapUtil() {\n    _classCallCheck(this, MapUtil);\n  }\n  return _createClass(MapUtil, null, [{\n    key: \"equals\",\n    value: function equals(m1, m2) {\n      if (m1 === m2) {\n        return true;\n      } else if (m1.size != m2.size) {\n        return false;\n      } else {\n        var _iterator = _createForOfIteratorHelper(m1),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _step$value = _slicedToArray(_step.value, 2),\n              key = _step$value[0],\n              value = _step$value[1];\n            if (value === undefined) {\n              if (!m2.has(key)) {\n                return false;\n              } else if (m2.get(key) !== value) {\n                return false;\n              }\n            } else if (m2.get(key) !== value) {\n              return false;\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n      return true;\n    }\n  }]);\n}();\nIce.MapUtil = MapUtil;\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/MapUtil.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Metrics.js":
/*!*********************************************!*\
  !*** ./node_modules/ice/src/Ice/Metrics.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `Metrics.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nvar _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\");\n__webpack_require__(/*! ../Ice/ObjectPrx */ \"./node_modules/ice/src/Ice/ObjectPrx.js\");\n__webpack_require__(/*! ../Ice/Operation */ \"./node_modules/ice/src/Ice/Operation.js\");\n__webpack_require__(/*! ../Ice/Struct */ \"./node_modules/ice/src/Ice/Struct.js\");\n__webpack_require__(/*! ../Ice/Exception */ \"./node_modules/ice/src/Ice/Exception.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\n__webpack_require__(/*! ../Ice/BuiltinSequences */ \"./node_modules/ice/src/Ice/BuiltinSequences.js\");\nvar Ice = _ModuleRegistry.module(\"Ice\");\nvar Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n/* slice2js browser-bundle-skip */\n\nvar IceMX = _ModuleRegistry.module(\"IceMX\");\n/* slice2js browser-bundle-skip-end */\n\nSlice.defineDictionary(IceMX, \"StringIntDict\", \"StringIntDictHelper\", \"Ice.StringHelper\", \"Ice.IntHelper\", false, undefined, undefined);\nvar iceC_IceMX_Metrics_ids = [\"::Ice::Object\", \"::IceMX::Metrics\"];\n\n/**\n * The base class for metrics. A metrics object represents a\n * collection of measurements associated to a given a system.\n *\n **/\nIceMX.Metrics = /*#__PURE__*/function (_Ice$Value) {\n  \"use strict\";\n\n  function _class() {\n    var _this;\n    var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var total = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Ice.Long(0, 0);\n    var current = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var totalLifetime = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new Ice.Long(0, 0);\n    var failures = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    _classCallCheck(this, _class);\n    _this = _callSuper(this, _class);\n    _this.id = id;\n    _this.total = total;\n    _this.current = current;\n    _this.totalLifetime = totalLifetime;\n    _this.failures = failures;\n    return _this;\n  }\n  _inherits(_class, _Ice$Value);\n  return _createClass(_class, [{\n    key: \"_iceWriteMemberImpl\",\n    value: function _iceWriteMemberImpl(ostr) {\n      ostr.writeString(this.id);\n      ostr.writeLong(this.total);\n      ostr.writeInt(this.current);\n      ostr.writeLong(this.totalLifetime);\n      ostr.writeInt(this.failures);\n    }\n  }, {\n    key: \"_iceReadMemberImpl\",\n    value: function _iceReadMemberImpl(istr) {\n      this.id = istr.readString();\n      this.total = istr.readLong();\n      this.current = istr.readInt();\n      this.totalLifetime = istr.readLong();\n      this.failures = istr.readInt();\n    }\n  }]);\n}(Ice.Value);\nSlice.defineValue(IceMX.Metrics, iceC_IceMX_Metrics_ids[1], false);\n\n/**\n * A structure to keep track of failures associated with a given\n * metrics.\n *\n **/\nIceMX.MetricsFailures = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function _class2() {\n    var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var failures = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    _classCallCheck(this, _class2);\n    this.id = id;\n    this.failures = failures;\n  }\n  return _createClass(_class2, [{\n    key: \"_write\",\n    value: function _write(ostr) {\n      ostr.writeString(this.id);\n      IceMX.StringIntDictHelper.write(ostr, this.failures);\n    }\n  }, {\n    key: \"_read\",\n    value: function _read(istr) {\n      this.id = istr.readString();\n      this.failures = IceMX.StringIntDictHelper.read(istr);\n    }\n  }], [{\n    key: \"minWireSize\",\n    get: function get() {\n      return 2;\n    }\n  }]);\n}();\nSlice.defineStruct(IceMX.MetricsFailures, false, true);\nSlice.defineSequence(IceMX, \"MetricsFailuresSeqHelper\", \"IceMX.MetricsFailures\", false);\nSlice.defineSequence(IceMX, \"MetricsMapHelper\", \"Ice.ObjectHelper\", false, \"IceMX.Metrics\");\nSlice.defineDictionary(IceMX, \"MetricsView\", \"MetricsViewHelper\", \"Ice.StringHelper\", \"IceMX.MetricsMapHelper\", false, undefined, undefined, Ice.ArrayUtil.equals);\n\n/**\n * Raised if a metrics view cannot be found.\n *\n **/\nIceMX.UnknownMetricsView = /*#__PURE__*/function (_Ice$UserException) {\n  \"use strict\";\n\n  function _class3() {\n    var _cause = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    _classCallCheck(this, _class3);\n    return _callSuper(this, _class3, [_cause]);\n  }\n  _inherits(_class3, _Ice$UserException);\n  return _createClass(_class3, [{\n    key: \"_mostDerivedType\",\n    value: function _mostDerivedType() {\n      return IceMX.UnknownMetricsView;\n    }\n  }], [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.UserException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::IceMX::UnknownMetricsView\";\n    }\n  }]);\n}(Ice.UserException);\nvar iceC_IceMX_MetricsAdmin_ids = [\"::Ice::Object\", \"::IceMX::MetricsAdmin\"];\n\n/**\n * The metrics administrative facet interface. This interface allows\n * remote administrative clients to access metrics of an application\n * that enabled the Ice administrative facility and configured some\n * metrics views.\n *\n **/\nIceMX.MetricsAdmin = /*#__PURE__*/function (_Ice$Object) {\n  \"use strict\";\n\n  function _class4() {\n    _classCallCheck(this, _class4);\n    return _callSuper(this, _class4, arguments);\n  }\n  _inherits(_class4, _Ice$Object);\n  return _createClass(_class4);\n}(Ice.Object);\nIceMX.MetricsAdminPrx = /*#__PURE__*/function (_Ice$ObjectPrx) {\n  \"use strict\";\n\n  function _class5() {\n    _classCallCheck(this, _class5);\n    return _callSuper(this, _class5, arguments);\n  }\n  _inherits(_class5, _Ice$ObjectPrx);\n  return _createClass(_class5);\n}(Ice.ObjectPrx);\nSlice.defineOperations(IceMX.MetricsAdmin, IceMX.MetricsAdminPrx, iceC_IceMX_MetricsAdmin_ids, 1, {\n  \"getMetricsViewNames\": [,,, 2, [\"Ice.StringSeqHelper\"],, [[\"Ice.StringSeqHelper\"]],,,],\n  \"enableMetricsView\": [,,, 2,, [[7]],, [IceMX.UnknownMetricsView],,],\n  \"disableMetricsView\": [,,, 2,, [[7]],, [IceMX.UnknownMetricsView],,],\n  \"getMetricsView\": [,,, 2, [\"IceMX.MetricsViewHelper\"], [[7]], [[4]], [IceMX.UnknownMetricsView],, true],\n  \"getMapMetricsFailures\": [,,, 2, [\"IceMX.MetricsFailuresSeqHelper\"], [[7], [7]],, [IceMX.UnknownMetricsView],,],\n  \"getMetricsFailures\": [,,, 2, [IceMX.MetricsFailures], [[7], [7], [7]],, [IceMX.UnknownMetricsView],,]\n});\nvar iceC_IceMX_ThreadMetrics_ids = [\"::Ice::Object\", \"::IceMX::Metrics\", \"::IceMX::ThreadMetrics\"];\n\n/**\n * Provides information on the number of threads currently in use and\n * their activity.\n *\n **/\nIceMX.ThreadMetrics = /*#__PURE__*/function (_IceMX$Metrics) {\n  \"use strict\";\n\n  function _class6(id, total, current, totalLifetime, failures) {\n    var _this2;\n    var inUseForIO = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n    var inUseForUser = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n    var inUseForOther = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;\n    _classCallCheck(this, _class6);\n    _this2 = _callSuper(this, _class6, [id, total, current, totalLifetime, failures]);\n    _this2.inUseForIO = inUseForIO;\n    _this2.inUseForUser = inUseForUser;\n    _this2.inUseForOther = inUseForOther;\n    return _this2;\n  }\n  _inherits(_class6, _IceMX$Metrics);\n  return _createClass(_class6, [{\n    key: \"_iceWriteMemberImpl\",\n    value: function _iceWriteMemberImpl(ostr) {\n      ostr.writeInt(this.inUseForIO);\n      ostr.writeInt(this.inUseForUser);\n      ostr.writeInt(this.inUseForOther);\n    }\n  }, {\n    key: \"_iceReadMemberImpl\",\n    value: function _iceReadMemberImpl(istr) {\n      this.inUseForIO = istr.readInt();\n      this.inUseForUser = istr.readInt();\n      this.inUseForOther = istr.readInt();\n    }\n  }]);\n}(IceMX.Metrics);\nSlice.defineValue(IceMX.ThreadMetrics, iceC_IceMX_ThreadMetrics_ids[2], false);\nvar iceC_IceMX_DispatchMetrics_ids = [\"::Ice::Object\", \"::IceMX::DispatchMetrics\", \"::IceMX::Metrics\"];\n\n/**\n * Provides information on servant dispatch.\n *\n **/\nIceMX.DispatchMetrics = /*#__PURE__*/function (_IceMX$Metrics2) {\n  \"use strict\";\n\n  function _class7(id, total, current, totalLifetime, failures) {\n    var _this3;\n    var userException = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n    var size = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : new Ice.Long(0, 0);\n    var replySize = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : new Ice.Long(0, 0);\n    _classCallCheck(this, _class7);\n    _this3 = _callSuper(this, _class7, [id, total, current, totalLifetime, failures]);\n    _this3.userException = userException;\n    _this3.size = size;\n    _this3.replySize = replySize;\n    return _this3;\n  }\n  _inherits(_class7, _IceMX$Metrics2);\n  return _createClass(_class7, [{\n    key: \"_iceWriteMemberImpl\",\n    value: function _iceWriteMemberImpl(ostr) {\n      ostr.writeInt(this.userException);\n      ostr.writeLong(this.size);\n      ostr.writeLong(this.replySize);\n    }\n  }, {\n    key: \"_iceReadMemberImpl\",\n    value: function _iceReadMemberImpl(istr) {\n      this.userException = istr.readInt();\n      this.size = istr.readLong();\n      this.replySize = istr.readLong();\n    }\n  }]);\n}(IceMX.Metrics);\nSlice.defineValue(IceMX.DispatchMetrics, iceC_IceMX_DispatchMetrics_ids[1], false);\nvar iceC_IceMX_ChildInvocationMetrics_ids = [\"::Ice::Object\", \"::IceMX::ChildInvocationMetrics\", \"::IceMX::Metrics\"];\n\n/**\n * Provides information on child invocations. A child invocation is\n * either remote (sent over an Ice connection) or collocated. An\n * invocation can have multiple child invocation if it is\n * retried. Child invocation metrics are embedded within\n * {@link InvocationMetrics}.\n *\n **/\nIceMX.ChildInvocationMetrics = /*#__PURE__*/function (_IceMX$Metrics3) {\n  \"use strict\";\n\n  function _class8(id, total, current, totalLifetime, failures) {\n    var _this4;\n    var size = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : new Ice.Long(0, 0);\n    var replySize = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : new Ice.Long(0, 0);\n    _classCallCheck(this, _class8);\n    _this4 = _callSuper(this, _class8, [id, total, current, totalLifetime, failures]);\n    _this4.size = size;\n    _this4.replySize = replySize;\n    return _this4;\n  }\n  _inherits(_class8, _IceMX$Metrics3);\n  return _createClass(_class8, [{\n    key: \"_iceWriteMemberImpl\",\n    value: function _iceWriteMemberImpl(ostr) {\n      ostr.writeLong(this.size);\n      ostr.writeLong(this.replySize);\n    }\n  }, {\n    key: \"_iceReadMemberImpl\",\n    value: function _iceReadMemberImpl(istr) {\n      this.size = istr.readLong();\n      this.replySize = istr.readLong();\n    }\n  }]);\n}(IceMX.Metrics);\nSlice.defineValue(IceMX.ChildInvocationMetrics, iceC_IceMX_ChildInvocationMetrics_ids[1], false);\nvar iceC_IceMX_CollocatedMetrics_ids = [\"::Ice::Object\", \"::IceMX::ChildInvocationMetrics\", \"::IceMX::CollocatedMetrics\", \"::IceMX::Metrics\"];\n\n/**\n * Provides information on invocations that are collocated. Collocated\n * metrics are embedded within {@link InvocationMetrics}.\n *\n **/\nIceMX.CollocatedMetrics = /*#__PURE__*/function (_IceMX$ChildInvocatio) {\n  \"use strict\";\n\n  function _class9(id, total, current, totalLifetime, failures, size, replySize) {\n    _classCallCheck(this, _class9);\n    return _callSuper(this, _class9, [id, total, current, totalLifetime, failures, size, replySize]);\n  }\n  _inherits(_class9, _IceMX$ChildInvocatio);\n  return _createClass(_class9);\n}(IceMX.ChildInvocationMetrics);\nSlice.defineValue(IceMX.CollocatedMetrics, iceC_IceMX_CollocatedMetrics_ids[2], false);\nvar iceC_IceMX_RemoteMetrics_ids = [\"::Ice::Object\", \"::IceMX::ChildInvocationMetrics\", \"::IceMX::Metrics\", \"::IceMX::RemoteMetrics\"];\n\n/**\n * Provides information on invocations that are specifically sent over\n * Ice connections. Remote metrics are embedded within {@link InvocationMetrics}.\n *\n **/\nIceMX.RemoteMetrics = /*#__PURE__*/function (_IceMX$ChildInvocatio2) {\n  \"use strict\";\n\n  function _class0(id, total, current, totalLifetime, failures, size, replySize) {\n    _classCallCheck(this, _class0);\n    return _callSuper(this, _class0, [id, total, current, totalLifetime, failures, size, replySize]);\n  }\n  _inherits(_class0, _IceMX$ChildInvocatio2);\n  return _createClass(_class0);\n}(IceMX.ChildInvocationMetrics);\nSlice.defineValue(IceMX.RemoteMetrics, iceC_IceMX_RemoteMetrics_ids[3], false);\nvar iceC_IceMX_InvocationMetrics_ids = [\"::Ice::Object\", \"::IceMX::InvocationMetrics\", \"::IceMX::Metrics\"];\n\n/**\n * Provide measurements for proxy invocations. Proxy invocations can\n * either be sent over the wire or be collocated.\n *\n **/\nIceMX.InvocationMetrics = /*#__PURE__*/function (_IceMX$Metrics4) {\n  \"use strict\";\n\n  function _class1(id, total, current, totalLifetime, failures) {\n    var _this5;\n    var retry = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n    var userException = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n    var remotes = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;\n    var collocated = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : null;\n    _classCallCheck(this, _class1);\n    _this5 = _callSuper(this, _class1, [id, total, current, totalLifetime, failures]);\n    _this5.retry = retry;\n    _this5.userException = userException;\n    _this5.remotes = remotes;\n    _this5.collocated = collocated;\n    return _this5;\n  }\n  _inherits(_class1, _IceMX$Metrics4);\n  return _createClass(_class1, [{\n    key: \"_iceWriteMemberImpl\",\n    value: function _iceWriteMemberImpl(ostr) {\n      ostr.writeInt(this.retry);\n      ostr.writeInt(this.userException);\n      IceMX.MetricsMapHelper.write(ostr, this.remotes);\n      IceMX.MetricsMapHelper.write(ostr, this.collocated);\n    }\n  }, {\n    key: \"_iceReadMemberImpl\",\n    value: function _iceReadMemberImpl(istr) {\n      this.retry = istr.readInt();\n      this.userException = istr.readInt();\n      this.remotes = IceMX.MetricsMapHelper.read(istr);\n      this.collocated = IceMX.MetricsMapHelper.read(istr);\n    }\n  }]);\n}(IceMX.Metrics);\nSlice.defineValue(IceMX.InvocationMetrics, iceC_IceMX_InvocationMetrics_ids[1], false);\nvar iceC_IceMX_ConnectionMetrics_ids = [\"::Ice::Object\", \"::IceMX::ConnectionMetrics\", \"::IceMX::Metrics\"];\n\n/**\n * Provides information on the data sent and received over Ice\n * connections.\n *\n **/\nIceMX.ConnectionMetrics = /*#__PURE__*/function (_IceMX$Metrics5) {\n  \"use strict\";\n\n  function _class10(id, total, current, totalLifetime, failures) {\n    var _this6;\n    var receivedBytes = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : new Ice.Long(0, 0);\n    var sentBytes = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : new Ice.Long(0, 0);\n    _classCallCheck(this, _class10);\n    _this6 = _callSuper(this, _class10, [id, total, current, totalLifetime, failures]);\n    _this6.receivedBytes = receivedBytes;\n    _this6.sentBytes = sentBytes;\n    return _this6;\n  }\n  _inherits(_class10, _IceMX$Metrics5);\n  return _createClass(_class10, [{\n    key: \"_iceWriteMemberImpl\",\n    value: function _iceWriteMemberImpl(ostr) {\n      ostr.writeLong(this.receivedBytes);\n      ostr.writeLong(this.sentBytes);\n    }\n  }, {\n    key: \"_iceReadMemberImpl\",\n    value: function _iceReadMemberImpl(istr) {\n      this.receivedBytes = istr.readLong();\n      this.sentBytes = istr.readLong();\n    }\n  }]);\n}(IceMX.Metrics);\nSlice.defineValue(IceMX.ConnectionMetrics, iceC_IceMX_ConnectionMetrics_ids[1], false);\n/* slice2js browser-bundle-skip */\nexports.IceMX = IceMX;\n/* slice2js browser-bundle-skip-end */\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/Metrics.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/ModuleRegistry.js":
/*!****************************************************!*\
  !*** ./node_modules/ice/src/Ice/ModuleRegistry.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = {};\nif (typeof process !== 'undefined') {\n  var modules = {};\n  var _ModuleRegistry = /*#__PURE__*/function () {\n    \"use strict\";\n\n    function _ModuleRegistry() {\n      _classCallCheck(this, _ModuleRegistry);\n    }\n    return _createClass(_ModuleRegistry, null, [{\n      key: \"module\",\n      value: function module(name) {\n        var m = modules[name];\n        if (m === undefined) {\n          m = {};\n          modules[name] = m;\n        }\n        return m;\n      }\n    }, {\n      key: \"require\",\n      value: function require(m, paths) {\n        var o;\n        paths.forEach(function (path) {\n          o = m.require(path);\n        });\n        return o;\n      }\n    }, {\n      key: \"type\",\n      value: function type(scoped) {\n        if (scoped === undefined) {\n          return undefined;\n        }\n        var components = scoped.split(\".\");\n        var type = modules;\n        for (var i = 0; i < components.length; ++i) {\n          type = type[components[i]];\n          if (type === undefined) {\n            return undefined;\n          }\n        }\n        return type;\n      }\n    }]);\n  }();\n  Ice = _ModuleRegistry.module(\"Ice\");\n  Ice.Slice = Ice.Slice || {};\n  Ice._ModuleRegistry = _ModuleRegistry;\n} else {\n  /* global\n      self : false\n  */\n  var root = typeof window !== \"undefined\" ? window : typeof __webpack_require__.g !== \"undefined\" ? __webpack_require__.g : typeof self !== \"undefined\" ? self : {};\n  /* global\n      self : true\n  */\n  var _ModuleRegistry2 = /*#__PURE__*/function () {\n    \"use strict\";\n\n    function _ModuleRegistry2() {\n      _classCallCheck(this, _ModuleRegistry2);\n    }\n    return _createClass(_ModuleRegistry2, null, [{\n      key: \"module\",\n      value: function module(name) {\n        var m = root[name];\n        if (m === undefined) {\n          m = {};\n          root[name] = m;\n        }\n        return m;\n      }\n    }, {\n      key: \"require\",\n      value: function require(name) {\n        return root;\n      }\n    }, {\n      key: \"type\",\n      value: function type(scoped) {\n        if (scoped === undefined) {\n          return undefined;\n        }\n        var components = scoped.split(\".\");\n        var type = root;\n        for (var i = 0, length = components.length; i < length; ++i) {\n          type = type[components[i]];\n          if (type === undefined) {\n            return undefined;\n          }\n        }\n        return type;\n      }\n    }]);\n  }();\n  Ice = _ModuleRegistry2.module(\"Ice\");\n  Ice._require = function () {\n    return root;\n  };\n  Ice.Slice = Ice.Slice || {};\n  Ice._ModuleRegistry = _ModuleRegistry2;\n}\nexports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/ModuleRegistry.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Object.js":
/*!********************************************!*\
  !*** ./node_modules/ice/src/Ice/Object.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\n//\n// Ice.Object\n//\n// Using IceObject in this file to avoid collisions with the native Object.\n//\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n__webpack_require__(/*! ../Ice/Exception */ \"./node_modules/ice/src/Ice/Exception.js\");\n__webpack_require__(/*! ../Ice/FormatType */ \"./node_modules/ice/src/Ice/FormatType.js\");\n__webpack_require__(/*! ../Ice/OptionalFormat */ \"./node_modules/ice/src/Ice/OptionalFormat.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\nIce.Object = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function _class() {\n    _classCallCheck(this, _class);\n  }\n  return _createClass(_class, [{\n    key: \"ice_isA\",\n    value: function ice_isA(s, current) {\n      return this._iceMostDerivedType()._iceIds.indexOf(s) >= 0;\n    }\n  }, {\n    key: \"ice_ping\",\n    value: function ice_ping(current) {}\n  }, {\n    key: \"ice_ids\",\n    value: function ice_ids(current) {\n      return this._iceMostDerivedType()._iceIds;\n    }\n  }, {\n    key: \"ice_id\",\n    value: function ice_id(current) {\n      return this._iceMostDerivedType()._iceId;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"[object \" + this.ice_id() + \"]\";\n    }\n\n    //\n    // _iceMostDerivedType returns the the most derived Ice generated class. This is\n    // necessary because the user might extend Slice generated classes. The user\n    // class extensions don't have _iceId, _iceIds, etc static members so the implementation\n    // of ice_id and ice_ids would fail trying to access those members of the user\n    // defined class. Instead, ice_id, ice_ids and ice_instanceof call _iceMostDerivedType\n    // to get the most derived Ice class.\n    //\n  }, {\n    key: \"_iceMostDerivedType\",\n    value: function _iceMostDerivedType() {\n      return Ice.Object;\n    }\n\n    //\n    // The default implementation of equals compare references.\n    //\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return this === other;\n    }\n  }], [{\n    key: \"_iceImplements\",\n    get: function get() {\n      return [];\n    }\n  }]);\n}();\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/Object.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/ObjectAdapterF.js":
/*!****************************************************!*\
  !*** ./node_modules/ice/src/Ice/ObjectAdapterF.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `ObjectAdapterF.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nvar _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\nvar Ice = _ModuleRegistry.module(\"Ice\");\nvar Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n/* slice2js browser-bundle-skip */\nexports.Ice = Ice;\n/* slice2js browser-bundle-skip-end */\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/ObjectAdapterF.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/ObjectAdapterFactory.js":
/*!**********************************************************!*\
  !*** ./node_modules/ice/src/Ice/ObjectAdapterFactory.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\");\n__webpack_require__(/*! ../Ice/ObjectAdapterI */ \"./node_modules/ice/src/Ice/ObjectAdapterI.js\");\n__webpack_require__(/*! ../Ice/Promise */ \"./node_modules/ice/src/Ice/Promise.js\");\n__webpack_require__(/*! ../Ice/UUID */ \"./node_modules/ice/src/Ice/UUID.js\");\nvar ObjectAdapterI = Ice.ObjectAdapterI;\nvar _Promise = Ice.Promise;\n\n//\n// Only for use by Instance.\n//\nvar ObjectAdapterFactory = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function ObjectAdapterFactory(instance, communicator) {\n    _classCallCheck(this, ObjectAdapterFactory);\n    this._instance = instance;\n    this._communicator = communicator;\n    this._adapters = [];\n    this._adapterNamesInUse = [];\n    this._shutdownPromise = new _Promise();\n  }\n  return _createClass(ObjectAdapterFactory, [{\n    key: \"shutdown\",\n    value: function shutdown() {\n      var _this = this;\n      //\n      // Ignore shutdown requests if the object adapter factory has\n      // already been shut down.\n      //\n      if (this._instance === null) {\n        return this._shutdownPromise;\n      }\n      this._instance = null;\n      this._communicator = null;\n      _Promise.all(this._adapters.map(function (adapter) {\n        return adapter.deactivate();\n      })).then(function () {\n        return _this._shutdownPromise.resolve();\n      });\n      return this._shutdownPromise;\n    }\n  }, {\n    key: \"waitForShutdown\",\n    value: function waitForShutdown() {\n      var _this2 = this;\n      return this._shutdownPromise.then(function () {\n        return _Promise.all(_this2._adapters.map(function (adapter) {\n          return adapter.waitForDeactivate();\n        }));\n      });\n    }\n  }, {\n    key: \"isShutdown\",\n    value: function isShutdown() {\n      return this._instance === null;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var _this3 = this;\n      return this.waitForShutdown().then(function () {\n        return _Promise.all(_this3._adapters.map(function (adapter) {\n          return adapter.destroy();\n        }));\n      });\n    }\n  }, {\n    key: \"createObjectAdapter\",\n    value: function createObjectAdapter(name, router, promise) {\n      if (this._instance === null) {\n        throw new Ice.ObjectAdapterDeactivatedException();\n      }\n      var adapter = null;\n      try {\n        if (name.length === 0) {\n          adapter = new ObjectAdapterI(this._instance, this._communicator, this, Ice.generateUUID(), null, true, promise);\n        } else {\n          if (this._adapterNamesInUse.indexOf(name) !== -1) {\n            throw new Ice.AlreadyRegisteredException(\"object adapter\", name);\n          }\n          adapter = new ObjectAdapterI(this._instance, this._communicator, this, name, router, false, promise);\n          this._adapterNamesInUse.push(name);\n        }\n        this._adapters.push(adapter);\n      } catch (ex) {\n        promise.reject(ex);\n      }\n    }\n  }, {\n    key: \"removeObjectAdapter\",\n    value: function removeObjectAdapter(adapter) {\n      if (this._instance === null) {\n        return;\n      }\n      var n = this._adapters.indexOf(adapter);\n      if (n !== -1) {\n        this._adapters.splice(n, 1);\n      }\n      n = this._adapterNamesInUse.indexOf(adapter.getName());\n      if (n !== -1) {\n        this._adapterNamesInUse.splice(n, 1);\n      }\n    }\n  }]);\n}();\nIce.ObjectAdapterFactory = ObjectAdapterFactory;\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/ObjectAdapterFactory.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/ObjectAdapterI.js":
/*!****************************************************!*\
  !*** ./node_modules/ice/src/Ice/ObjectAdapterI.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/AsyncResultBase */ \"./node_modules/ice/src/Ice/AsyncResultBase.js\");\n__webpack_require__(/*! ../Ice/Debug */ \"./node_modules/ice/src/Ice/Debug.js\");\n__webpack_require__(/*! ../Ice/Identity */ \"./node_modules/ice/src/Ice/Identity.js\");\n__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\");\n__webpack_require__(/*! ../Ice/Promise */ \"./node_modules/ice/src/Ice/Promise.js\");\n__webpack_require__(/*! ../Ice/PropertyNames */ \"./node_modules/ice/src/Ice/PropertyNames.js\");\n__webpack_require__(/*! ../Ice/Router */ \"./node_modules/ice/src/Ice/Router.js\");\n__webpack_require__(/*! ../Ice/ServantManager */ \"./node_modules/ice/src/Ice/ServantManager.js\");\n__webpack_require__(/*! ../Ice/StringUtil */ \"./node_modules/ice/src/Ice/StringUtil.js\");\n__webpack_require__(/*! ../Ice/Timer */ \"./node_modules/ice/src/Ice/Timer.js\");\n__webpack_require__(/*! ../Ice/UUID */ \"./node_modules/ice/src/Ice/UUID.js\");\nvar ArrayUtil = Ice.ArrayUtil;\nvar AsyncResultBase = Ice.AsyncResultBase;\nvar Debug = Ice.Debug;\nvar Identity = Ice.Identity;\nvar PropertyNames = Ice.PropertyNames;\nvar ServantManager = Ice.ServantManager;\nvar StringUtil = Ice.StringUtil;\nvar Timer = Ice.Timer;\nvar _suffixes = [\"ACM\", \"AdapterId\", \"Endpoints\", \"Locator\", \"Locator.EncodingVersion\", \"Locator.EndpointSelection\", \"Locator.ConnectionCached\", \"Locator.PreferSecure\", \"Locator.CollocationOptimized\", \"Locator.Router\", \"MessageSizeMax\", \"PublishedEndpoints\", \"ReplicaGroupId\", \"Router\", \"Router.EncodingVersion\", \"Router.EndpointSelection\", \"Router.ConnectionCached\", \"Router.PreferSecure\", \"Router.CollocationOptimized\", \"Router.Locator\", \"Router.Locator.EndpointSelection\", \"Router.Locator.ConnectionCached\", \"Router.Locator.PreferSecure\", \"Router.Locator.CollocationOptimized\", \"Router.Locator.LocatorCacheTimeout\", \"Router.Locator.InvocationTimeout\", \"Router.LocatorCacheTimeout\", \"Router.InvocationTimeout\", \"ProxyOptions\", \"ThreadPool.Size\", \"ThreadPool.SizeMax\", \"ThreadPool.SizeWarn\", \"ThreadPool.StackSize\", \"ThreadPool.Serialize\"];\nvar StateUninitialized = 0; // Just constructed.\nvar StateHeld = 1;\n// const StateWaitActivate = 2;\nvar StateActive = 3;\n// const StateDeactivating = 4;\nvar StateDeactivated = 5;\nvar StateDestroyed = 6;\n\n//\n// Only for use by IceInternal.ObjectAdapterFactory\n//\nvar ObjectAdapterI = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function ObjectAdapterI(instance, communicator, objectAdapterFactory, name, router, noConfig, promise) {\n    var _this = this;\n    _classCallCheck(this, ObjectAdapterI);\n    this._instance = instance;\n    this._communicator = communicator;\n    this._objectAdapterFactory = objectAdapterFactory;\n    this._servantManager = new ServantManager(instance, name);\n    this._name = name;\n    this._publishedEndpoints = [];\n    this._routerInfo = null;\n    this._state = StateUninitialized;\n    this._noConfig = noConfig;\n    this._statePromises = [];\n    if (this._noConfig) {\n      this._reference = this._instance.referenceFactory().createFromString(\"dummy -t\", \"\");\n      this._messageSizeMax = this._instance.messageSizeMax();\n      promise.resolve(this);\n      return;\n    }\n    var properties = this._instance.initializationData().properties;\n    var unknownProps = [];\n    var noProps = this.filterProperties(unknownProps);\n\n    //\n    // Warn about unknown object adapter properties.\n    //\n    if (unknownProps.length !== 0 && properties.getPropertyAsIntWithDefault(\"Ice.Warn.UnknownProperties\", 1) > 0) {\n      var message = [\"found unknown properties for object adapter `\" + name + \"':\"];\n      unknownProps.forEach(function (unknownProp) {\n        return message.push(\"\\n    \" + unknownProp);\n      });\n      this._instance.initializationData().logger.warning(message.join(\"\"));\n    }\n\n    //\n    // Make sure named adapter has some configuration.\n    //\n    if (router === null && noProps) {\n      throw new Ice.InitializationException(\"object adapter `\".concat(this._name, \"' requires configuration\"));\n    }\n\n    //\n    // Setup a reference to be used to get the default proxy options\n    // when creating new proxies. By default, create twoway proxies.\n    //\n    var proxyOptions = properties.getPropertyWithDefault(this._name + \".ProxyOptions\", \"-t\");\n    try {\n      this._reference = this._instance.referenceFactory().createFromString(\"dummy \" + proxyOptions, \"\");\n    } catch (e) {\n      if (e instanceof Ice.ProxyParseException) {\n        throw new Ice.InitializationException(\"invalid proxy options `\".concat(proxyOptions, \"' for object adapter `\").concat(name, \"'\"));\n      } else {\n        throw e;\n      }\n    }\n    {\n      var defaultMessageSizeMax = this._instance.messageSizeMax() / 1024;\n      var num = properties.getPropertyAsIntWithDefault(this._name + \".MessageSizeMax\", defaultMessageSizeMax);\n      if (num < 1 || num > 0x7fffffff / 1024) {\n        this._messageSizeMax = 0x7fffffff;\n      } else {\n        this._messageSizeMax = num * 1024; // Property is in kilobytes, _messageSizeMax in bytes\n      }\n    }\n    try {\n      if (router === null) {\n        router = Ice.RouterPrx.uncheckedCast(this._instance.proxyFactory().propertyToProxy(this._name + \".Router\"));\n      }\n      var p;\n      if (router !== null) {\n        this._routerInfo = this._instance.routerManager().find(router);\n        Debug.assert(this._routerInfo !== null);\n\n        //\n        // Make sure this router is not already registered with another adapter.\n        //\n        if (this._routerInfo.getAdapter() !== null) {\n          throw new Ice.AlreadyRegisteredException(\"object adapter with router\", Ice.identityToString(router.ice_getIdentity(), this._instance.toStringMode()));\n        }\n\n        //\n        // Associate this object adapter with the router. This way,\n        // new outgoing connections to the router's client proxy will\n        // use this object adapter for callbacks.\n        //\n        this._routerInfo.setAdapter(this);\n\n        //\n        // Also modify all existing outgoing connections to the\n        // router's client proxy to use this object adapter for\n        // callbacks.\n        //\n        p = this._instance.outgoingConnectionFactory().setRouterInfo(this._routerInfo);\n      } else {\n        var endpoints = properties.getProperty(this._name + \".Endpoints\");\n        if (endpoints.length > 0) {\n          throw new Ice.FeatureNotSupportedException(\"object adapter endpoints not supported\");\n        }\n        p = Ice.Promise.resolve();\n      }\n      p.then(function () {\n        return _this.computePublishedEndpoints();\n      }).then(function (endpoints) {\n        _this._publishedEndpoints = endpoints;\n        promise.resolve(_this);\n      }, function (ex) {\n        _this.destroy();\n        promise.reject(ex);\n      });\n    } catch (ex) {\n      this.destroy();\n      throw ex;\n    }\n  }\n  return _createClass(ObjectAdapterI, [{\n    key: \"getName\",\n    value: function getName() {\n      //\n      // No mutex lock necessary, _name is immutable.\n      //\n      return this._noConfig ? \"\" : this._name;\n    }\n  }, {\n    key: \"getCommunicator\",\n    value: function getCommunicator() {\n      return this._communicator;\n    }\n  }, {\n    key: \"activate\",\n    value: function activate() {\n      var promise = new AsyncResultBase(this._communicator, \"activate\", null, null, this);\n      this.setState(StateActive);\n      promise.resolve();\n      return promise;\n    }\n  }, {\n    key: \"hold\",\n    value: function hold() {\n      this.checkForDeactivation();\n      this.setState(StateHeld);\n    }\n  }, {\n    key: \"waitForHold\",\n    value: function waitForHold() {\n      var promise = new AsyncResultBase(this._communicator, \"waitForHold\", null, null, this);\n      try {\n        this.checkForDeactivation();\n        this.waitState(StateHeld, promise);\n      } catch (ex) {\n        promise.reject(ex);\n      }\n      return promise;\n    }\n  }, {\n    key: \"deactivate\",\n    value: function deactivate() {\n      var promise = new AsyncResultBase(this._communicator, \"deactivate\", null, null, this);\n      if (this._state < StateDeactivated) {\n        this.setState(StateDeactivated);\n        this._instance.outgoingConnectionFactory().removeAdapter(this);\n      }\n      promise.resolve();\n      return promise;\n    }\n  }, {\n    key: \"waitForDeactivate\",\n    value: function waitForDeactivate() {\n      var promise = new AsyncResultBase(this._communicator, \"waitForDeactivate\", null, null, this);\n      this.waitState(StateDeactivated, promise);\n      return promise;\n    }\n  }, {\n    key: \"isDeactivated\",\n    value: function isDeactivated() {\n      return this._state >= StateDeactivated;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var _this2 = this;\n      // NOTE: we don't call waitForDeactivate since it's currently a no-op.\n      return this.deactivate().then(function () {\n        if (_this2._state < StateDestroyed) {\n          _this2.setState(StateDestroyed);\n          _this2._servantManager.destroy();\n          _this2._objectAdapterFactory.removeObjectAdapter(_this2);\n          _this2._publishedEndpoints = [];\n        }\n        var promise = new AsyncResultBase(_this2._communicator, \"destroy\", null, null, _this2);\n        promise.resolve();\n        return promise;\n      });\n    }\n  }, {\n    key: \"add\",\n    value: function add(object, ident) {\n      return this.addFacet(object, ident, \"\");\n    }\n  }, {\n    key: \"addFacet\",\n    value: function addFacet(object, ident, facet) {\n      this.checkForDeactivation();\n      this.checkIdentity(ident);\n      this.checkServant(object);\n\n      //\n      // Create a copy of the Identity argument, in case the caller\n      // reuses it.\n      //\n      var id = ident.clone();\n      this._servantManager.addServant(object, id, facet);\n      return this.newProxy(id, facet);\n    }\n  }, {\n    key: \"addWithUUID\",\n    value: function addWithUUID(object) {\n      return this.addFacetWithUUID(object, \"\");\n    }\n  }, {\n    key: \"addFacetWithUUID\",\n    value: function addFacetWithUUID(object, facet) {\n      return this.addFacet(object, new Identity(Ice.generateUUID(), \"\"), facet);\n    }\n  }, {\n    key: \"addDefaultServant\",\n    value: function addDefaultServant(servant, category) {\n      this.checkServant(servant);\n      this.checkForDeactivation();\n      this._servantManager.addDefaultServant(servant, category);\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(ident) {\n      return this.removeFacet(ident, \"\");\n    }\n  }, {\n    key: \"removeFacet\",\n    value: function removeFacet(ident, facet) {\n      this.checkForDeactivation();\n      this.checkIdentity(ident);\n      return this._servantManager.removeServant(ident, facet);\n    }\n  }, {\n    key: \"removeAllFacets\",\n    value: function removeAllFacets(ident) {\n      this.checkForDeactivation();\n      this.checkIdentity(ident);\n      return this._servantManager.removeAllFacets(ident);\n    }\n  }, {\n    key: \"removeDefaultServant\",\n    value: function removeDefaultServant(category) {\n      this.checkForDeactivation();\n      return this._servantManager.removeDefaultServant(category);\n    }\n  }, {\n    key: \"find\",\n    value: function find(ident) {\n      return this.findFacet(ident, \"\");\n    }\n  }, {\n    key: \"findFacet\",\n    value: function findFacet(ident, facet) {\n      this.checkForDeactivation();\n      this.checkIdentity(ident);\n      return this._servantManager.findServant(ident, facet);\n    }\n  }, {\n    key: \"findAllFacets\",\n    value: function findAllFacets(ident) {\n      this.checkForDeactivation();\n      this.checkIdentity(ident);\n      return this._servantManager.findAllFacets(ident);\n    }\n  }, {\n    key: \"findByProxy\",\n    value: function findByProxy(proxy) {\n      this.checkForDeactivation();\n      var ref = proxy._getReference();\n      return this.findFacet(ref.getIdentity(), ref.getFacet());\n    }\n  }, {\n    key: \"findDefaultServant\",\n    value: function findDefaultServant(category) {\n      this.checkForDeactivation();\n      return this._servantManager.findDefaultServant(category);\n    }\n  }, {\n    key: \"addServantLocator\",\n    value: function addServantLocator(locator, prefix) {\n      this.checkForDeactivation();\n      this._servantManager.addServantLocator(locator, prefix);\n    }\n  }, {\n    key: \"removeServantLocator\",\n    value: function removeServantLocator(prefix) {\n      this.checkForDeactivation();\n      return this._servantManager.removeServantLocator(prefix);\n    }\n  }, {\n    key: \"findServantLocator\",\n    value: function findServantLocator(prefix) {\n      this.checkForDeactivation();\n      return this._servantManager.findServantLocator(prefix);\n    }\n  }, {\n    key: \"createProxy\",\n    value: function createProxy(ident) {\n      this.checkForDeactivation();\n      this.checkIdentity(ident);\n      return this.newProxy(ident, \"\");\n    }\n  }, {\n    key: \"createDirectProxy\",\n    value: function createDirectProxy(ident) {\n      return this.createProxy(ident);\n    }\n  }, {\n    key: \"createIndirectProxy\",\n    value: function createIndirectProxy(ident) {\n      throw new Ice.FeatureNotSupportedException(\"createIndirectProxy not supported\");\n    }\n  }, {\n    key: \"setLocator\",\n    value: function setLocator(locator) {\n      throw new Ice.FeatureNotSupportedException(\"setLocator not supported\");\n    }\n  }, {\n    key: \"getEndpoints\",\n    value: function getEndpoints() {\n      return [];\n    }\n  }, {\n    key: \"refreshPublishedEndpoints\",\n    value: function refreshPublishedEndpoints() {\n      var _this3 = this;\n      this.checkForDeactivation();\n      return this.computePublishedEndpoints().then(function (endpoints) {\n        _this3._publishedEndpoints = endpoints;\n      });\n    }\n  }, {\n    key: \"getPublishedEndpoints\",\n    value: function getPublishedEndpoints() {\n      return ArrayUtil.clone(this._publishedEndpoints);\n    }\n  }, {\n    key: \"setPublishedEndpoints\",\n    value: function setPublishedEndpoints(newEndpoints) {\n      this.checkForDeactivation();\n      if (this._routerInfo !== null) {\n        throw new Error(\"can't set published endpoints on object adapter associated with a router\");\n      }\n      this._publishedEndpoints = ArrayUtil.clone(newEndpoints);\n    }\n  }, {\n    key: \"getServantManager\",\n    value: function getServantManager() {\n      //\n      // _servantManager is immutable.\n      //\n      return this._servantManager;\n    }\n  }, {\n    key: \"setAdapterOnConnection\",\n    value: function setAdapterOnConnection(connection) {\n      this.checkForDeactivation();\n      connection.setAdapterAndServantManager(this, this._servantManager);\n    }\n  }, {\n    key: \"messageSizeMax\",\n    value: function messageSizeMax() {\n      return this._messageSizeMax;\n    }\n  }, {\n    key: \"newProxy\",\n    value: function newProxy(ident, facet) {\n      //\n      // Now we also add the endpoints of the router's server proxy, if\n      // any. This way, object references created by this object adapter\n      // will also point to the router's server proxy endpoints.\n      //\n      //\n      // Create a reference and return a proxy for this reference.\n      //\n      return this._instance.proxyFactory().referenceToProxy(this._instance.referenceFactory().create(ident, facet, this._reference, this._publishedEndpoints));\n    }\n  }, {\n    key: \"checkForDeactivation\",\n    value: function checkForDeactivation() {\n      if (this._state >= StateDeactivated) {\n        var ex = new Ice.ObjectAdapterDeactivatedException();\n        ex.name = this.getName();\n        throw ex;\n      }\n    }\n  }, {\n    key: \"checkIdentity\",\n    value: function checkIdentity(ident) {\n      if (ident.name === undefined || ident.name === null || ident.name.length === 0) {\n        throw new Ice.IllegalIdentityException(ident);\n      }\n      if (ident.category === undefined || ident.category === null) {\n        ident.category = \"\";\n      }\n    }\n  }, {\n    key: \"checkServant\",\n    value: function checkServant(servant) {\n      if (servant === undefined || servant === null) {\n        throw new Ice.IllegalServantException(\"cannot add null servant to Object Adapter\");\n      }\n    }\n  }, {\n    key: \"computePublishedEndpoints\",\n    value: function computePublishedEndpoints() {\n      var _this4 = this;\n      var p;\n      if (this._routerInfo !== null) {\n        p = this._routerInfo.getServerEndpoints().then(function (endpts) {\n          //\n          // Remove duplicate endpoints, so we have a list of unique endpoints.\n          //\n          var endpoints = [];\n          endpts.forEach(function (endpoint) {\n            if (endpoints.findIndex(function (value) {\n              return endpoint.equals(value);\n            }) === -1) {\n              endpoints.push(endpoint);\n            }\n          });\n          return endpoints;\n        });\n      } else {\n        //\n        // Parse published endpoints. If set, these are used in proxies\n        // instead of the connection factory Endpoints.\n        //\n        var endpoints = [];\n        var s = this._instance.initializationData().properties.getProperty(this._name + \".PublishedEndpoints\");\n        var delim = \" \\t\\n\\r\";\n        var end = 0;\n        var beg;\n        while (end < s.length) {\n          beg = StringUtil.findFirstNotOf(s, delim, end);\n          if (beg === -1) {\n            if (s != \"\") {\n              throw new Ice.EndpointParseException(\"invalid empty object adapter endpoint\");\n            }\n            break;\n          }\n          end = beg;\n          while (true) {\n            end = s.indexOf(':', end);\n            if (end == -1) {\n              end = s.length;\n              break;\n            } else {\n              var quoted = false;\n              var quote = beg;\n              while (true) {\n                quote = s.indexOf(\"\\\"\", quote);\n                if (quote == -1 || end < quote) {\n                  break;\n                } else {\n                  quote = s.indexOf(\"\\\"\", ++quote);\n                  if (quote == -1) {\n                    break;\n                  } else if (end < quote) {\n                    quoted = true;\n                    break;\n                  }\n                  ++quote;\n                }\n              }\n              if (!quoted) {\n                break;\n              }\n              ++end;\n            }\n          }\n          var es = s.substring(beg, end);\n          var endp = this._instance.endpointFactoryManager().create(es, false);\n          if (endp === null) {\n            throw new Ice.EndpointParseException(\"invalid object adapter endpoint `\" + s + \"'\");\n          }\n          endpoints.push(endp);\n        }\n        p = Ice.Promise.resolve(endpoints);\n      }\n      return p.then(function (endpoints) {\n        if (_this4._instance.traceLevels().network >= 1 && endpoints.length > 0) {\n          var _s = [];\n          _s.push(\"published endpoints for object adapter `\");\n          _s.push(_this4._name);\n          _s.push(\"':\\n\");\n          var first = true;\n          endpoints.forEach(function (endpoint) {\n            if (!first) {\n              _s.push(\":\");\n            }\n            _s.push(endpoint.toString());\n            first = false;\n          });\n          _this4._instance.initializationData().logger.trace(_this4._instance.traceLevels().networkCat, _s.toString());\n        }\n        return endpoints;\n      });\n    }\n  }, {\n    key: \"filterProperties\",\n    value: function filterProperties(unknownProps) {\n      //\n      // Do not create unknown properties list if Ice prefix, i.e., Ice, Glacier2, etc.\n      //\n      var addUnknown = true;\n      var prefix = this._name + \".\";\n      for (var i = 0; i < PropertyNames.clPropNames.length; ++i) {\n        if (prefix.indexOf(PropertyNames.clPropNames[i] + \".\") === 0) {\n          addUnknown = false;\n          break;\n        }\n      }\n      var noProps = true;\n      var props = this._instance.initializationData().properties.getPropertiesForPrefix(prefix);\n      var _iterator = _createForOfIteratorHelper(props.keys()),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var key = _step.value;\n          var valid = false;\n          for (var _i = 0; _i < _suffixes.length; ++_i) {\n            if (key === prefix + _suffixes[_i]) {\n              noProps = false;\n              valid = true;\n              break;\n            }\n          }\n          if (!valid && addUnknown) {\n            unknownProps.push(key);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return noProps;\n    }\n  }, {\n    key: \"setState\",\n    value: function setState(state) {\n      var _this5 = this;\n      if (this._state === state) {\n        return;\n      }\n      this._state = state;\n      var promises = [];\n      (state < StateDeactivated ? [state] : [StateHeld, StateDeactivated]).forEach(function (s) {\n        if (_this5._statePromises[s]) {\n          promises = promises.concat(_this5._statePromises[s]);\n          delete _this5._statePromises[s];\n        }\n      });\n      if (promises.length > 0) {\n        Timer.setImmediate(function () {\n          return promises.forEach(function (p) {\n            return p.resolve();\n          });\n        });\n      }\n    }\n  }, {\n    key: \"waitState\",\n    value: function waitState(state, promise) {\n      if (this._state < StateDeactivated && (state === StateHeld && this._state !== StateHeld || state === StateDeactivated)) {\n        if (this._statePromises[state]) {\n          this._statePromises[state].push(promise);\n        } else {\n          this._statePromises[state] = [promise];\n        }\n      } else {\n        promise.resolve();\n      }\n    }\n  }]);\n}();\nIce.ObjectAdapterI = ObjectAdapterI;\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/ObjectAdapterI.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/ObjectFactory.js":
/*!***************************************************!*\
  !*** ./node_modules/ice/src/Ice/ObjectFactory.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `ObjectFactory.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nvar _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\");\n__webpack_require__(/*! ../Ice/ObjectPrx */ \"./node_modules/ice/src/Ice/ObjectPrx.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\nvar Ice = _ModuleRegistry.module(\"Ice\");\nvar Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n/* slice2js browser-bundle-skip */\nexports.Ice = Ice;\n/* slice2js browser-bundle-skip-end */\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/ObjectFactory.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/ObjectPrx.js":
/*!***********************************************!*\
  !*** ./node_modules/ice/src/Ice/ObjectPrx.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/AsyncResult */ \"./node_modules/ice/src/Ice/AsyncResult.js\");\n__webpack_require__(/*! ../Ice/BuiltinSequences */ \"./node_modules/ice/src/Ice/BuiltinSequences.js\");\n__webpack_require__(/*! ../Ice/Current */ \"./node_modules/ice/src/Ice/Current.js\");\n__webpack_require__(/*! ../Ice/Debug */ \"./node_modules/ice/src/Ice/Debug.js\");\n__webpack_require__(/*! ../Ice/Exception */ \"./node_modules/ice/src/Ice/Exception.js\");\n__webpack_require__(/*! ../Ice/FormatType */ \"./node_modules/ice/src/Ice/FormatType.js\");\n__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\");\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/OutgoingAsync */ \"./node_modules/ice/src/Ice/OutgoingAsync.js\");\n__webpack_require__(/*! ../Ice/ReferenceMode */ \"./node_modules/ice/src/Ice/ReferenceMode.js\");\nvar ArrayUtil = Ice.ArrayUtil;\nvar AsyncResultBase = Ice.AsyncResultBase;\nvar Debug = Ice.Debug;\nvar OutgoingAsync = Ice.OutgoingAsync;\nvar ProxyFlushBatch = Ice.ProxyFlushBatch;\nvar ProxyGetConnection = Ice.ProxyGetConnection;\nvar RefMode = Ice.ReferenceMode;\nvar OperationMode = Ice.OperationMode;\n\n//\n// Ice.ObjectPrx\n//\nvar ObjectPrx = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function ObjectPrx() {\n    _classCallCheck(this, ObjectPrx);\n    this._reference = null;\n    this._requestHandler = null;\n  }\n  return _createClass(ObjectPrx, [{\n    key: \"hashCode\",\n    value: function hashCode(r) {\n      return this._reference.hashCode();\n    }\n  }, {\n    key: \"ice_getCommunicator\",\n    value: function ice_getCommunicator() {\n      return this._reference.getCommunicator();\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this._reference.toString();\n    }\n  }, {\n    key: \"ice_getIdentity\",\n    value: function ice_getIdentity() {\n      return this._reference.getIdentity().clone();\n    }\n  }, {\n    key: \"ice_identity\",\n    value: function ice_identity(newIdentity) {\n      if (newIdentity === undefined || newIdentity === null || newIdentity.name.length === 0) {\n        throw new Ice.IllegalIdentityException();\n      }\n      if (newIdentity.equals(this._reference.getIdentity())) {\n        return this;\n      } else {\n        var proxy = new ObjectPrx();\n        proxy._setup(this._reference.changeIdentity(newIdentity));\n        return proxy;\n      }\n    }\n  }, {\n    key: \"ice_getContext\",\n    value: function ice_getContext() {\n      return new Map(this._reference.getContext());\n    }\n  }, {\n    key: \"ice_context\",\n    value: function ice_context(newContext) {\n      return this._newInstance(this._reference.changeContext(newContext));\n    }\n  }, {\n    key: \"ice_getFacet\",\n    value: function ice_getFacet() {\n      return this._reference.getFacet();\n    }\n  }, {\n    key: \"ice_facet\",\n    value: function ice_facet(newFacet) {\n      if (newFacet === undefined || newFacet === null) {\n        newFacet = \"\";\n      }\n      if (newFacet === this._reference.getFacet()) {\n        return this;\n      } else {\n        var proxy = new ObjectPrx();\n        proxy._setup(this._reference.changeFacet(newFacet));\n        return proxy;\n      }\n    }\n  }, {\n    key: \"ice_getAdapterId\",\n    value: function ice_getAdapterId() {\n      return this._reference.getAdapterId();\n    }\n  }, {\n    key: \"ice_adapterId\",\n    value: function ice_adapterId(newAdapterId) {\n      if (newAdapterId === undefined || newAdapterId === null) {\n        newAdapterId = \"\";\n      }\n      if (newAdapterId === this._reference.getAdapterId()) {\n        return this;\n      } else {\n        return this._newInstance(this._reference.changeAdapterId(newAdapterId));\n      }\n    }\n  }, {\n    key: \"ice_getEndpoints\",\n    value: function ice_getEndpoints() {\n      return ArrayUtil.clone(this._reference.getEndpoints());\n    }\n  }, {\n    key: \"ice_endpoints\",\n    value: function ice_endpoints(newEndpoints) {\n      if (newEndpoints === undefined || newEndpoints === null) {\n        newEndpoints = [];\n      }\n      if (ArrayUtil.equals(newEndpoints, this._reference.getEndpoints())) {\n        return this;\n      } else {\n        return this._newInstance(this._reference.changeEndpoints(newEndpoints));\n      }\n    }\n  }, {\n    key: \"ice_getLocatorCacheTimeout\",\n    value: function ice_getLocatorCacheTimeout() {\n      return this._reference.getLocatorCacheTimeout();\n    }\n  }, {\n    key: \"ice_locatorCacheTimeout\",\n    value: function ice_locatorCacheTimeout(newTimeout) {\n      if (newTimeout < -1) {\n        throw new RangeError(\"invalid value passed to ice_locatorCacheTimeout: \" + newTimeout);\n      }\n      if (newTimeout === this._reference.getLocatorCacheTimeout()) {\n        return this;\n      } else {\n        return this._newInstance(this._reference.changeLocatorCacheTimeout(newTimeout));\n      }\n    }\n  }, {\n    key: \"ice_getInvocationTimeout\",\n    value: function ice_getInvocationTimeout() {\n      return this._reference.getInvocationTimeout();\n    }\n  }, {\n    key: \"ice_invocationTimeout\",\n    value: function ice_invocationTimeout(newTimeout) {\n      if (newTimeout < 1 && newTimeout !== -1) {\n        throw new RangeError(\"invalid value passed to ice_invocationTimeout: \" + newTimeout);\n      }\n      if (newTimeout === this._reference.getInvocationTimeout()) {\n        return this;\n      } else {\n        return this._newInstance(this._reference.changeInvocationTimeout(newTimeout));\n      }\n    }\n  }, {\n    key: \"ice_isConnectionCached\",\n    value: function ice_isConnectionCached() {\n      return this._reference.getCacheConnection();\n    }\n  }, {\n    key: \"ice_connectionCached\",\n    value: function ice_connectionCached(newCache) {\n      if (newCache === this._reference.getCacheConnection()) {\n        return this;\n      } else {\n        return this._newInstance(this._reference.changeCacheConnection(newCache));\n      }\n    }\n  }, {\n    key: \"ice_getEndpointSelection\",\n    value: function ice_getEndpointSelection() {\n      return this._reference.getEndpointSelection();\n    }\n  }, {\n    key: \"ice_endpointSelection\",\n    value: function ice_endpointSelection(newType) {\n      if (newType === this._reference.getEndpointSelection()) {\n        return this;\n      } else {\n        return this._newInstance(this._reference.changeEndpointSelection(newType));\n      }\n    }\n  }, {\n    key: \"ice_isSecure\",\n    value: function ice_isSecure() {\n      return this._reference.getSecure();\n    }\n  }, {\n    key: \"ice_secure\",\n    value: function ice_secure(b) {\n      if (b === this._reference.getSecure()) {\n        return this;\n      } else {\n        return this._newInstance(this._reference.changeSecure(b));\n      }\n    }\n  }, {\n    key: \"ice_getEncodingVersion\",\n    value: function ice_getEncodingVersion() {\n      return this._reference.getEncoding().clone();\n    }\n  }, {\n    key: \"ice_encodingVersion\",\n    value: function ice_encodingVersion(e) {\n      if (e.equals(this._reference.getEncoding())) {\n        return this;\n      } else {\n        return this._newInstance(this._reference.changeEncoding(e));\n      }\n    }\n  }, {\n    key: \"ice_isPreferSecure\",\n    value: function ice_isPreferSecure() {\n      return this._reference.getPreferSecure();\n    }\n  }, {\n    key: \"ice_preferSecure\",\n    value: function ice_preferSecure(b) {\n      if (b === this._reference.getPreferSecure()) {\n        return this;\n      } else {\n        return this._newInstance(this._reference.changePreferSecure(b));\n      }\n    }\n  }, {\n    key: \"ice_getRouter\",\n    value: function ice_getRouter() {\n      var ri = this._reference.getRouterInfo();\n      return ri !== null ? ri.getRouter() : null;\n    }\n  }, {\n    key: \"ice_router\",\n    value: function ice_router(router) {\n      var ref = this._reference.changeRouter(router);\n      if (ref.equals(this._reference)) {\n        return this;\n      } else {\n        return this._newInstance(ref);\n      }\n    }\n  }, {\n    key: \"ice_getLocator\",\n    value: function ice_getLocator() {\n      var ri = this._reference.getLocatorInfo();\n      return ri !== null ? ri.getLocator() : null;\n    }\n  }, {\n    key: \"ice_locator\",\n    value: function ice_locator(locator) {\n      var ref = this._reference.changeLocator(locator);\n      if (ref.equals(this._reference)) {\n        return this;\n      } else {\n        return this._newInstance(ref);\n      }\n    }\n  }, {\n    key: \"ice_isTwoway\",\n    value: function ice_isTwoway() {\n      return this._reference.getMode() === RefMode.ModeTwoway;\n    }\n  }, {\n    key: \"ice_twoway\",\n    value: function ice_twoway() {\n      if (this._reference.getMode() === RefMode.ModeTwoway) {\n        return this;\n      } else {\n        return this._newInstance(this._reference.changeMode(RefMode.ModeTwoway));\n      }\n    }\n  }, {\n    key: \"ice_isOneway\",\n    value: function ice_isOneway() {\n      return this._reference.getMode() === RefMode.ModeOneway;\n    }\n  }, {\n    key: \"ice_oneway\",\n    value: function ice_oneway() {\n      if (this._reference.getMode() === RefMode.ModeOneway) {\n        return this;\n      } else {\n        return this._newInstance(this._reference.changeMode(RefMode.ModeOneway));\n      }\n    }\n  }, {\n    key: \"ice_isBatchOneway\",\n    value: function ice_isBatchOneway() {\n      return this._reference.getMode() === RefMode.ModeBatchOneway;\n    }\n  }, {\n    key: \"ice_batchOneway\",\n    value: function ice_batchOneway() {\n      if (this._reference.getMode() === RefMode.ModeBatchOneway) {\n        return this;\n      } else {\n        return this._newInstance(this._reference.changeMode(RefMode.ModeBatchOneway));\n      }\n    }\n  }, {\n    key: \"ice_isDatagram\",\n    value: function ice_isDatagram() {\n      return this._reference.getMode() === RefMode.ModeDatagram;\n    }\n  }, {\n    key: \"ice_datagram\",\n    value: function ice_datagram() {\n      if (this._reference.getMode() === RefMode.ModeDatagram) {\n        return this;\n      } else {\n        return this._newInstance(this._reference.changeMode(RefMode.ModeDatagram));\n      }\n    }\n  }, {\n    key: \"ice_isBatchDatagram\",\n    value: function ice_isBatchDatagram() {\n      return this._reference.getMode() === RefMode.ModeBatchDatagram;\n    }\n  }, {\n    key: \"ice_batchDatagram\",\n    value: function ice_batchDatagram() {\n      if (this._reference.getMode() === RefMode.ModeBatchDatagram) {\n        return this;\n      } else {\n        return this._newInstance(this._reference.changeMode(RefMode.ModeBatchDatagram));\n      }\n    }\n  }, {\n    key: \"ice_timeout\",\n    value: function ice_timeout(t) {\n      if (t < 1 && t !== -1) {\n        throw new RangeError(\"invalid value passed to ice_timeout: \" + t);\n      }\n      var ref = this._reference.changeTimeout(t);\n      if (ref.equals(this._reference)) {\n        return this;\n      } else {\n        return this._newInstance(ref);\n      }\n    }\n  }, {\n    key: \"ice_getTimeout\",\n    value: function ice_getTimeout() {\n      return this._reference.getTimeout();\n    }\n  }, {\n    key: \"ice_fixed\",\n    value: function ice_fixed(connection) {\n      if (connection === null) {\n        throw new RangeError(\"invalid null connection passed to ice_fixed\");\n      }\n      if (!(connection instanceof Ice.ConnectionI)) {\n        throw new RangeError(\"invalid connection passed to ice_fixed\");\n      }\n      var ref = this._reference.changeConnection(connection);\n      if (ref.equals(this._reference)) {\n        return this;\n      } else {\n        return this._newInstance(ref);\n      }\n    }\n  }, {\n    key: \"ice_isFixed\",\n    value: function ice_isFixed() {\n      return this._reference instanceof Ice.FixedReference;\n    }\n  }, {\n    key: \"ice_getConnectionId\",\n    value: function ice_getConnectionId() {\n      return this._reference.getConnectionId();\n    }\n  }, {\n    key: \"ice_connectionId\",\n    value: function ice_connectionId(id) {\n      var ref = this._reference.changeConnectionId(id);\n      if (ref.equals(this._reference)) {\n        return this;\n      } else {\n        return this._newInstance(ref);\n      }\n    }\n  }, {\n    key: \"ice_getConnection\",\n    value: function ice_getConnection() {\n      var r = new ProxyGetConnection(this, \"ice_getConnection\");\n      try {\n        r.invoke();\n      } catch (ex) {\n        r.abort(ex);\n      }\n      return r;\n    }\n  }, {\n    key: \"ice_getCachedConnection\",\n    value: function ice_getCachedConnection() {\n      return this._requestHandler ? this._requestHandler.getConnection() : null;\n    }\n  }, {\n    key: \"ice_flushBatchRequests\",\n    value: function ice_flushBatchRequests() {\n      var r = new ProxyFlushBatch(this, \"ice_flushBatchRequests\");\n      try {\n        r.invoke();\n      } catch (ex) {\n        r.abort(ex);\n      }\n      return r;\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(r) {\n      if (this === r) {\n        return true;\n      }\n      if (r instanceof ObjectPrx) {\n        return this._reference.equals(r._reference);\n      }\n      return false;\n    }\n  }, {\n    key: \"_write\",\n    value: function _write(os) {\n      this._reference.getIdentity()._write(os);\n      this._reference.streamWrite(os);\n    }\n  }, {\n    key: \"_getReference\",\n    value: function _getReference() {\n      return this._reference;\n    }\n  }, {\n    key: \"_copyFrom\",\n    value: function _copyFrom(from) {\n      Debug.assert(this._reference === null);\n      Debug.assert(this._requestHandler === null);\n      this._reference = from._reference;\n      this._requestHandler = from._requestHandler;\n    }\n  }, {\n    key: \"_handleException\",\n    value: function _handleException(ex, handler, mode, sent, sleep, cnt) {\n      this._updateRequestHandler(handler, null); // Clear the request handler\n\n      //\n      // We only retry local exception, system exceptions aren't retried.\n      //\n      // A CloseConnectionException indicates graceful server shutdown, and is therefore\n      // always repeatable without violating \"at-most-once\". That's because by sending a\n      // close connection message, the server guarantees that all outstanding requests\n      // can safely be repeated.\n      //\n      // An ObjectNotExistException can always be retried as well without violating\n      // \"at-most-once\" (see the implementation of the checkRetryAfterException method\n      //  of the ProxyFactory class for the reasons why it can be useful).\n      //\n      // If the request didn't get sent or if it's non-mutating or idempotent it can\n      // also always be retried if the retry count isn't reached.\n      //\n      if (ex instanceof Ice.LocalException && (!sent || mode == OperationMode.Nonmutating || mode == OperationMode.Idempotent || ex instanceof Ice.CloseConnectionException || ex instanceof Ice.ObjectNotExistException)) {\n        try {\n          return this._reference.getInstance().proxyFactory().checkRetryAfterException(ex, this._reference, sleep, cnt);\n        } catch (exc) {\n          if (exc instanceof Ice.CommunicatorDestroyedException) {\n            //\n            // The communicator is already destroyed, so we cannot retry.\n            //\n            throw ex;\n          } else {\n            throw exc;\n          }\n        }\n      } else {\n        throw ex;\n      }\n    }\n  }, {\n    key: \"_checkAsyncTwowayOnly\",\n    value: function _checkAsyncTwowayOnly(name) {\n      if (!this.ice_isTwoway()) {\n        throw new Ice.TwowayOnlyException(name);\n      }\n    }\n  }, {\n    key: \"_getRequestHandler\",\n    value: function _getRequestHandler() {\n      if (this._reference.getCacheConnection()) {\n        if (this._requestHandler) {\n          return this._requestHandler;\n        }\n      }\n      return this._reference.getRequestHandler(this);\n    }\n  }, {\n    key: \"_getBatchRequestQueue\",\n    value: function _getBatchRequestQueue() {\n      if (!this._batchRequestQueue) {\n        this._batchRequestQueue = this._reference.getBatchRequestQueue();\n      }\n      return this._batchRequestQueue;\n    }\n  }, {\n    key: \"_setRequestHandler\",\n    value: function _setRequestHandler(handler) {\n      if (this._reference.getCacheConnection()) {\n        if (!this._requestHandler) {\n          this._requestHandler = handler;\n        }\n        return this._requestHandler;\n      }\n      return handler;\n    }\n  }, {\n    key: \"_updateRequestHandler\",\n    value: function _updateRequestHandler(previous, handler) {\n      if (this._reference.getCacheConnection() && previous !== null) {\n        if (this._requestHandler && this._requestHandler !== handler) {\n          this._requestHandler = this._requestHandler.update(previous, handler);\n        }\n      }\n    }\n\n    //\n    // Only for use by IceInternal.ProxyFactory\n    //\n  }, {\n    key: \"_setup\",\n    value: function _setup(ref) {\n      Debug.assert(this._reference === null);\n      this._reference = ref;\n    }\n  }, {\n    key: \"_newInstance\",\n    value: function _newInstance(ref) {\n      var proxy = new this.constructor();\n      proxy._setup(ref);\n      return proxy;\n    }\n  }, {\n    key: \"ice_instanceof\",\n    value: function ice_instanceof(T) {\n      if (T) {\n        if (this instanceof T) {\n          return true;\n        }\n        return this.constructor._instanceof(T);\n      }\n      return false;\n    }\n\n    //\n    // Generic invocation for operations that have input parameters.\n    //\n  }], [{\n    key: \"_invoke\",\n    value: function _invoke(p, name, mode, fmt, ctx, marshalFn, unmarshalFn, userEx, args) {\n      var _this = this;\n      if (unmarshalFn !== null || userEx.length > 0) {\n        p._checkAsyncTwowayOnly(name);\n      }\n      var r = new OutgoingAsync(p, name, function (res) {\n        _this._completed(res, unmarshalFn, userEx);\n      });\n      try {\n        r.prepare(name, mode, ctx);\n        if (marshalFn === null) {\n          r.writeEmptyParams();\n        } else {\n          var ostr = r.startWriteParams(fmt);\n          marshalFn(ostr, args);\n          r.endWriteParams();\n        }\n        r.invoke();\n      } catch (ex) {\n        r.abort(ex);\n      }\n      return r;\n    }\n\n    //\n    // Handles the completion of an invocation.\n    //\n  }, {\n    key: \"_completed\",\n    value: function _completed(r, unmarshalFn, userEx) {\n      if (!this._check(r, userEx)) {\n        return;\n      }\n      try {\n        if (unmarshalFn === null) {\n          r.readEmptyParams();\n          r.resolve();\n        } else {\n          r.resolve(unmarshalFn(r));\n        }\n      } catch (ex) {\n        this.dispatchLocalException(r, ex);\n      }\n    }\n\n    //\n    // Handles user exceptions.\n    //\n  }, {\n    key: \"_check\",\n    value: function _check(r, uex) {\n      //\n      // If uex is non-null, it must be an array of exception types.\n      //\n      try {\n        r.throwUserException();\n      } catch (ex) {\n        if (ex instanceof Ice.UserException) {\n          if (uex !== null) {\n            for (var i = 0; i < uex.length; ++i) {\n              if (ex instanceof uex[i]) {\n                r.reject(ex);\n                return false;\n              }\n            }\n          }\n          r.reject(new Ice.UnknownUserException(ex.ice_id()));\n          return false;\n        } else {\n          r.reject(ex);\n          return false;\n        }\n      }\n      return true;\n    }\n  }, {\n    key: \"dispatchLocalException\",\n    value: function dispatchLocalException(r, ex) {\n      r.reject(ex);\n    }\n  }, {\n    key: \"checkedCast\",\n    value: function checkedCast(prx, facet, ctx) {\n      var _this2 = this;\n      var r = null;\n      if (prx === undefined || prx === null) {\n        r = new AsyncResultBase(null, \"checkedCast\", null, null, null);\n        r.resolve(null);\n      } else {\n        if (facet !== undefined) {\n          prx = prx.ice_facet(facet);\n        }\n        r = new AsyncResultBase(prx.ice_getCommunicator(), \"checkedCast\", null, prx, null);\n        prx.ice_isA(this.ice_staticId(), ctx).then(function (ret) {\n          if (ret) {\n            var h = new _this2();\n            h._copyFrom(prx);\n            r.resolve(h);\n          } else {\n            r.resolve(null);\n          }\n        })[\"catch\"](function (ex) {\n          if (ex instanceof Ice.FacetNotExistException) {\n            r.resolve(null);\n          } else {\n            r.reject(ex);\n          }\n        });\n      }\n      return r;\n    }\n  }, {\n    key: \"uncheckedCast\",\n    value: function uncheckedCast(prx, facet) {\n      var r = null;\n      if (prx !== undefined && prx !== null) {\n        r = new this();\n        if (facet !== undefined) {\n          prx = prx.ice_facet(facet);\n        }\n        r._copyFrom(prx);\n      }\n      return r;\n    }\n  }, {\n    key: \"minWireSize\",\n    get: function get() {\n      return 2;\n    }\n  }, {\n    key: \"write\",\n    value: function write(os, v) {\n      os.writeProxy(v);\n    }\n  }, {\n    key: \"read\",\n    value: function read(is) {\n      return is.readProxy(this);\n    }\n  }, {\n    key: \"writeOptional\",\n    value: function writeOptional(os, tag, v) {\n      os.writeOptionalProxy(tag, v);\n    }\n  }, {\n    key: \"readOptional\",\n    value: function readOptional(is, tag) {\n      return is.readOptionalProxy(tag, this);\n    }\n  }, {\n    key: \"_instanceof\",\n    value: function _instanceof(T) {\n      if (T === this) {\n        return true;\n      }\n      for (var i in this._implements) {\n        if (this._implements[i]._instanceof(T)) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }, {\n    key: \"ice_staticId\",\n    value: function ice_staticId() {\n      return this._id;\n    }\n  }, {\n    key: \"_implements\",\n    get: function get() {\n      return [];\n    }\n  }]);\n}();\nIce.ObjectPrx = ObjectPrx;\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/ObjectPrx.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/OpaqueEndpointI.js":
/*!*****************************************************!*\
  !*** ./node_modules/ice/src/Ice/OpaqueEndpointI.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && \"function\" == typeof p ? function (t) { return p.apply(e, t); } : p; }\nfunction _get() { return _get = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }\nfunction _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n__webpack_require__(/*! ../Ice/Base64 */ \"./node_modules/ice/src/Ice/Base64.js\");\n__webpack_require__(/*! ../Ice/Debug */ \"./node_modules/ice/src/Ice/Debug.js\");\n__webpack_require__(/*! ../Ice/EndpointI */ \"./node_modules/ice/src/Ice/EndpointI.js\");\n__webpack_require__(/*! ../Ice/FormatType */ \"./node_modules/ice/src/Ice/FormatType.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\");\n__webpack_require__(/*! ../Ice/StringUtil */ \"./node_modules/ice/src/Ice/StringUtil.js\");\nvar Base64 = Ice.Base64;\nvar Debug = Ice.Debug;\nvar EndpointParseException = Ice.EndpointParseException;\nvar HashUtil = Ice.HashUtil;\nvar StringUtil = Ice.StringUtil;\nvar OpaqueEndpointI = /*#__PURE__*/function (_Ice$EndpointI) {\n  \"use strict\";\n\n  function OpaqueEndpointI(type) {\n    var _this;\n    _classCallCheck(this, OpaqueEndpointI);\n    _this = _callSuper(this, OpaqueEndpointI);\n    _this._rawEncoding = Ice.Encoding_1_0;\n    _this._type = type === undefined ? -1 : type;\n    _this._rawBytes = null;\n    return _this;\n  }\n\n  //\n  // Marshal the endpoint\n  //\n  _inherits(OpaqueEndpointI, _Ice$EndpointI);\n  return _createClass(OpaqueEndpointI, [{\n    key: \"streamWrite\",\n    value: function streamWrite(s) {\n      s.startEncapsulation(this._rawEncoding, Ice.FormatType.DefaultFormat);\n      s.writeBlob(this._rawBytes);\n      s.endEncapsulation();\n    }\n\n    //\n    // Return the endpoint information.\n    //\n  }, {\n    key: \"getInfo\",\n    value: function getInfo() {\n      return new OpaqueEndpointInfoI(null, -1, false, this._rawEncoding, this._rawBytes, this._type);\n    }\n\n    //\n    // Return the endpoint type\n    //\n  }, {\n    key: \"type\",\n    value: function type() {\n      return this._type;\n    }\n  }, {\n    key: \"protocol\",\n    value: function protocol() {\n      return \"opaque\";\n    }\n\n    //\n    // Return the timeout for the endpoint in milliseconds. 0 means\n    // non-blocking, -1 means no timeout.\n    //\n  }, {\n    key: \"timeout\",\n    value: function timeout() {\n      return -1;\n    }\n\n    //\n    // Return a new endpoint with a different timeout value, provided\n    // that timeouts are supported by the endpoint. Otherwise the same\n    // endpoint is returned.\n    //\n  }, {\n    key: \"changeTimeout\",\n    value: function changeTimeout(t) {\n      return this;\n    }\n\n    //\n    // Return a new endpoint with a different connection id.\n    //\n  }, {\n    key: \"changeConnectionId\",\n    value: function changeConnectionId(connectionId) {\n      return this;\n    }\n\n    //\n    // Return true if the endpoints support bzip2 compress, or false\n    // otherwise.\n    //\n  }, {\n    key: \"compress\",\n    value: function compress() {\n      return false;\n    }\n\n    //\n    // Return a new endpoint with a different compression value,\n    // provided that compression is supported by the\n    // endpoint. Otherwise the same endpoint is returned.\n    //\n  }, {\n    key: \"changeCompress\",\n    value: function changeCompress(compress) {\n      return this;\n    }\n\n    //\n    // Return true if the endpoint is datagram-based.\n    //\n  }, {\n    key: \"datagram\",\n    value: function datagram() {\n      return false;\n    }\n\n    //\n    // Return true if the endpoint is secure.\n    //\n  }, {\n    key: \"secure\",\n    value: function secure() {\n      return false;\n    }\n\n    //\n    // Get the encoded endpoint.\n    //\n  }, {\n    key: \"rawBytes\",\n    value: function rawBytes() {\n      return this._rawBytes; // Returns a Uint8Array\n    }\n\n    //\n    // Return a server side transceiver for this endpoint, or null if a\n    // transceiver can only be created by an acceptor. In case a\n    // transceiver is created, this operation also returns a new\n    // \"effective\" endpoint, which might differ from this endpoint,\n    // for example, if a dynamic port number is assigned.\n    //\n  }, {\n    key: \"transceiver\",\n    value: function transceiver(endpoint) {\n      endpoint.value = null;\n      return null;\n    }\n\n    //\n    // Return an acceptor for this endpoint, or null if no acceptors\n    // is available. In case an acceptor is created, this operation\n    // also returns a new \"effective\" endpoint, which might differ\n    // from this endpoint, for example, if a dynamic port number is\n    // assigned.\n    //\n  }, {\n    key: \"acceptor\",\n    value: function acceptor(endpoint, adapterName) {\n      endpoint.value = this;\n      return null;\n    }\n  }, {\n    key: \"connect\",\n    value: function connect() {\n      return null;\n    }\n  }, {\n    key: \"hashCode\",\n    value: function hashCode() {\n      if (this._hashCode === undefined) {\n        var h = 5381;\n        h = HashUtil.addNumber(h, this._type);\n        h = HashUtil.addHashable(h, this._rawEncoding);\n        h = HashUtil.addArray(h, this._rawBytes, HashUtil.addNumber);\n        this._hashCode = h;\n      }\n      return this._hashCode;\n    }\n  }, {\n    key: \"options\",\n    value: function options() {\n      var s = \"\";\n      s += \" -t \" + this._type;\n      s += \" -e \" + Ice.encodingVersionToString(this._rawEncoding);\n      s += \" -v \" + Base64.encode(this._rawBytes);\n      return s;\n    }\n\n    //\n    // Compare endpoints for sorting purposes\n    //\n  }, {\n    key: \"equals\",\n    value: function equals(p) {\n      if (!(p instanceof OpaqueEndpointI)) {\n        return false;\n      }\n      if (this === p) {\n        return true;\n      }\n      if (this._type !== p._type) {\n        return false;\n      }\n      if (!this._rawEncoding.equals(p._rawEncoding)) {\n        return false;\n      }\n      if (this._rawBytes.length !== p._rawBytes.length) {\n        return false;\n      }\n      for (var i = 0; i < this._rawBytes.length; i++) {\n        if (this._rawBytes[i] !== p._rawBytes[i]) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }, {\n    key: \"compareTo\",\n    value: function compareTo(p) {\n      if (this === p) {\n        return 0;\n      }\n      if (p === null) {\n        return 1;\n      }\n      if (!(p instanceof OpaqueEndpointI)) {\n        return this.type() < p.type() ? -1 : 1;\n      }\n      if (this._type < p._type) {\n        return -1;\n      } else if (p._type < this._type) {\n        return 1;\n      }\n      if (this._rawEncoding.major < p._rawEncoding.major) {\n        return -1;\n      } else if (p._rawEncoding.major < this._rawEncoding.major) {\n        return 1;\n      }\n      if (this._rawEncoding.minor < p._rawEncoding.minor) {\n        return -1;\n      } else if (p._rawEncoding.minor < this._rawEncoding.minor) {\n        return 1;\n      }\n      if (this._rawBytes.length < p._rawBytes.length) {\n        return -1;\n      } else if (p._rawBytes.length < this._rawBytes.length) {\n        return 1;\n      }\n      for (var i = 0; i < this._rawBytes.length; i++) {\n        if (this._rawBytes[i] < p._rawBytes[i]) {\n          return -1;\n        } else if (p._rawBytes[i] < this._rawBytes[i]) {\n          return 1;\n        }\n      }\n      return 0;\n    }\n  }, {\n    key: \"checkOption\",\n    value: function checkOption(option, argument, endpoint) {\n      switch (option.charAt(1)) {\n        case 't':\n          {\n            if (this._type > -1) {\n              throw new EndpointParseException(\"multiple -t options in endpoint \" + endpoint);\n            }\n            if (argument === null) {\n              throw new EndpointParseException(\"no argument provided for -t option in endpoint \" + endpoint);\n            }\n            var type;\n            try {\n              type = StringUtil.toInt(argument);\n            } catch (ex) {\n              throw new EndpointParseException(\"invalid type value `\" + argument + \"' in endpoint \" + endpoint);\n            }\n            if (type < 0 || type > 65535) {\n              throw new EndpointParseException(\"type value `\" + argument + \"' out of range in endpoint \" + endpoint);\n            }\n            this._type = type;\n            return true;\n          }\n        case 'v':\n          {\n            if (this._rawBytes) {\n              throw new EndpointParseException(\"multiple -v options in endpoint \" + endpoint);\n            }\n            if (argument === null || argument.length === 0) {\n              throw new EndpointParseException(\"no argument provided for -v option in endpoint \" + endpoint);\n            }\n            for (var i = 0; i < argument.length; ++i) {\n              if (!Base64.isBase64(argument.charAt(i))) {\n                throw new EndpointParseException(\"invalid base64 character `\" + argument.charAt(i) + \"' (ordinal \" + argument.charCodeAt(i) + \") in endpoint \" + endpoint);\n              }\n            }\n            this._rawBytes = Base64.decode(argument);\n            return true;\n          }\n        case 'e':\n          {\n            if (argument === null) {\n              throw new EndpointParseException(\"no argument provided for -e option in endpoint \" + endpoint);\n            }\n            try {\n              this._rawEncoding = Ice.stringToEncodingVersion(argument);\n            } catch (e) {\n              throw new EndpointParseException(\"invalid encoding version `\" + argument + \"' in endpoint \" + endpoint + \":\\n\" + e.str);\n            }\n            return true;\n          }\n        default:\n          {\n            return false;\n          }\n      }\n    }\n  }, {\n    key: \"initWithOptions\",\n    value: function initWithOptions(args) {\n      _superPropGet(OpaqueEndpointI, \"initWithOptions\", this, 3)([args]);\n      Debug.assert(this._rawEncoding);\n      if (this._type < 0) {\n        throw new EndpointParseException(\"no -t option in endpoint `\" + this + \"'\");\n      }\n      if (this._rawBytes === null || this._rawBytes.length === 0) {\n        throw new EndpointParseException(\"no -v option in endpoint `\" + this + \"'\");\n      }\n    }\n  }, {\n    key: \"initWithStream\",\n    value: function initWithStream(s) {\n      this._rawEncoding = s.getEncoding();\n      this._rawBytes = s.readBlob(s.getEncapsulationSize());\n    }\n  }]);\n}(Ice.EndpointI);\nvar OpaqueEndpointInfoI = /*#__PURE__*/function (_Ice$OpaqueEndpointIn) {\n  \"use strict\";\n\n  function OpaqueEndpointInfoI(timeout, compress, rawEncoding, rawBytes, type) {\n    var _this2;\n    _classCallCheck(this, OpaqueEndpointInfoI);\n    _this2 = _callSuper(this, OpaqueEndpointInfoI, [-1, false, rawEncoding, rawBytes]);\n    _this2._type = type;\n    return _this2;\n  }\n  _inherits(OpaqueEndpointInfoI, _Ice$OpaqueEndpointIn);\n  return _createClass(OpaqueEndpointInfoI, [{\n    key: \"type\",\n    value: function type() {\n      return this._type;\n    }\n  }, {\n    key: \"datagram\",\n    value: function datagram() {\n      return false;\n    }\n  }, {\n    key: \"secure\",\n    value: function secure() {\n      return false;\n    }\n  }]);\n}(Ice.OpaqueEndpointInfo);\nIce.OpaqueEndpointI = OpaqueEndpointI;\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/OpaqueEndpointI.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Operation.js":
/*!***********************************************!*\
  !*** ./node_modules/ice/src/Ice/Operation.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\nvar _ModuleRegistry = Ice._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Current */ \"./node_modules/ice/src/Ice/Current.js\");\n__webpack_require__(/*! ../Ice/Exception */ \"./node_modules/ice/src/Ice/Exception.js\");\n__webpack_require__(/*! ../Ice/FormatType */ \"./node_modules/ice/src/Ice/FormatType.js\");\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/ObjectPrx */ \"./node_modules/ice/src/Ice/ObjectPrx.js\");\n__webpack_require__(/*! ../Ice/OptionalFormat */ \"./node_modules/ice/src/Ice/OptionalFormat.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\nvar builtinHelpers = [Ice.ByteHelper, Ice.BoolHelper, Ice.ShortHelper, Ice.IntHelper, Ice.LongHelper, Ice.FloatHelper, Ice.DoubleHelper, Ice.StringHelper, Ice.Value, Ice.ObjectPrx, Ice.Value];\nfunction parseParam(p) {\n  var type = p[0];\n  var t = _typeof(type);\n  if (t === 'number') {\n    type = builtinHelpers[p[0]];\n  } else if (t === 'string') {\n    type = _ModuleRegistry.type(type);\n  }\n  return {\n    type: type,\n    isObject: p[1] === true,\n    tag: p[2] // Optional tag, which may not be present - an undefined tag means \"not optional\".\n  };\n}\n\n//\n// Each operation descriptor is a property. The key is the \"on-the-wire\"\n// name, and the value is an array consisting of the following elements:\n//\n//  0: native method name in case of a keyword conflict (e.g., \"_while\"),\n//     otherwise an empty string\n//  1: mode (undefined == Normal or int)\n//  2: sendMode (undefined == Normal or int)\n//  3: format (undefined == Default or int)\n//  4: return type (undefined if void, or [type, tag])\n//  5: in params (undefined if none, or array of [type, tag])\n//  6: out params (undefined if none, or array of [type, tag])\n//  7: exceptions (undefined if none, or array of types)\n//  8: sends classes (true or undefined)\n//  9: returns classes (true or undefined)\n//\nfunction parseOperation(name, arr) {\n  var r = {};\n  r.name = name;\n  r.servantMethod = arr[0] ? arr[0] : name;\n  r.mode = arr[1] ? Ice.OperationMode.valueOf(arr[1]) : Ice.OperationMode.Normal;\n  r.sendMode = arr[2] ? Ice.OperationMode.valueOf(arr[2]) : Ice.OperationMode.Normal;\n  r.format = arr[3] ? Ice.FormatType.valueOf(arr[3]) : Ice.FormatType.DefaultFormat;\n  var ret;\n  if (arr[4]) {\n    ret = parseParam(arr[4]);\n    ret.pos = 0;\n  }\n  r.returns = ret;\n  var inParams = [];\n  var inParamsOpt = [];\n  if (arr[5]) {\n    for (var i = 0; i < arr[5].length; ++i) {\n      var p = parseParam(arr[5][i]);\n      p.pos = i;\n      inParams.push(p);\n      if (p.tag) {\n        inParamsOpt.push(p);\n      }\n    }\n  }\n  inParamsOpt.sort(function (p1, p2) {\n    return p1.tag - p2.tag;\n  }); // Sort by tag.\n  r.inParams = inParams;\n  r.inParamsOpt = inParamsOpt;\n  var outParams = [];\n  var outParamsOpt = [];\n  if (arr[6]) {\n    var offs = ret ? 1 : 0;\n    for (var _i = 0; _i < arr[6].length; ++_i) {\n      var _p = parseParam(arr[6][_i]);\n      _p.pos = _i + offs;\n      outParams.push(_p);\n      if (_p.tag) {\n        outParamsOpt.push(_p);\n      }\n    }\n  }\n  if (ret && ret.tag) {\n    outParamsOpt.push(ret);\n  }\n  outParamsOpt.sort(function (p1, p2) {\n    return p1.tag - p2.tag;\n  }); // Sort by tag.\n  r.outParams = outParams;\n  r.outParamsOpt = outParamsOpt;\n  var exceptions = [];\n  if (arr[7]) {\n    for (var _i2 = 0; _i2 < arr[7].length; ++_i2) {\n      exceptions.push(arr[7][_i2]);\n    }\n  }\n  r.exceptions = exceptions;\n  r.sendsClasses = arr[8] === true;\n  r.returnsClasses = arr[9] === true;\n  return r;\n}\nvar OpTable = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function OpTable(ops) {\n    _classCallCheck(this, OpTable);\n    this.raw = ops;\n    this.parsed = {};\n  }\n  return _createClass(OpTable, [{\n    key: \"find\",\n    value: function find(name) {\n      //\n      // Check if we've already parsed the operation.\n      //\n      var op = this.parsed[name];\n      if (op === undefined && this.raw[name] !== undefined) {\n        //\n        // We haven't parsed it yet, but we found a match for the name, so parse it now.\n        //\n        op = parseOperation(name, this.raw[name]);\n        this.parsed[name] = op;\n      }\n      return op;\n    }\n  }]);\n}();\nfunction unmarshalParams(is, retvalInfo, allParamInfo, optParamInfo, usesClasses, params, offset) {\n  var readParam = function readParam(p, optional) {\n    if (optional) {\n      if (p.isObject) {\n        is.readOptionalValue(p.tag, function (obj) {\n          params[p.pos + offset] = obj;\n        }, p.type);\n      } else {\n        params[p.pos + offset] = p.type.readOptional(is, p.tag);\n      }\n    } else if (p.isObject) {\n      is.readValue(function (obj) {\n        params[p.pos + offset] = obj;\n      }, p.type);\n    } else {\n      params[p.pos + offset] = p.type.read(is);\n    }\n  };\n\n  //\n  // First read all required params.\n  //\n  for (var i = 0; i < allParamInfo.length; ++i) {\n    if (!allParamInfo[i].tag) {\n      readParam(allParamInfo[i], false);\n    }\n  }\n\n  //\n  // Then read a required return value (if any).\n  //\n  if (retvalInfo) {\n    readParam(retvalInfo, false);\n  }\n\n  //\n  // Then read all optional params.\n  //\n  for (var _i3 = 0; _i3 < optParamInfo.length; ++_i3) {\n    readParam(optParamInfo[_i3], true);\n  }\n  if (usesClasses) {\n    is.readPendingValues();\n  }\n}\nfunction marshalParams(os, params, retvalInfo, paramInfo, optParamInfo, usesClasses) {\n  //\n  // Write the required params.\n  //\n  for (var i = 0; i < paramInfo.length; ++i) {\n    var p = paramInfo[i];\n    if (!p.tag) {\n      p.type.write(os, params[p.pos]);\n    }\n  }\n\n  //\n  // retvalInfo should only be provided if there is a non-void required return value.\n  //\n  if (retvalInfo) {\n    retvalInfo.type.write(os, params[retvalInfo.pos]);\n  }\n\n  //\n  // Write the optional params.\n  //\n  for (var _i4 = 0; _i4 < optParamInfo.length; ++_i4) {\n    var _p2 = optParamInfo[_i4];\n    _p2.type.writeOptional(os, _p2.tag, params[_p2.pos]);\n  }\n  if (usesClasses) {\n    os.writePendingValues();\n  }\n}\nfunction dispatchImpl(servant, op, incomingAsync, current) {\n  //\n  // Check to make sure the servant implements the operation.\n  //\n  var method = servant[op.servantMethod];\n  if (method === undefined || typeof method !== \"function\") {\n    throw new Ice.UnknownException(\"servant for identity \" + current.adapter.getCommunicator().identityToString(current.id) + \" does not define operation `\" + op.servantMethod + \"'\");\n  }\n\n  //\n  // Unmarshal the in params (if any).\n  //\n  var params = [];\n  if (op.inParams.length === 0) {\n    incomingAsync.readEmptyParams();\n  } else {\n    var is = incomingAsync.startReadParams();\n    unmarshalParams(is, undefined, op.inParams, op.inParamsOpt, op.sendsClasses, params, 0);\n    incomingAsync.endReadParams();\n  }\n  params.push(current);\n  incomingAsync.setFormat(op.format);\n  var marshalFn = function marshalFn(params) {\n    var numExpectedResults = op.outParams.length + (op.returns ? 1 : 0);\n    if (numExpectedResults > 1 && !(params instanceof Array)) {\n      throw new Ice.MarshalException(\"operation `\" + op.servantMethod + \"' should return an array\");\n    } else if (numExpectedResults === 1) {\n      params = [params]; // Wrap a single out parameter in an array.\n    }\n    if (op.returns === undefined && op.outParams.length === 0) {\n      if (params && params.length > 0) {\n        throw new Ice.MarshalException(\"operation `\" + op.servantMethod + \"' shouldn't return any value\");\n      } else {\n        incomingAsync.writeEmptyParams();\n      }\n    } else {\n      var retvalInfo;\n      if (op.returns && !op.returns.tag) {\n        retvalInfo = op.returns;\n      }\n      var os = incomingAsync.startWriteParams();\n      marshalParams(os, params, retvalInfo, op.outParams, op.outParamsOpt, op.returnsClasses);\n      incomingAsync.endWriteParams();\n    }\n  };\n  var results = method.apply(servant, params);\n  if (results instanceof Promise) {\n    return results.then(marshalFn);\n  } else {\n    marshalFn(results);\n    return null;\n  }\n}\nfunction getServantMethodFromInterfaces(interfaces, methodName, all) {\n  var method;\n  for (var i = 0; method === undefined && i < interfaces.length; ++i) {\n    var intf = interfaces[i];\n    method = intf[methodName];\n    if (method === undefined) {\n      if (all.indexOf(intf) === -1) {\n        all.push(intf);\n      }\n      if (intf._iceImplements) {\n        method = getServantMethodFromInterfaces(intf._iceImplements, methodName, all);\n      }\n    }\n  }\n  return method;\n}\nvar dispatchPrefix = \"_iceD_\";\nfunction getServantMethod(servantType, name) {\n  //\n  // The dispatch method is named _iceD_<Slice name> and is stored in the type (not the prototype).\n  //\n  var methodName = dispatchPrefix + name;\n\n  //\n  // First check the servant type.\n  //\n  var method = servantType[methodName];\n  var allInterfaces;\n  if (method === undefined) {\n    allInterfaces = [];\n\n    //\n    // Now check the prototypes of the implemented interfaces.\n    //\n    var curr = servantType;\n    while (curr && method === undefined) {\n      if (curr._iceImplements) {\n        method = getServantMethodFromInterfaces(curr._iceImplements, methodName, allInterfaces);\n      }\n      curr = Object.getPrototypeOf(curr);\n    }\n    if (method !== undefined) {\n      //\n      // Add the method to the servant's type.\n      //\n      servantType[methodName] = method;\n    }\n  }\n  if (method === undefined) {\n    //\n    // Next check the op table for the servant's type.\n    //\n    var op;\n    if (servantType._iceOps) {\n      op = servantType._iceOps.find(name);\n    }\n    var source;\n    if (op === undefined) {\n      //\n      // Now check the op tables of the base types.\n      //\n      var parent = Object.getPrototypeOf(servantType);\n      while (op === undefined && parent) {\n        if (parent._iceOps) {\n          if ((op = parent._iceOps.find(name)) !== undefined) {\n            source = parent;\n          }\n        }\n        parent = Object.getPrototypeOf(parent);\n      }\n\n      //\n      // Now check the op tables of all base interfaces.\n      //\n      for (var i = 0; op === undefined && i < allInterfaces.length; ++i) {\n        var intf = allInterfaces[i];\n        if (intf._iceOps) {\n          if ((op = intf._iceOps.find(name)) !== undefined) {\n            source = intf;\n          }\n        }\n      }\n    }\n    if (op !== undefined) {\n      method = function method(servant, incomingAsync, current) {\n        return dispatchImpl(servant, op, incomingAsync, current);\n      };\n\n      //\n      // Add the method to the servant type.\n      //\n      servantType[methodName] = method;\n\n      //\n      // Also add the method to the type in which the operation was found.\n      //\n      if (source) {\n        source[methodName] = method;\n      }\n    }\n  }\n  return method;\n}\nfunction addProxyOperation(proxyType, name, data) {\n  var method = data[0] ? data[0] : name;\n  var op = null;\n  proxyType.prototype[method] = function () {\n    //\n    // Parse the operation data on the first invocation of a proxy method.\n    //\n    if (op === null) {\n      op = parseOperation(name, data);\n    }\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    var ctx = args[op.inParams.length]; // The request context is the last argument (if present).\n\n    var marshalFn = null;\n    if (op.inParams.length > 0) {\n      marshalFn = function marshalFn(os, params) {\n        //\n        // Validate the parameters.\n        //\n        for (var i = 0; i < op.inParams.length; ++i) {\n          var p = op.inParams[i];\n          var v = params[p.pos];\n          if (!p.tag || v !== undefined) {\n            if (typeof p.type.validate === \"function\") {\n              if (!p.type.validate(v)) {\n                throw new Ice.MarshalException(\"invalid value for argument \" + (i + 1) + \" in operation `\" + op.servantMethod + \"'\");\n              }\n            }\n          }\n        }\n        marshalParams(os, params, undefined, op.inParams, op.inParamsOpt, op.sendsClasses);\n      };\n    }\n    var unmarshalFn = null;\n    if (op.returns || op.outParams.length > 0) {\n      unmarshalFn = function unmarshalFn(asyncResult) {\n        //\n        // The results array holds the out parameters in the following format:\n        //\n        // [retval, out1, out2, ..., asyncResult]\n        //\n        var results = [];\n        var is = asyncResult.startReadParams();\n        var retvalInfo;\n        if (op.returns && !op.returns.tag) {\n          retvalInfo = op.returns;\n        }\n        unmarshalParams(is, retvalInfo, op.outParams, op.outParamsOpt, op.returnsClasses, results, 0);\n        asyncResult.endReadParams();\n        return results.length == 1 ? results[0] : results;\n      };\n    }\n    return Ice.ObjectPrx._invoke(this, op.name, op.sendMode, op.format, ctx, marshalFn, unmarshalFn, op.exceptions, Array.prototype.slice.call(args));\n  };\n}\nvar Slice = Ice.Slice;\nSlice.defineOperations = function (classType, proxyType, ids, pos, ops) {\n  if (ops) {\n    classType._iceOps = new OpTable(ops);\n  }\n  classType.prototype._iceDispatch = function (incomingAsync, current) {\n    //\n    // Retrieve the dispatch method for this operation.\n    //\n    var method = getServantMethod(classType, current.operation);\n    if (method === undefined || typeof method !== 'function') {\n      throw new Ice.OperationNotExistException(current.id, current.facet, current.operation);\n    }\n    return method.call(method, this, incomingAsync, current);\n  };\n  classType.prototype._iceMostDerivedType = function () {\n    return classType;\n  };\n  Object.defineProperty(classType, \"_iceIds\", {\n    get: function get() {\n      return ids;\n    }\n  });\n  Object.defineProperty(classType, \"_iceId\", {\n    get: function get() {\n      return ids[pos];\n    }\n  });\n  classType.ice_staticId = function () {\n    return classType._iceId;\n  };\n  if (proxyType !== undefined) {\n    if (ops) {\n      for (var name in ops) {\n        addProxyOperation(proxyType, name, ops[name]);\n      }\n    }\n\n    //\n    // Copy proxy methods from super-interfaces.\n    //\n    if (proxyType._implements) {\n      for (var intf in proxyType._implements) {\n        var proto = proxyType._implements[intf].prototype;\n        for (var f in proto) {\n          if (typeof proto[f] == \"function\" && proxyType.prototype[f] === undefined) {\n            proxyType.prototype[f] = proto[f];\n          }\n        }\n      }\n    }\n    Object.defineProperty(proxyType, \"_id\", {\n      get: function get() {\n        return ids[pos];\n      }\n    });\n  }\n};\n\n//\n// Define the \"built-in\" operations for all Ice objects.\n//\nSlice.defineOperations(Ice.Object, Ice.ObjectPrx, [\"::Ice::Object\"], 0, {\n  ice_ping: [undefined, 1, 1, undefined, undefined, undefined, undefined, undefined],\n  ice_isA: [undefined, 1, 1, undefined, [1], [[7]], undefined, undefined],\n  ice_id: [undefined, 1, 1, undefined, [7], undefined, undefined, undefined],\n  ice_ids: [undefined, 1, 1, undefined, [\"Ice.StringSeqHelper\"], undefined, undefined, undefined]\n});\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/Operation.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/OptionalFormat.js":
/*!****************************************************!*\
  !*** ./node_modules/ice/src/Ice/OptionalFormat.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/EnumBase */ \"./node_modules/ice/src/Ice/EnumBase.js\").Ice);\nIce.OptionalFormat = Ice.Slice.defineEnum([['F1', 0], ['F2', 1], ['F4', 2], ['F8', 3], ['Size', 4], ['VSize', 5], ['FSize', 6], ['Class', 7]]);\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/OptionalFormat.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/OutgoingAsync.js":
/*!***************************************************!*\
  !*** ./node_modules/ice/src/Ice/OutgoingAsync.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && \"function\" == typeof p ? function (t) { return p.apply(e, t); } : p; }\nfunction _get() { return _get = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }\nfunction _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n__webpack_require__(/*! ../Ice/AsyncResult */ \"./node_modules/ice/src/Ice/AsyncResult.js\");\n__webpack_require__(/*! ../Ice/AsyncStatus */ \"./node_modules/ice/src/Ice/AsyncStatus.js\");\n__webpack_require__(/*! ../Ice/BuiltinSequences */ \"./node_modules/ice/src/Ice/BuiltinSequences.js\");\n__webpack_require__(/*! ../Ice/Current */ \"./node_modules/ice/src/Ice/Current.js\");\n__webpack_require__(/*! ../Ice/Debug */ \"./node_modules/ice/src/Ice/Debug.js\");\n__webpack_require__(/*! ../Ice/Exception */ \"./node_modules/ice/src/Ice/Exception.js\");\n__webpack_require__(/*! ../Ice/Identity */ \"./node_modules/ice/src/Ice/Identity.js\");\n__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\");\n__webpack_require__(/*! ../Ice/Protocol */ \"./node_modules/ice/src/Ice/Protocol.js\");\n__webpack_require__(/*! ../Ice/RetryException */ \"./node_modules/ice/src/Ice/RetryException.js\");\n__webpack_require__(/*! ../Ice/Stream */ \"./node_modules/ice/src/Ice/Stream.js\");\nvar AsyncResult = Ice.AsyncResult;\nvar AsyncStatus = Ice.AsyncStatus;\nvar Debug = Ice.Debug;\nvar Identity = Ice.Identity;\nvar InputStream = Ice.InputStream;\nvar OutputStream = Ice.OutputStream;\nvar Protocol = Ice.Protocol;\nvar RetryException = Ice.RetryException;\nvar OutgoingAsyncBase = /*#__PURE__*/function (_AsyncResult) {\n  \"use strict\";\n\n  function OutgoingAsyncBase(communicator, operation, connection, proxy, adapter) {\n    var _this;\n    _classCallCheck(this, OutgoingAsyncBase);\n    _this = _callSuper(this, OutgoingAsyncBase, [communicator, operation, connection, proxy, adapter]);\n    _this._os = new OutputStream(_this._instance, Protocol.currentProtocolEncoding);\n    return _this;\n  }\n  _inherits(OutgoingAsyncBase, _AsyncResult);\n  return _createClass(OutgoingAsyncBase, [{\n    key: \"getOs\",\n    value: function getOs() {\n      return this._os;\n    }\n  }, {\n    key: \"sent\",\n    value: function sent() {\n      this.markSent(true);\n    }\n  }, {\n    key: \"completedEx\",\n    value: function completedEx(ex) {\n      this.markFinishedEx(ex);\n    }\n  }]);\n}(AsyncResult);\nvar ProxyOutgoingAsyncBase = /*#__PURE__*/function (_OutgoingAsyncBase) {\n  \"use strict\";\n\n  function ProxyOutgoingAsyncBase(prx, operation) {\n    var _this2;\n    _classCallCheck(this, ProxyOutgoingAsyncBase);\n    if (prx) {\n      _this2 = _callSuper(this, ProxyOutgoingAsyncBase, [prx.ice_getCommunicator(), operation, null, prx, null]);\n    } else {\n      _this2 = _callSuper(this, ProxyOutgoingAsyncBase);\n    }\n    _this2._mode = null;\n    _this2._cnt = 0;\n    _this2._sent = false;\n    _this2._handler = null;\n    return _assertThisInitialized(_this2);\n  }\n  _inherits(ProxyOutgoingAsyncBase, _OutgoingAsyncBase);\n  return _createClass(ProxyOutgoingAsyncBase, [{\n    key: \"completedEx\",\n    value: function completedEx(ex) {\n      try {\n        this._instance.retryQueue().add(this, this.handleException(ex));\n      } catch (ex) {\n        this.markFinishedEx(ex);\n      }\n    }\n  }, {\n    key: \"retryException\",\n    value: function retryException(ex) {\n      try {\n        this._proxy._updateRequestHandler(this._handler, null); // Clear request handler and always retry.\n        this._instance.retryQueue().add(this, 0);\n      } catch (ex) {\n        this.completedEx(ex);\n      }\n    }\n  }, {\n    key: \"retry\",\n    value: function retry() {\n      this.invokeImpl(false);\n    }\n  }, {\n    key: \"abort\",\n    value: function abort(ex) {\n      this.markFinishedEx(ex);\n    }\n  }, {\n    key: \"invokeImpl\",\n    value: function invokeImpl(userThread) {\n      var _this3 = this;\n      try {\n        if (userThread) {\n          var invocationTimeout = this._proxy._getReference().getInvocationTimeout();\n          if (invocationTimeout > 0) {\n            this._timeoutToken = this._instance.timer().schedule(function () {\n              _this3.cancelWithException(new Ice.InvocationTimeoutException());\n            }, invocationTimeout);\n          }\n        }\n        while (true) {\n          try {\n            this._sent = false;\n            this._handler = this._proxy._getRequestHandler();\n            if ((this._handler.sendAsyncRequest(this) & AsyncStatus.Sent) > 0) {\n              if (userThread) {\n                this._sentSynchronously = true;\n              }\n            }\n            return; // We're done!\n          } catch (ex) {\n            if (ex instanceof RetryException) {\n              // Clear request handler and always retry\n              this._proxy._updateRequestHandler(this._handler, null);\n            } else {\n              var interval = this.handleException(ex);\n              if (interval > 0) {\n                this._instance.retryQueue().add(this, interval);\n                return;\n              }\n            }\n          }\n        }\n      } catch (ex) {\n        this.markFinishedEx(ex);\n      }\n    }\n  }, {\n    key: \"markSent\",\n    value: function markSent(done) {\n      this._sent = true;\n      if (done) {\n        if (this._timeoutToken) {\n          this._instance.timer().cancel(this._timeoutToken);\n        }\n      }\n      _superPropGet(ProxyOutgoingAsyncBase, \"markSent\", this, 1).call(this, done);\n    }\n  }, {\n    key: \"markFinishedEx\",\n    value: function markFinishedEx(ex) {\n      if (this._timeoutToken) {\n        this._instance.timer().cancel(this._timeoutToken);\n      }\n      _superPropGet(ProxyOutgoingAsyncBase, \"markFinishedEx\", this, 1).call(this, ex);\n    }\n  }, {\n    key: \"handleException\",\n    value: function handleException(ex) {\n      var interval = {\n        value: 0\n      };\n      this._cnt = this._proxy._handleException(ex, this._handler, this._mode, this._sent, interval, this._cnt);\n      return interval.value;\n    }\n  }]);\n}(OutgoingAsyncBase);\nvar OutgoingAsync = /*#__PURE__*/function (_ProxyOutgoingAsyncBa) {\n  \"use strict\";\n\n  function OutgoingAsync(prx, operation, completed) {\n    var _this4;\n    _classCallCheck(this, OutgoingAsync);\n    _this4 = _callSuper(this, OutgoingAsync, [prx, operation]);\n    if (prx) {\n      _this4._encoding = Protocol.getCompatibleEncoding(_this4._proxy._getReference().getEncoding());\n      _this4._completed = completed;\n    }\n    return _this4;\n  }\n  _inherits(OutgoingAsync, _ProxyOutgoingAsyncBa);\n  return _createClass(OutgoingAsync, [{\n    key: \"prepare\",\n    value: function prepare(op, mode, ctx) {\n      Protocol.checkSupportedProtocol(Protocol.getCompatibleProtocol(this._proxy._getReference().getProtocol()));\n      this._mode = mode;\n      if (ctx === null) {\n        ctx = OutgoingAsync._emptyContext;\n      }\n      if (this._proxy.ice_isBatchOneway() || this._proxy.ice_isBatchDatagram()) {\n        this._proxy._getBatchRequestQueue().prepareBatchRequest(this._os);\n      } else {\n        this._os.writeBlob(Protocol.requestHdr);\n      }\n      var ref = this._proxy._getReference();\n      ref.getIdentity()._write(this._os);\n\n      //\n      // For compatibility with the old FacetPath.\n      //\n      var facet = ref.getFacet();\n      if (facet === null || facet.length === 0) {\n        Ice.StringSeqHelper.write(this._os, null);\n      } else {\n        Ice.StringSeqHelper.write(this._os, [facet]);\n      }\n      this._os.writeString(this._operation);\n      this._os.writeByte(mode.value);\n      if (ctx !== undefined) {\n        if (ctx !== null && !(ctx instanceof Map)) {\n          throw new RangeError(\"illegal context value, expecting null or Map\");\n        }\n\n        //\n        // Explicit context\n        //\n        Ice.ContextHelper.write(this._os, ctx);\n      } else {\n        //\n        // Implicit context\n        //\n        var implicitContext = ref.getInstance().getImplicitContext();\n        var prxContext = ref.getContext();\n        if (implicitContext === null) {\n          Ice.ContextHelper.write(this._os, prxContext);\n        } else {\n          implicitContext.write(prxContext, this._os);\n        }\n      }\n    }\n  }, {\n    key: \"sent\",\n    value: function sent() {\n      this.markSent(!this._proxy.ice_isTwoway());\n    }\n  }, {\n    key: \"invokeRemote\",\n    value: function invokeRemote(connection, response) {\n      return connection.sendAsyncRequest(this, response, 0);\n    }\n  }, {\n    key: \"abort\",\n    value: function abort(ex) {\n      if (this._proxy.ice_isBatchOneway() || this._proxy.ice_isBatchDatagram()) {\n        this._proxy._getBatchRequestQueue().abortBatchRequest(this._os);\n      }\n      _superPropGet(OutgoingAsync, \"abort\", this, 3)([ex]);\n    }\n  }, {\n    key: \"invoke\",\n    value: function invoke() {\n      if (this._proxy.ice_isBatchOneway() || this._proxy.ice_isBatchDatagram()) {\n        this._sentSynchronously = true;\n        this._proxy._getBatchRequestQueue().finishBatchRequest(this._os, this._proxy, this._operation);\n        this.markFinished(true);\n        return;\n      }\n\n      //\n      // NOTE: invokeImpl doesn't throw so this can be called from the\n      // try block with the catch block calling abort() in case of an\n      // exception.\n      //\n      this.invokeImpl(true); // userThread = true\n    }\n  }, {\n    key: \"completed\",\n    value: function completed(istr) {\n      Debug.assert(this._proxy.ice_isTwoway()); // Can only be called for twoways.\n\n      var replyStatus;\n      try {\n        if (this._is === null)\n          // _is can already be initialized if the invocation is retried\n          {\n            this._is = new InputStream(this._instance, Protocol.currentProtocolEncoding);\n          }\n        this._is.swap(istr);\n        replyStatus = this._is.readByte();\n        switch (replyStatus) {\n          case Protocol.replyOK:\n          case Protocol.replyUserException:\n            {\n              break;\n            }\n          case Protocol.replyObjectNotExist:\n          case Protocol.replyFacetNotExist:\n          case Protocol.replyOperationNotExist:\n            {\n              var id = new Identity();\n              id._read(this._is);\n\n              //\n              // For compatibility with the old FacetPath.\n              //\n              var facetPath = Ice.StringSeqHelper.read(this._is);\n              var facet;\n              if (facetPath.length > 0) {\n                if (facetPath.length > 1) {\n                  throw new Ice.MarshalException();\n                }\n                facet = facetPath[0];\n              } else {\n                facet = \"\";\n              }\n              var operation = this._is.readString();\n              var rfe = null;\n              switch (replyStatus) {\n                case Protocol.replyObjectNotExist:\n                  {\n                    rfe = new Ice.ObjectNotExistException();\n                    break;\n                  }\n                case Protocol.replyFacetNotExist:\n                  {\n                    rfe = new Ice.FacetNotExistException();\n                    break;\n                  }\n                case Protocol.replyOperationNotExist:\n                  {\n                    rfe = new Ice.OperationNotExistException();\n                    break;\n                  }\n                default:\n                  {\n                    Debug.assert(false);\n                    break;\n                  }\n              }\n              rfe.id = id;\n              rfe.facet = facet;\n              rfe.operation = operation;\n              throw rfe;\n            }\n          case Protocol.replyUnknownException:\n          case Protocol.replyUnknownLocalException:\n          case Protocol.replyUnknownUserException:\n            {\n              var unknown = this._is.readString();\n              var ue = null;\n              switch (replyStatus) {\n                case Protocol.replyUnknownException:\n                  {\n                    ue = new Ice.UnknownException();\n                    break;\n                  }\n                case Protocol.replyUnknownLocalException:\n                  {\n                    ue = new Ice.UnknownLocalException();\n                    break;\n                  }\n                case Protocol.replyUnknownUserException:\n                  {\n                    ue = new Ice.UnknownUserException();\n                    break;\n                  }\n                default:\n                  {\n                    Debug.assert(false);\n                    break;\n                  }\n              }\n              ue.unknown = unknown;\n              throw ue;\n            }\n          default:\n            {\n              throw new Ice.UnknownReplyStatusException();\n            }\n        }\n        this.markFinished(replyStatus == Protocol.replyOK, this._completed);\n      } catch (ex) {\n        this.completedEx(ex);\n      }\n    }\n  }, {\n    key: \"startWriteParams\",\n    value: function startWriteParams(format) {\n      this._os.startEncapsulation(this._encoding, format);\n      return this._os;\n    }\n  }, {\n    key: \"endWriteParams\",\n    value: function endWriteParams() {\n      this._os.endEncapsulation();\n    }\n  }, {\n    key: \"writeEmptyParams\",\n    value: function writeEmptyParams() {\n      this._os.writeEmptyEncapsulation(this._encoding);\n    }\n  }, {\n    key: \"startReadParams\",\n    value: function startReadParams() {\n      this._is.startEncapsulation();\n      return this._is;\n    }\n  }, {\n    key: \"endReadParams\",\n    value: function endReadParams() {\n      this._is.endEncapsulation();\n    }\n  }, {\n    key: \"readEmptyParams\",\n    value: function readEmptyParams() {\n      this._is.skipEmptyEncapsulation();\n    }\n  }, {\n    key: \"throwUserException\",\n    value: function throwUserException() {\n      Debug.assert((this._state & AsyncResult.Done) !== 0);\n      if ((this._state & AsyncResult.OK) === 0) {\n        try {\n          this._is.startEncapsulation();\n          this._is.throwException();\n        } catch (ex) {\n          if (ex instanceof Ice.UserException) {\n            this._is.endEncapsulation();\n          }\n          throw ex;\n        }\n      }\n    }\n  }]);\n}(ProxyOutgoingAsyncBase);\nOutgoingAsync._emptyContext = new Map(); // Map<string, string>\nvar ProxyFlushBatch = /*#__PURE__*/function (_ProxyOutgoingAsyncBa2) {\n  \"use strict\";\n\n  function ProxyFlushBatch(prx, operation) {\n    var _this5;\n    _classCallCheck(this, ProxyFlushBatch);\n    _this5 = _callSuper(this, ProxyFlushBatch, [prx, operation]);\n    _this5._batchRequestNum = prx._getBatchRequestQueue().swap(_this5._os);\n    return _this5;\n  }\n  _inherits(ProxyFlushBatch, _ProxyOutgoingAsyncBa2);\n  return _createClass(ProxyFlushBatch, [{\n    key: \"invokeRemote\",\n    value: function invokeRemote(connection, response) {\n      if (this._batchRequestNum === 0) {\n        this.sent();\n        return AsyncStatus.Sent;\n      }\n      return connection.sendAsyncRequest(this, response, this._batchRequestNum);\n    }\n  }, {\n    key: \"invoke\",\n    value: function invoke() {\n      Protocol.checkSupportedProtocol(Protocol.getCompatibleProtocol(this._proxy._getReference().getProtocol()));\n      this.invokeImpl(true); // userThread = true\n    }\n  }]);\n}(ProxyOutgoingAsyncBase);\nvar ProxyGetConnection = /*#__PURE__*/function (_ProxyOutgoingAsyncBa3) {\n  \"use strict\";\n\n  function ProxyGetConnection() {\n    _classCallCheck(this, ProxyGetConnection);\n    return _callSuper(this, ProxyGetConnection, arguments);\n  }\n  _inherits(ProxyGetConnection, _ProxyOutgoingAsyncBa3);\n  return _createClass(ProxyGetConnection, [{\n    key: \"invokeRemote\",\n    value: function invokeRemote(connection, response) {\n      this.markFinished(true, function (r) {\n        return r.resolve(connection);\n      });\n      return AsyncStatus.Sent;\n    }\n  }, {\n    key: \"invoke\",\n    value: function invoke() {\n      this.invokeImpl(true); // userThread = true\n    }\n  }]);\n}(ProxyOutgoingAsyncBase);\nvar ConnectionFlushBatch = /*#__PURE__*/function (_OutgoingAsyncBase2) {\n  \"use strict\";\n\n  function ConnectionFlushBatch(con, communicator, operation) {\n    _classCallCheck(this, ConnectionFlushBatch);\n    return _callSuper(this, ConnectionFlushBatch, [communicator, operation, con, null, null]);\n  }\n  _inherits(ConnectionFlushBatch, _OutgoingAsyncBase2);\n  return _createClass(ConnectionFlushBatch, [{\n    key: \"invoke\",\n    value: function invoke() {\n      try {\n        var batchRequestNum = this._connection.getBatchRequestQueue().swap(this._os);\n        var status;\n        if (batchRequestNum === 0) {\n          this.sent();\n          status = AsyncStatus.Sent;\n        } else {\n          status = this._connection.sendAsyncRequest(this, false, batchRequestNum);\n        }\n        if ((status & AsyncStatus.Sent) > 0) {\n          this._sentSynchronously = true;\n        }\n      } catch (ex) {\n        this.completedEx(ex);\n      }\n    }\n  }]);\n}(OutgoingAsyncBase);\nvar HeartbeatAsync = /*#__PURE__*/function (_OutgoingAsyncBase3) {\n  \"use strict\";\n\n  function HeartbeatAsync(con, communicator) {\n    _classCallCheck(this, HeartbeatAsync);\n    return _callSuper(this, HeartbeatAsync, [communicator, \"heartbeat\", con, null, null]);\n  }\n  _inherits(HeartbeatAsync, _OutgoingAsyncBase3);\n  return _createClass(HeartbeatAsync, [{\n    key: \"invoke\",\n    value: function invoke() {\n      try {\n        this._os.writeBlob(Protocol.magic);\n        Protocol.currentProtocol._write(this._os);\n        Protocol.currentProtocolEncoding._write(this._os);\n        this._os.writeByte(Protocol.validateConnectionMsg);\n        this._os.writeByte(0);\n        this._os.writeInt(Protocol.headerSize); // Message size.\n\n        var status = this._connection.sendAsyncRequest(this, false, 0);\n        if ((status & AsyncStatus.Sent) > 0) {\n          this._sentSynchronously = true;\n        }\n      } catch (ex) {\n        this.completedEx(ex);\n      }\n    }\n  }]);\n}(OutgoingAsyncBase);\nIce.OutgoingAsync = OutgoingAsync;\nIce.ProxyFlushBatch = ProxyFlushBatch;\nIce.ProxyGetConnection = ProxyGetConnection;\nIce.ConnectionFlushBatch = ConnectionFlushBatch;\nIce.HeartbeatAsync = HeartbeatAsync;\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/OutgoingAsync.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/OutgoingConnectionFactory.js":
/*!***************************************************************!*\
  !*** ./node_modules/ice/src/Ice/OutgoingConnectionFactory.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && \"function\" == typeof p ? function (t) { return p.apply(e, t); } : p; }\nfunction _get() { return _get = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }\nfunction _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n__webpack_require__(/*! ../Ice/ACM */ \"./node_modules/ice/src/Ice/ACM.js\");\n__webpack_require__(/*! ../Ice/AsyncResultBase */ \"./node_modules/ice/src/Ice/AsyncResultBase.js\");\n__webpack_require__(/*! ../Ice/ConnectionI */ \"./node_modules/ice/src/Ice/ConnectionI.js\");\n__webpack_require__(/*! ../Ice/Debug */ \"./node_modules/ice/src/Ice/Debug.js\");\n__webpack_require__(/*! ../Ice/EndpointTypes */ \"./node_modules/ice/src/Ice/EndpointTypes.js\");\n__webpack_require__(/*! ../Ice/Exception */ \"./node_modules/ice/src/Ice/Exception.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\");\n__webpack_require__(/*! ../Ice/Promise */ \"./node_modules/ice/src/Ice/Promise.js\");\nvar AsyncResultBase = Ice.AsyncResultBase;\nvar ConnectionI = Ice.ConnectionI;\nvar Debug = Ice.Debug;\nvar FactoryACMMonitor = Ice.FactoryACMMonitor;\nvar HashMap = Ice.HashMap;\n\n//\n// Only for use by Instance.\n//\nvar OutgoingConnectionFactory = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function OutgoingConnectionFactory(communicator, instance) {\n    _classCallCheck(this, OutgoingConnectionFactory);\n    this._communicator = communicator;\n    this._instance = instance;\n    this._destroyed = false;\n    this._monitor = new FactoryACMMonitor(this._instance, this._instance.clientACM());\n    this._connectionsByEndpoint = new ConnectionListMap(); // map<EndpointI, Array<Ice.ConnectionI>>\n    this._pending = new HashMap(HashMap.compareEquals); // map<EndpointI, Array<ConnectCallback>>\n    this._pendingConnectCount = 0;\n    this._waitPromise = null;\n  }\n  return _createClass(OutgoingConnectionFactory, [{\n    key: \"destroy\",\n    value: function destroy() {\n      if (this._destroyed) {\n        return;\n      }\n      this._connectionsByEndpoint.forEach(function (connection) {\n        return connection.destroy(ConnectionI.CommunicatorDestroyed);\n      });\n      this._destroyed = true;\n      this._communicator = null;\n      this.checkFinished();\n    }\n  }, {\n    key: \"waitUntilFinished\",\n    value: function waitUntilFinished() {\n      this._waitPromise = new Ice.Promise();\n      this.checkFinished();\n      return this._waitPromise;\n    }\n\n    //\n    // Returns a promise, success callback receives the connection\n    //\n  }, {\n    key: \"create\",\n    value: function create(endpts, hasMore, selType) {\n      Debug.assert(endpts.length > 0);\n\n      //\n      // Apply the overrides.\n      //\n      var endpoints = this.applyOverrides(endpts);\n\n      //\n      // Try to find a connection to one of the given endpoints.\n      //\n      try {\n        var connection = this.findConnectionByEndpoint(endpoints);\n        if (connection !== null) {\n          return Ice.Promise.resolve(connection);\n        }\n      } catch (ex) {\n        return Ice.Promise.reject(ex);\n      }\n      return new ConnectCallback(this, endpoints, hasMore, selType).start();\n    }\n  }, {\n    key: \"setRouterInfo\",\n    value: function setRouterInfo(routerInfo) {\n      var _this = this;\n      return Ice.Promise[\"try\"](function () {\n        if (_this._destroyed) {\n          throw new Ice.CommunicatorDestroyedException();\n        }\n        return routerInfo.getClientEndpoints();\n      }).then(function (endpoints) {\n        //\n        // Search for connections to the router's client proxy\n        // endpoints, and update the object adapter for such\n        // connections, so that callbacks from the router can be\n        // received over such connections.\n        //\n        var adapter = routerInfo.getAdapter();\n        var defaultsAndOverrides = _this._instance.defaultsAndOverrides();\n        endpoints.forEach(function (endpoint) {\n          //\n          // Modify endpoints with overrides.\n          //\n          if (defaultsAndOverrides.overrideTimeout) {\n            endpoint = endpoint.changeTimeout(defaultsAndOverrides.overrideTimeoutValue);\n          }\n\n          //\n          // The Connection object does not take the compression flag of\n          // endpoints into account, but instead gets the information\n          // about whether messages should be compressed or not from\n          // other sources. In order to allow connection sharing for\n          // endpoints that differ in the value of the compression flag\n          // only, we always set the compression flag to false here in\n          // this connection factory.\n          //\n          endpoint = endpoint.changeCompress(false);\n          _this._connectionsByEndpoint.forEach(function (connection) {\n            if (connection.endpoint().equals(endpoint)) {\n              connection.setAdapter(adapter);\n            }\n          });\n        });\n      });\n    }\n  }, {\n    key: \"removeAdapter\",\n    value: function removeAdapter(adapter) {\n      if (this._destroyed) {\n        return;\n      }\n      this._connectionsByEndpoint.forEach(function (connection) {\n        if (connection.getAdapter() === adapter) {\n          connection.setAdapter(null);\n        }\n      });\n    }\n  }, {\n    key: \"flushAsyncBatchRequests\",\n    value: function flushAsyncBatchRequests() {\n      var promise = new AsyncResultBase(this._communicator, \"flushBatchRequests\", null, null, null);\n      if (this._destroyed) {\n        promise.resolve();\n        return promise;\n      }\n      Ice.Promise.all(this._connectionsByEndpoint.map(function (connection) {\n        if (connection.isActiveOrHolding()) {\n          return connection.flushBatchRequests()[\"catch\"](function (ex) {\n            if (ex instanceof Ice.LocalException) {\n              // Ignore\n            } else {\n              throw ex;\n            }\n          });\n        }\n      })).then(promise.resolve, promise.reject);\n      return promise;\n    }\n  }, {\n    key: \"applyOverrides\",\n    value: function applyOverrides(endpts) {\n      var defaultsAndOverrides = this._instance.defaultsAndOverrides();\n      return endpts.map(function (endpoint) {\n        if (defaultsAndOverrides.overrideTimeout) {\n          return endpoint.changeTimeout(defaultsAndOverrides.overrideTimeoutValue);\n        } else {\n          return endpoint;\n        }\n      });\n    }\n  }, {\n    key: \"findConnectionByEndpoint\",\n    value: function findConnectionByEndpoint(endpoints) {\n      if (this._destroyed) {\n        throw new Ice.CommunicatorDestroyedException();\n      }\n      Debug.assert(endpoints.length > 0);\n      for (var i = 0; i < endpoints.length; ++i) {\n        var endpoint = endpoints[i];\n        if (this._pending.has(endpoint)) {\n          continue;\n        }\n        var connectionList = this._connectionsByEndpoint.get(endpoint);\n        if (connectionList === undefined) {\n          continue;\n        }\n        for (var j = 0; j < connectionList.length; ++j) {\n          if (connectionList[j].isActiveOrHolding())\n            // Don't return destroyed or un-validated connections\n            {\n              return connectionList[j];\n            }\n        }\n      }\n      return null;\n    }\n  }, {\n    key: \"incPendingConnectCount\",\n    value: function incPendingConnectCount() {\n      //\n      // Keep track of the number of pending connects. The outgoing connection factory\n      // waitUntilFinished() method waits for all the pending connects to terminate before\n      // to return. This ensures that the communicator client thread pool isn't destroyed\n      // too soon and will still be available to execute the ice_exception() callbacks for\n      // the asynchronous requests waiting on a connection to be established.\n      //\n\n      if (this._destroyed) {\n        throw new Ice.CommunicatorDestroyedException();\n      }\n      ++this._pendingConnectCount;\n    }\n  }, {\n    key: \"decPendingConnectCount\",\n    value: function decPendingConnectCount() {\n      --this._pendingConnectCount;\n      Debug.assert(this._pendingConnectCount >= 0);\n      if (this._destroyed && this._pendingConnectCount === 0) {\n        this.checkFinished();\n      }\n    }\n  }, {\n    key: \"getConnection\",\n    value: function getConnection(endpoints, cb) {\n      var _this2 = this;\n      if (this._destroyed) {\n        throw new Ice.CommunicatorDestroyedException();\n      }\n\n      //\n      // Reap closed connections\n      //\n      var cons = this._monitor.swapReapedConnections();\n      if (cons !== null) {\n        cons.forEach(function (c) {\n          _this2._connectionsByEndpoint.removeConnection(c.endpoint(), c);\n          _this2._connectionsByEndpoint.removeConnection(c.endpoint().changeCompress(true), c);\n        });\n      }\n\n      //\n      // Try to get the connection.\n      //\n      while (true) {\n        if (this._destroyed) {\n          throw new Ice.CommunicatorDestroyedException();\n        }\n\n        //\n        // Search for a matching connection. If we find one, we're done.\n        //\n        var connection = this.findConnectionByEndpoint(endpoints);\n        if (connection !== null) {\n          return connection;\n        }\n        if (this.addToPending(cb, endpoints)) {\n          //\n          // A connection is already pending.\n          //\n          return null;\n        } else {\n          //\n          // No connection is currently pending to one of our endpoints, so we\n          // get out of this loop and start the connection establishment to one of the\n          // given endpoints.\n          //\n          break;\n        }\n      }\n\n      //\n      // At this point, we're responsible for establishing the connection to one of\n      // the given endpoints. If it's a non-blocking connect, calling nextEndpoint\n      // will start the connection establishment. Otherwise, we return null to get\n      // the caller to establish the connection.\n      //\n      cb.nextEndpoint();\n      return null;\n    }\n  }, {\n    key: \"createConnection\",\n    value: function createConnection(transceiver, endpoint) {\n      Debug.assert(this._pending.has(endpoint) && transceiver !== null);\n\n      //\n      // Create and add the connection to the connection map. Adding the connection to the map\n      // is necessary to support the interruption of the connection initialization and validation\n      // in case the communicator is destroyed.\n      //\n      var connection = null;\n      try {\n        if (this._destroyed) {\n          throw new Ice.CommunicatorDestroyedException();\n        }\n        connection = new ConnectionI(this._communicator, this._instance, this._monitor, transceiver, endpoint.changeCompress(false), false, null);\n      } catch (ex) {\n        if (ex instanceof Ice.LocalException) {\n          try {\n            transceiver.close();\n          } catch (exc) {\n            // Ignore\n          }\n        }\n        throw ex;\n      }\n      this._connectionsByEndpoint.set(connection.endpoint(), connection);\n      this._connectionsByEndpoint.set(connection.endpoint().changeCompress(true), connection);\n      return connection;\n    }\n  }, {\n    key: \"finishGetConnection\",\n    value: function finishGetConnection(endpoints, endpoint, connection, cb) {\n      var _this3 = this;\n      // cb is-a ConnectCallback\n\n      var connectionCallbacks = [];\n      if (cb !== null) {\n        connectionCallbacks.push(cb);\n      }\n      var callbacks = [];\n      endpoints.forEach(function (endpt) {\n        var cbs = _this3._pending.get(endpt);\n        if (cbs !== undefined) {\n          _this3._pending[\"delete\"](endpt);\n          cbs.forEach(function (cc) {\n            if (cc.hasEndpoint(endpoint)) {\n              if (connectionCallbacks.indexOf(cc) === -1) {\n                connectionCallbacks.push(cc);\n              }\n            } else if (callbacks.indexOf(cc) === -1) {\n              callbacks.push(cc);\n            }\n          });\n        }\n      });\n      connectionCallbacks.forEach(function (cc) {\n        cc.removeFromPending();\n        var idx = callbacks.indexOf(cc);\n        if (idx !== -1) {\n          callbacks.splice(idx, 1);\n        }\n      });\n      callbacks.forEach(function (cc) {\n        return cc.removeFromPending();\n      });\n      callbacks.forEach(function (cc) {\n        return cc.getConnection();\n      });\n      connectionCallbacks.forEach(function (cc) {\n        return cc.setConnection(connection);\n      });\n      this.checkFinished();\n    }\n  }, {\n    key: \"finishGetConnectionEx\",\n    value: function finishGetConnectionEx(endpoints, ex, cb) {\n      var _this4 = this;\n      // cb is-a ConnectCallback\n\n      var failedCallbacks = [];\n      if (cb !== null) {\n        failedCallbacks.push(cb);\n      }\n      var callbacks = [];\n      endpoints.forEach(function (endpt) {\n        var cbs = _this4._pending.get(endpt);\n        if (cbs !== undefined) {\n          _this4._pending[\"delete\"](endpt);\n          cbs.forEach(function (cc) {\n            if (cc.removeEndpoints(endpoints)) {\n              if (failedCallbacks.indexOf(cc) === -1) {\n                failedCallbacks.push(cc);\n              }\n            } else if (callbacks.indexOf(cc) === -1) {\n              callbacks.push(cc);\n            }\n          });\n        }\n      });\n      callbacks.forEach(function (cc) {\n        Debug.assert(failedCallbacks.indexOf(cc) === -1);\n        cc.removeFromPending();\n      });\n      this.checkFinished();\n      callbacks.forEach(function (cc) {\n        return cc.getConnection();\n      });\n      failedCallbacks.forEach(function (cc) {\n        return cc.setException(ex);\n      });\n    }\n  }, {\n    key: \"addToPending\",\n    value: function addToPending(cb, endpoints) {\n      var _this5 = this;\n      // cb is-a ConnectCallback\n\n      //\n      // Add the callback to each pending list.\n      //\n      var found = false;\n      if (cb !== null) {\n        endpoints.forEach(function (p) {\n          var cbs = _this5._pending.get(p);\n          if (cbs !== undefined) {\n            found = true;\n            if (cbs.indexOf(cb) === -1) {\n              cbs.push(cb); // Add the callback to each pending endpoint.\n            }\n          }\n        });\n      }\n      if (found) {\n        return true;\n      }\n\n      //\n      // If there's no pending connection for the given endpoints, we're\n      // responsible for its establishment. We add empty pending lists,\n      // other callbacks to the same endpoints will be queued.\n      //\n      endpoints.forEach(function (p) {\n        if (!_this5._pending.has(p)) {\n          _this5._pending.set(p, []);\n        }\n      });\n      return false;\n    }\n  }, {\n    key: \"removeFromPending\",\n    value: function removeFromPending(cb, endpoints) {\n      var _this6 = this;\n      // cb is-a ConnectCallback\n      endpoints.forEach(function (p) {\n        var cbs = _this6._pending.get(p);\n        if (cbs !== undefined) {\n          var idx = cbs.indexOf(cb);\n          if (idx !== -1) {\n            cbs.splice(idx, 1);\n          }\n        }\n      });\n    }\n  }, {\n    key: \"handleConnectionException\",\n    value: function handleConnectionException(ex, hasMore) {\n      var traceLevels = this._instance.traceLevels();\n      if (traceLevels.network >= 2) {\n        var s = [];\n        s.push(\"connection to endpoint failed\");\n        if (ex instanceof Ice.CommunicatorDestroyedException) {\n          s.push(\"\\n\");\n        } else if (hasMore) {\n          s.push(\", trying next endpoint\\n\");\n        } else {\n          s.push(\" and no more endpoints to try\\n\");\n        }\n        s.push(ex.toString());\n        this._instance.initializationData().logger.trace(traceLevels.networkCat, s.join(\"\"));\n      }\n    }\n  }, {\n    key: \"handleException\",\n    value: function handleException(ex, hasMore) {\n      var traceLevels = this._instance.traceLevels();\n      if (traceLevels.network >= 2) {\n        var s = [];\n        s.push(\"couldn't resolve endpoint host\");\n        if (ex instanceof Ice.CommunicatorDestroyedException) {\n          s.push(\"\\n\");\n        } else if (hasMore) {\n          s.push(\", trying next endpoint\\n\");\n        } else {\n          s.push(\" and no more endpoints to try\\n\");\n        }\n        s.push(ex.toString());\n        this._instance.initializationData().logger.trace(traceLevels.networkCat, s.join(\"\"));\n      }\n    }\n  }, {\n    key: \"checkFinished\",\n    value: function checkFinished() {\n      var _this7 = this;\n      //\n      // Can't continue until the factory is destroyed and there are no pending connections.\n      //\n      if (!this._waitPromise || !this._destroyed || this._pending.size > 0 || this._pendingConnectCount > 0) {\n        return;\n      }\n      Ice.Promise.all(this._connectionsByEndpoint.map(function (connection) {\n        return connection.waitUntilFinished()[\"catch\"](function (ex) {\n          return Debug.assert(false);\n        });\n      })).then(function () {\n        var cons = _this7._monitor.swapReapedConnections();\n        if (cons !== null) {\n          var arr = [];\n          _this7._connectionsByEndpoint.forEach(function (connection) {\n            if (arr.indexOf(connection) === -1) {\n              arr.push(connection);\n            }\n          });\n          Debug.assert(cons.length === arr.length);\n          _this7._connectionsByEndpoint.clear();\n        } else {\n          Debug.assert(_this7._connectionsByEndpoint.size === 0);\n        }\n        Debug.assert(_this7._waitPromise !== null);\n        _this7._waitPromise.resolve();\n        _this7._monitor.destroy();\n      });\n    }\n  }]);\n}();\nIce.OutgoingConnectionFactory = OutgoingConnectionFactory;\nmodule.exports.Ice = Ice;\n\n//\n// Value is a Vector<Ice.ConnectionI>\n//\nvar ConnectionListMap = /*#__PURE__*/function (_HashMap) {\n  \"use strict\";\n\n  function ConnectionListMap(h) {\n    _classCallCheck(this, ConnectionListMap);\n    return _callSuper(this, ConnectionListMap, [h || HashMap.compareEquals]);\n  }\n  _inherits(ConnectionListMap, _HashMap);\n  return _createClass(ConnectionListMap, [{\n    key: \"set\",\n    value: function set(key, value) {\n      var list = this.get(key);\n      if (list === undefined) {\n        list = [];\n        _superPropGet(ConnectionListMap, \"set\", this, 3)([key, list]);\n      }\n      Debug.assert(value instanceof ConnectionI);\n      list.push(value);\n      return undefined;\n    }\n  }, {\n    key: \"removeConnection\",\n    value: function removeConnection(key, conn) {\n      var list = this.get(key);\n      Debug.assert(list !== null);\n      var idx = list.indexOf(conn);\n      Debug.assert(idx !== -1);\n      list.splice(idx, 1);\n      if (list.length === 0) {\n        this[\"delete\"](key);\n      }\n    }\n  }, {\n    key: \"map\",\n    value: function map(fn) {\n      var arr = [];\n      this.forEach(function (c) {\n        return arr.push(fn(c));\n      });\n      return arr;\n    }\n  }, {\n    key: \"forEach\",\n    value: function forEach(fn) {\n      var _iterator = _createForOfIteratorHelper(this.values()),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var connections = _step.value;\n          connections.forEach(fn);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }]);\n}(HashMap);\nvar ConnectCallback = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function ConnectCallback(f, endpoints, more, selType) {\n    _classCallCheck(this, ConnectCallback);\n    this._factory = f;\n    this._endpoints = endpoints;\n    this._hasMore = more;\n    this._selType = selType;\n    this._promise = new Ice.Promise();\n    this._index = 0;\n    this._current = null;\n  }\n\n  //\n  // Methods from ConnectionI_StartCallback\n  //\n  return _createClass(ConnectCallback, [{\n    key: \"connectionStartCompleted\",\n    value: function connectionStartCompleted(connection) {\n      connection.activate();\n      this._factory.finishGetConnection(this._endpoints, this._current, connection, this);\n    }\n  }, {\n    key: \"connectionStartFailed\",\n    value: function connectionStartFailed(connection, ex) {\n      Debug.assert(this._current !== null);\n      if (this.connectionStartFailedImpl(ex)) {\n        this.nextEndpoint();\n      }\n    }\n  }, {\n    key: \"setConnection\",\n    value: function setConnection(connection) {\n      //\n      // Callback from the factory: the connection to one of the callback\n      // connectors has been established.\n      //\n      this._promise.resolve(connection);\n      this._factory.decPendingConnectCount(); // Must be called last.\n    }\n  }, {\n    key: \"setException\",\n    value: function setException(ex) {\n      //\n      // Callback from the factory: connection establishment failed.\n      //\n      this._promise.reject(ex);\n      this._factory.decPendingConnectCount(); // Must be called last.\n    }\n  }, {\n    key: \"hasEndpoint\",\n    value: function hasEndpoint(endpoint) {\n      return this.findEndpoint(endpoint) !== -1;\n    }\n  }, {\n    key: \"findEndpoint\",\n    value: function findEndpoint(endpoint) {\n      return this._endpoints.findIndex(function (value) {\n        return endpoint.equals(value);\n      });\n    }\n  }, {\n    key: \"removeEndpoints\",\n    value: function removeEndpoints(endpoints) {\n      var _this8 = this;\n      endpoints.forEach(function (endpoint) {\n        var idx = _this8.findEndpoint(endpoint);\n        if (idx !== -1) {\n          _this8._endpoints.splice(idx, 1);\n        }\n      });\n      this._index = 0;\n      return this._endpoints.length === 0;\n    }\n  }, {\n    key: \"removeFromPending\",\n    value: function removeFromPending() {\n      this._factory.removeFromPending(this, this._endpoints);\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      try {\n        //\n        // Notify the factory that there's an async connect pending. This is necessary\n        // to prevent the outgoing connection factory to be destroyed before all the\n        // pending asynchronous connects are finished.\n        //\n        this._factory.incPendingConnectCount();\n      } catch (ex) {\n        this._promise.reject(ex);\n        return;\n      }\n      this.getConnection();\n      return this._promise;\n    }\n  }, {\n    key: \"getConnection\",\n    value: function getConnection() {\n      try {\n        //\n        // Ask the factory to get a connection.\n        //\n        var connection = this._factory.getConnection(this._endpoints, this);\n        if (connection === null) {\n          //\n          // A null return value from getConnection indicates that the connection\n          // is being established and that everthing has been done to ensure that\n          // the callback will be notified when the connection establishment is\n          // done.\n          //\n          return;\n        }\n        this._promise.resolve(connection);\n        this._factory.decPendingConnectCount(); // Must be called last.\n      } catch (ex) {\n        this._promise.reject(ex);\n        this._factory.decPendingConnectCount(); // Must be called last.\n      }\n    }\n  }, {\n    key: \"nextEndpoint\",\n    value: function nextEndpoint() {\n      var _this9 = this;\n      var start = function start(connection) {\n        connection.start().then(function () {\n          _this9.connectionStartCompleted(connection);\n        }, function (ex) {\n          _this9.connectionStartFailed(connection, ex);\n        });\n      };\n      while (true) {\n        var traceLevels = this._factory._instance.traceLevels();\n        try {\n          Debug.assert(this._index < this._endpoints.length);\n          this._current = this._endpoints[this._index++];\n          if (traceLevels.network >= 2) {\n            var s = [];\n            s.push(\"trying to establish \");\n            s.push(this._current.protocol());\n            s.push(\" connection to \");\n            s.push(this._current.toConnectorString());\n            this._factory._instance.initializationData().logger.trace(traceLevels.networkCat, s.join(\"\"));\n          }\n          start(this._factory.createConnection(this._current.connect(), this._current));\n        } catch (ex) {\n          if (traceLevels.network >= 2) {\n            var _s = [];\n            _s.push(\"failed to establish \");\n            _s.push(this._current.protocol());\n            _s.push(\" connection to \");\n            _s.push(this._current.toString());\n            _s.push(\"\\n\");\n            _s.push(ex.toString());\n            this._factory._instance.initializationData().logger.trace(traceLevels.networkCat, _s.join(\"\"));\n          }\n          if (this.connectionStartFailedImpl(ex)) {\n            continue;\n          }\n        }\n        break;\n      }\n    }\n  }, {\n    key: \"connectionStartFailedImpl\",\n    value: function connectionStartFailedImpl(ex) {\n      if (ex instanceof Ice.LocalException) {\n        this._factory.handleConnectionException(ex, this._hasMore || this._index < this._endpoints.length);\n        if (ex instanceof Ice.CommunicatorDestroyedException)\n          // No need to continue.\n          {\n            this._factory.finishGetConnectionEx(this._endpoints, ex, this);\n          } else if (this._index < this._endpoints.length)\n          // Try the next endpoint.\n          {\n            return true;\n          } else {\n          this._factory.finishGetConnectionEx(this._endpoints, ex, this);\n        }\n      } else {\n        this._factory.finishGetConnectionEx(this._endpoints, ex, this);\n      }\n      return false;\n    }\n  }]);\n}();\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/OutgoingConnectionFactory.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/PluginF.js":
/*!*********************************************!*\
  !*** ./node_modules/ice/src/Ice/PluginF.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `PluginF.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nvar _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\nvar Ice = _ModuleRegistry.module(\"Ice\");\nvar Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n/* slice2js browser-bundle-skip */\nexports.Ice = Ice;\n/* slice2js browser-bundle-skip-end */\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/PluginF.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Process.js":
/*!*********************************************!*\
  !*** ./node_modules/ice/src/Ice/Process.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `Process.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nvar _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\");\n__webpack_require__(/*! ../Ice/ObjectPrx */ \"./node_modules/ice/src/Ice/ObjectPrx.js\");\n__webpack_require__(/*! ../Ice/Operation */ \"./node_modules/ice/src/Ice/Operation.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\nvar Ice = _ModuleRegistry.module(\"Ice\");\nvar Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n\nvar iceC_Ice_Process_ids = [\"::Ice::Object\", \"::Ice::Process\"];\n\n/**\n * An administrative interface for process management. Managed servers must\n * implement this interface.\n *\n * <p class=\"Note\">A servant implementing this interface is a potential target\n * for denial-of-service attacks, therefore proper security precautions\n * should be taken. For example, the servant can use a UUID to make its\n * identity harder to guess, and be registered in an object adapter with\n * a secured endpoint.\n *\n **/\nIce.Process = /*#__PURE__*/function (_Ice$Object) {\n  \"use strict\";\n\n  function _class() {\n    _classCallCheck(this, _class);\n    return _callSuper(this, _class, arguments);\n  }\n  _inherits(_class, _Ice$Object);\n  return _createClass(_class);\n}(Ice.Object);\nIce.ProcessPrx = /*#__PURE__*/function (_Ice$ObjectPrx) {\n  \"use strict\";\n\n  function _class2() {\n    _classCallCheck(this, _class2);\n    return _callSuper(this, _class2, arguments);\n  }\n  _inherits(_class2, _Ice$ObjectPrx);\n  return _createClass(_class2);\n}(Ice.ObjectPrx);\nSlice.defineOperations(Ice.Process, Ice.ProcessPrx, iceC_Ice_Process_ids, 1, {\n  \"shutdown\": [,,,,,,,,,],\n  \"writeMessage\": [,,,,, [[7], [3]],,,,]\n});\n/* slice2js browser-bundle-skip */\nexports.Ice = Ice;\n/* slice2js browser-bundle-skip-end */\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/Process.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/ProcessLogger.js":
/*!***************************************************!*\
  !*** ./node_modules/ice/src/Ice/ProcessLogger.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/LoggerI */ \"./node_modules/ice/src/Ice/LoggerI.js\").Ice);\nvar Logger = Ice.Logger;\nvar processLogger = null;\nIce.getProcessLogger = function () {\n  if (processLogger === null) {\n    //\n    // TODO: Would be nice to be able to use process name as prefix by default.\n    //\n    processLogger = new Logger(\"\", \"\");\n  }\n  return processLogger;\n};\nIce.setProcessLogger = function (logger) {\n  processLogger = logger;\n};\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/ProcessLogger.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Promise.js":
/*!*********************************************!*\
  !*** ./node_modules/ice/src/Ice/Promise.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _wrapNativeSuper(t) { var r = \"function\" == typeof Map ? new Map() : void 0; return _wrapNativeSuper = function _wrapNativeSuper(t) { if (null === t || !_isNativeFunction(t)) return t; if (\"function\" != typeof t) throw new TypeError(\"Super expression must either be null or a function\"); if (void 0 !== r) { if (r.has(t)) return r.get(t); r.set(t, Wrapper); } function Wrapper() { return _construct(t, arguments, _getPrototypeOf(this).constructor); } return Wrapper.prototype = Object.create(t.prototype, { constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf(Wrapper, t); }, _wrapNativeSuper(t); }\nfunction _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _isNativeFunction(t) { try { return -1 !== Function.toString.call(t).indexOf(\"[native code]\"); } catch (n) { return \"function\" == typeof t; } }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/Timer */ \"./node_modules/ice/src/Ice/Timer.js\").Ice);\nvar Timer = Ice.Timer;\nvar P = /*#__PURE__*/function (_Promise) {\n  \"use strict\";\n\n  function P(cb) {\n    var _this;\n    _classCallCheck(this, P);\n    var res;\n    var rej;\n    _this = _callSuper(this, P, [function (resolve, reject) {\n      res = resolve;\n      rej = reject;\n      if (cb) {\n        cb(resolve, reject);\n      }\n    }]);\n    _this.resolve = res;\n    _this.reject = rej;\n    return _this;\n  }\n  _inherits(P, _Promise);\n  return _createClass(P, [{\n    key: \"delay\",\n    value: function delay(ms) {\n      return this.then(function (value) {\n        return new P(function (resolve, reject) {\n          return Timer.setTimeout(function () {\n            return resolve(value);\n          }, ms);\n        });\n      }, function (reason) {\n        return new P(function (resolve, reject) {\n          return Timer.setTimeout(function () {\n            return reject(reason);\n          }, ms);\n        });\n      });\n    }\n  }], [{\n    key: Symbol.species,\n    get: function get() {\n      return P;\n    }\n  }, {\n    key: \"delay\",\n    value: function delay(ms, value) {\n      return new P(function (resolve) {\n        return Timer.setTimeout(function () {\n          return resolve(value);\n        }, ms);\n      });\n    }\n  }, {\n    key: \"try\",\n    value: function _try(cb) {\n      return P.resolve().then(cb);\n    }\n  }]);\n}(/*#__PURE__*/_wrapNativeSuper(Promise));\nIce.Promise = P;\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/Promise.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Properties.js":
/*!************************************************!*\
  !*** ./node_modules/ice/src/Ice/Properties.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `Properties.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nvar _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\");\n__webpack_require__(/*! ../Ice/ObjectPrx */ \"./node_modules/ice/src/Ice/ObjectPrx.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\n__webpack_require__(/*! ../Ice/PropertiesAdmin */ \"./node_modules/ice/src/Ice/PropertiesAdmin.js\");\nvar Ice = _ModuleRegistry.module(\"Ice\");\nvar Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n/* slice2js browser-bundle-skip */\nexports.Ice = Ice;\n/* slice2js browser-bundle-skip-end */\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/Properties.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/PropertiesAdmin.js":
/*!*****************************************************!*\
  !*** ./node_modules/ice/src/Ice/PropertiesAdmin.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `PropertiesAdmin.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nvar _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\");\n__webpack_require__(/*! ../Ice/ObjectPrx */ \"./node_modules/ice/src/Ice/ObjectPrx.js\");\n__webpack_require__(/*! ../Ice/Operation */ \"./node_modules/ice/src/Ice/Operation.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\n__webpack_require__(/*! ../Ice/BuiltinSequences */ \"./node_modules/ice/src/Ice/BuiltinSequences.js\");\nvar Ice = _ModuleRegistry.module(\"Ice\");\nvar Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n\nSlice.defineDictionary(Ice, \"PropertyDict\", \"PropertyDictHelper\", \"Ice.StringHelper\", \"Ice.StringHelper\", false, undefined, undefined);\nvar iceC_Ice_PropertiesAdmin_ids = [\"::Ice::Object\", \"::Ice::PropertiesAdmin\"];\n\n/**\n * The PropertiesAdmin interface provides remote access to the properties\n * of a communicator.\n *\n **/\nIce.PropertiesAdmin = /*#__PURE__*/function (_Ice$Object) {\n  \"use strict\";\n\n  function _class() {\n    _classCallCheck(this, _class);\n    return _callSuper(this, _class, arguments);\n  }\n  _inherits(_class, _Ice$Object);\n  return _createClass(_class);\n}(Ice.Object);\nIce.PropertiesAdminPrx = /*#__PURE__*/function (_Ice$ObjectPrx) {\n  \"use strict\";\n\n  function _class2() {\n    _classCallCheck(this, _class2);\n    return _callSuper(this, _class2, arguments);\n  }\n  _inherits(_class2, _Ice$ObjectPrx);\n  return _createClass(_class2);\n}(Ice.ObjectPrx);\nSlice.defineOperations(Ice.PropertiesAdmin, Ice.PropertiesAdminPrx, iceC_Ice_PropertiesAdmin_ids, 1, {\n  \"getProperty\": [,,,, [7], [[7]],,,,],\n  \"getPropertiesForPrefix\": [,,,, [\"Ice.PropertyDictHelper\"], [[7]],,,,],\n  \"setProperties\": [,,,,, [[\"Ice.PropertyDictHelper\"]],,,,]\n});\n/* slice2js browser-bundle-skip */\nexports.Ice = Ice;\n/* slice2js browser-bundle-skip-end */\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/PropertiesAdmin.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/PropertiesI.js":
/*!*************************************************!*\
  !*** ./node_modules/ice/src/Ice/PropertiesI.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n__webpack_require__(/*! ../Ice/Debug */ \"./node_modules/ice/src/Ice/Debug.js\");\n__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\");\n__webpack_require__(/*! ../Ice/ProcessLogger */ \"./node_modules/ice/src/Ice/ProcessLogger.js\");\n__webpack_require__(/*! ../Ice/ProcessLogger */ \"./node_modules/ice/src/Ice/ProcessLogger.js\");\n__webpack_require__(/*! ../Ice/PropertyNames */ \"./node_modules/ice/src/Ice/PropertyNames.js\");\n__webpack_require__(/*! ../Ice/StringUtil */ \"./node_modules/ice/src/Ice/StringUtil.js\");\nvar StringUtil = Ice.StringUtil;\nvar PropertyNames = Ice.PropertyNames;\nvar Debug = Ice.Debug;\nvar getProcessLogger = Ice.getProcessLogger;\nvar InitializationException = Ice.InitializationException;\nvar ParseStateKey = 0;\nvar ParseStateValue = 1;\n//\n// Ice.Properties\n//\nvar Properties = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function Properties(args, defaults) {\n    _classCallCheck(this, Properties);\n    this._properties = new Map();\n    if (defaults !== undefined && defaults !== null) {\n      //\n      // NOTE: we can't just do a shallow copy of the map as the map values\n      // would otherwise be shared between the two PropertiesI object.\n      //\n      var _iterator = _createForOfIteratorHelper(defaults._properties),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _slicedToArray(_step.value, 2),\n            key = _step$value[0],\n            property = _step$value[1];\n          this._properties.set(key, {\n            value: property.value,\n            used: false\n          });\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    if (args !== undefined && args !== null) {\n      var v = this.parseIceCommandLineOptions(args);\n      args.length = 0;\n      for (var i = 0; i < v.length; ++i) {\n        args.push(v[i]);\n      }\n    }\n  }\n  return _createClass(Properties, [{\n    key: \"getProperty\",\n    value: function getProperty(key) {\n      return this.getPropertyWithDefault(key, \"\");\n    }\n  }, {\n    key: \"getPropertyWithDefault\",\n    value: function getPropertyWithDefault(key, value) {\n      var pv = this._properties.get(key);\n      if (pv !== undefined) {\n        pv.used = true;\n        return pv.value;\n      } else {\n        return value;\n      }\n    }\n  }, {\n    key: \"getPropertyAsInt\",\n    value: function getPropertyAsInt(key) {\n      return this.getPropertyAsIntWithDefault(key, 0);\n    }\n  }, {\n    key: \"getPropertyAsIntWithDefault\",\n    value: function getPropertyAsIntWithDefault(key, value) {\n      var pv = this._properties.get(key);\n      if (pv !== undefined) {\n        pv.used = true;\n        return parseInt(pv.value);\n      } else {\n        return value;\n      }\n    }\n  }, {\n    key: \"getPropertyAsList\",\n    value: function getPropertyAsList(key) {\n      return this.getPropertyAsListWithDefault(key, 0);\n    }\n  }, {\n    key: \"getPropertyAsListWithDefault\",\n    value: function getPropertyAsListWithDefault(key, value) {\n      if (value === undefined || value === null) {\n        value = [];\n      }\n      var pv = this._properties.get(key);\n      if (pv !== undefined) {\n        pv.used = true;\n        var result = StringUtil.splitString(pv.value, \", \\t\\r\\n\");\n        if (result === null) {\n          getProcessLogger().warning(\"mismatched quotes in property \" + key + \"'s value, returning default value\");\n          return value;\n        }\n        if (result.length === 0) {\n          result = value;\n        }\n        return result;\n      } else {\n        return value;\n      }\n    }\n  }, {\n    key: \"getPropertiesForPrefix\",\n    value: function getPropertiesForPrefix() {\n      var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n      var result = new Map();\n      this._properties.forEach(function (property, key) {\n        if (key.indexOf(prefix) === 0) {\n          property.used = true;\n          result.set(key, property.value);\n        }\n      });\n      return result;\n    }\n  }, {\n    key: \"setProperty\",\n    value: function setProperty() {\n      var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n      //\n      // Trim whitespace\n      //\n      if (key !== null) {\n        key = key.trim();\n      }\n\n      //\n      // Check if the property is legal.\n      //\n      var logger = getProcessLogger();\n      if (key === null || key.length === 0) {\n        throw new InitializationException(\"Attempt to set property with empty key\");\n      }\n      var dotPos = key.indexOf(\".\");\n      if (dotPos !== -1) {\n        var prefix = key.substr(0, dotPos);\n        for (var i = 0; i < PropertyNames.validProps.length; ++i) {\n          var pattern = PropertyNames.validProps[i][0].pattern;\n          dotPos = pattern.indexOf(\".\");\n          //\n          // Each top level prefix describes a non-empty namespace. Having a string without a\n          // prefix followed by a dot is an error.\n          //\n          Debug.assert(dotPos != -1);\n          if (pattern.substring(0, dotPos - 1) != prefix) {\n            continue;\n          }\n          var found = false;\n          var mismatchCase = false;\n          var otherKey = void 0;\n          for (var j = 0; j < PropertyNames.validProps[i][j].length && !found; ++j) {\n            pattern = PropertyNames.validProps[i][j].pattern();\n            var pComp = new RegExp(pattern);\n            found = pComp.test(key);\n            if (found && PropertyNames.validProps[i][j].deprecated) {\n              logger.warning(\"deprecated property: \" + key);\n              if (PropertyNames.validProps[i][j].deprecatedBy !== null) {\n                key = PropertyNames.validProps[i][j].deprecatedBy;\n              }\n            }\n            if (found) {\n              break;\n            } else {\n              pComp = new RegExp(pattern.toUpperCase());\n              found = pComp.test(key.toUpperCase());\n              if (found) {\n                mismatchCase = true;\n                otherKey = pattern.substr(2);\n                otherKey = otherKey.substr(0, otherKey.length - 1);\n                otherKey = otherKey.replace(/\\\\/g, \"\");\n                break;\n              }\n            }\n          }\n          if (!found) {\n            logger.warning(\"unknown property: \" + key);\n          } else if (mismatchCase) {\n            logger.warning(\"unknown property: `\" + key + \"'; did you mean `\" + otherKey + \"'\");\n          }\n        }\n      }\n\n      //\n      // Set or clear the property.\n      //\n      if (value !== null && value.length > 0) {\n        var pv = this._properties.get(key);\n        if (pv !== undefined) {\n          pv.value = value;\n        } else {\n          this._properties.set(key, {\n            value: value,\n            used: false\n          });\n        }\n      } else {\n        this._properties[\"delete\"](key);\n      }\n    }\n  }, {\n    key: \"getCommandLineOptions\",\n    value: function getCommandLineOptions() {\n      var result = [];\n      this._properties.forEach(function (property, key) {\n        result.push(\"--\" + key + \"=\" + property.value);\n      });\n      return result;\n    }\n  }, {\n    key: \"parseCommandLineOptions\",\n    value: function parseCommandLineOptions(pfx, options) {\n      var _this = this;\n      if (pfx.length > 0 && pfx.charAt(pfx.length - 1) != \".\") {\n        pfx += \".\";\n      }\n      pfx = \"--\" + pfx;\n      var result = [];\n      options.forEach(function (opt) {\n        if (opt.indexOf(pfx) === 0) {\n          if (opt.indexOf('=') === -1) {\n            opt += \"=1\";\n          }\n          _this.parseLine(opt.substring(2));\n        } else {\n          result.push(opt);\n        }\n      });\n      return result;\n    }\n  }, {\n    key: \"parseIceCommandLineOptions\",\n    value: function parseIceCommandLineOptions(options) {\n      var args = options.slice();\n      for (var i = 0; i < PropertyNames.clPropNames.length; ++i) {\n        args = this.parseCommandLineOptions(PropertyNames.clPropNames[i], args);\n      }\n      return args;\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(data) {\n      var _this2 = this;\n      data.match(/[^\\r\\n]+/g).forEach(function (line) {\n        return _this2.parseLine(line);\n      });\n    }\n  }, {\n    key: \"parseLine\",\n    value: function parseLine(line) {\n      var key = \"\";\n      var value = \"\";\n      var state = ParseStateKey;\n      var whitespace = \"\";\n      var escapedspace = \"\";\n      var finished = false;\n      for (var i = 0; i < line.length; ++i) {\n        var c = line.charAt(i);\n        switch (state) {\n          case ParseStateKey:\n            {\n              switch (c) {\n                case '\\\\':\n                  if (i < line.length - 1) {\n                    c = line.charAt(++i);\n                    switch (c) {\n                      case '\\\\':\n                      case '#':\n                      case '=':\n                        key += whitespace;\n                        whitespace = \"\";\n                        key += c;\n                        break;\n                      case ' ':\n                        if (key.length !== 0) {\n                          whitespace += c;\n                        }\n                        break;\n                      default:\n                        key += whitespace;\n                        whitespace = \"\";\n                        key += '\\\\';\n                        key += c;\n                        break;\n                    }\n                  } else {\n                    key += whitespace;\n                    key += c;\n                  }\n                  break;\n                case ' ':\n                case '\\t':\n                case '\\r':\n                case '\\n':\n                  if (key.length !== 0) {\n                    whitespace += c;\n                  }\n                  break;\n                case '=':\n                  whitespace = \"\";\n                  state = ParseStateValue;\n                  break;\n                case '#':\n                  finished = true;\n                  break;\n                default:\n                  key += whitespace;\n                  whitespace = \"\";\n                  key += c;\n                  break;\n              }\n              break;\n            }\n          case ParseStateValue:\n            {\n              switch (c) {\n                case '\\\\':\n                  if (i < line.length - 1) {\n                    c = line.charAt(++i);\n                    switch (c) {\n                      case '\\\\':\n                      case '#':\n                      case '=':\n                        value += value.length === 0 ? escapedspace : whitespace;\n                        whitespace = \"\";\n                        escapedspace = \"\";\n                        value += c;\n                        break;\n                      case ' ':\n                        whitespace += c;\n                        escapedspace += c;\n                        break;\n                      default:\n                        value += value.length === 0 ? escapedspace : whitespace;\n                        whitespace = \"\";\n                        escapedspace = \"\";\n                        value += '\\\\';\n                        value += c;\n                        break;\n                    }\n                  } else {\n                    value += value.length === 0 ? escapedspace : whitespace;\n                    value += c;\n                  }\n                  break;\n                case ' ':\n                case '\\t':\n                case '\\r':\n                case '\\n':\n                  if (value.length !== 0) {\n                    whitespace += c;\n                  }\n                  break;\n                case '#':\n                  finished = true;\n                  break;\n                default:\n                  value += value.length === 0 ? escapedspace : whitespace;\n                  whitespace = \"\";\n                  escapedspace = \"\";\n                  value += c;\n                  break;\n              }\n              break;\n            }\n          default:\n            {\n              Debug.assert(false);\n              break;\n            }\n        }\n        if (finished) {\n          break;\n        }\n      }\n      value += escapedspace;\n      if (state === ParseStateKey && key.length !== 0 || state == ParseStateValue && key.length === 0) {\n        getProcessLogger().warning(\"invalid config file entry: \\\"\" + line + \"\\\"\");\n        return;\n      } else if (key.length === 0) {\n        return;\n      }\n      this.setProperty(key, value);\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new Properties(null, this);\n    }\n  }, {\n    key: \"getUnusedProperties\",\n    value: function getUnusedProperties() {\n      var unused = [];\n      this._properties.forEach(function (property, key) {\n        if (!property.used) {\n          unused.push(key);\n        }\n      });\n      return unused;\n    }\n  }], [{\n    key: \"createProperties\",\n    value: function createProperties(args, defaults) {\n      return new Properties(args, defaults);\n    }\n  }]);\n}();\nIce.Properties = Properties;\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/PropertiesI.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Property.js":
/*!**********************************************!*\
  !*** ./node_modules/ice/src/Ice/Property.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\nIce.Property = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function _class(pattern, deprecated, deprecatedBy) {\n    _classCallCheck(this, _class);\n    this._pattern = pattern;\n    this._deprecated = deprecated;\n    this._deprecatedBy = deprecatedBy;\n  }\n  return _createClass(_class, [{\n    key: \"pattern\",\n    get: function get() {\n      return this._pattern;\n    }\n  }, {\n    key: \"deprecated\",\n    get: function get() {\n      return this._deprecated;\n    }\n  }, {\n    key: \"deprecatedBy\",\n    get: function get() {\n      return this._deprecatedBy;\n    }\n  }]);\n}();\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/Property.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/PropertyNames.js":
/*!***************************************************!*\
  !*** ./node_modules/ice/src/Ice/PropertyNames.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n// Generated by makeprops.py from file ..\\config\\PropertyNames.xml, Fri Jan  7 10:30:00 2022\n\n// IMPORTANT: Do not edit this file -- any edits made here will be lost!\n\n/* eslint comma-dangle: \"off\" */\n/* eslint array-bracket-newline: \"off\" */\n/* eslint no-useless-escape: \"off\" */\n\nvar Ice = (__webpack_require__(/*! ../Ice/Property */ \"./node_modules/ice/src/Ice/Property.js\").Ice);\nvar PropertyNames = {};\nvar Property = Ice.Property;\nPropertyNames.IceProps = [new Property(\"/^Ice\\.AcceptClassCycles/\", false, null), new Property(\"/^Ice\\.ACM\\.Client/\", true, null), new Property(\"/^Ice\\.ACM\\.Server/\", true, null), new Property(\"/^Ice\\.ACM\\.Timeout/\", false, null), new Property(\"/^Ice\\.ACM\\.Heartbeat/\", false, null), new Property(\"/^Ice\\.ACM\\.Close/\", false, null), new Property(\"/^Ice\\.ACM/\", false, null), new Property(\"/^Ice\\.ACM\\.Client\\.Timeout/\", false, null), new Property(\"/^Ice\\.ACM\\.Client\\.Heartbeat/\", false, null), new Property(\"/^Ice\\.ACM\\.Client\\.Close/\", false, null), new Property(\"/^Ice\\.ACM\\.Client/\", false, null), new Property(\"/^Ice\\.ACM\\.Server\\.Timeout/\", false, null), new Property(\"/^Ice\\.ACM\\.Server\\.Heartbeat/\", false, null), new Property(\"/^Ice\\.ACM\\.Server\\.Close/\", false, null), new Property(\"/^Ice\\.ACM\\.Server/\", false, null), new Property(\"/^Ice\\.Admin\\.ACM\\.Timeout/\", false, null), new Property(\"/^Ice\\.Admin\\.ACM\\.Heartbeat/\", false, null), new Property(\"/^Ice\\.Admin\\.ACM\\.Close/\", false, null), new Property(\"/^Ice\\.Admin\\.ACM/\", false, null), new Property(\"/^Ice\\.Admin\\.AdapterId/\", false, null), new Property(\"/^Ice\\.Admin\\.Endpoints/\", false, null), new Property(\"/^Ice\\.Admin\\.Locator\\.EndpointSelection/\", false, null), new Property(\"/^Ice\\.Admin\\.Locator\\.ConnectionCached/\", false, null), new Property(\"/^Ice\\.Admin\\.Locator\\.PreferSecure/\", false, null), new Property(\"/^Ice\\.Admin\\.Locator\\.LocatorCacheTimeout/\", false, null), new Property(\"/^Ice\\.Admin\\.Locator\\.InvocationTimeout/\", false, null), new Property(\"/^Ice\\.Admin\\.Locator\\.Locator/\", false, null), new Property(\"/^Ice\\.Admin\\.Locator\\.Router/\", false, null), new Property(\"/^Ice\\.Admin\\.Locator\\.CollocationOptimized/\", false, null), new Property(\"/^Ice\\.Admin\\.Locator\\.Context\\../\", false, null), new Property(\"/^Ice\\.Admin\\.Locator/\", false, null), new Property(\"/^Ice\\.Admin\\.PublishedEndpoints/\", false, null), new Property(\"/^Ice\\.Admin\\.ReplicaGroupId/\", false, null), new Property(\"/^Ice\\.Admin\\.Router\\.EndpointSelection/\", false, null), new Property(\"/^Ice\\.Admin\\.Router\\.ConnectionCached/\", false, null), new Property(\"/^Ice\\.Admin\\.Router\\.PreferSecure/\", false, null), new Property(\"/^Ice\\.Admin\\.Router\\.LocatorCacheTimeout/\", false, null), new Property(\"/^Ice\\.Admin\\.Router\\.InvocationTimeout/\", false, null), new Property(\"/^Ice\\.Admin\\.Router\\.Locator/\", false, null), new Property(\"/^Ice\\.Admin\\.Router\\.Router/\", false, null), new Property(\"/^Ice\\.Admin\\.Router\\.CollocationOptimized/\", false, null), new Property(\"/^Ice\\.Admin\\.Router\\.Context\\../\", false, null), new Property(\"/^Ice\\.Admin\\.Router/\", false, null), new Property(\"/^Ice\\.Admin\\.ProxyOptions/\", false, null), new Property(\"/^Ice\\.Admin\\.ThreadPool\\.Size/\", false, null), new Property(\"/^Ice\\.Admin\\.ThreadPool\\.SizeMax/\", false, null), new Property(\"/^Ice\\.Admin\\.ThreadPool\\.SizeWarn/\", false, null), new Property(\"/^Ice\\.Admin\\.ThreadPool\\.StackSize/\", false, null), new Property(\"/^Ice\\.Admin\\.ThreadPool\\.Serialize/\", false, null), new Property(\"/^Ice\\.Admin\\.ThreadPool\\.ThreadIdleTime/\", false, null), new Property(\"/^Ice\\.Admin\\.ThreadPool\\.ThreadPriority/\", false, null), new Property(\"/^Ice\\.Admin\\.MessageSizeMax/\", false, null), new Property(\"/^Ice\\.Admin\\.DelayCreation/\", false, null), new Property(\"/^Ice\\.Admin\\.Enabled/\", false, null), new Property(\"/^Ice\\.Admin\\.Facets/\", false, null), new Property(\"/^Ice\\.Admin\\.InstanceName/\", false, null), new Property(\"/^Ice\\.Admin\\.Logger\\.KeepLogs/\", false, null), new Property(\"/^Ice\\.Admin\\.Logger\\.KeepTraces/\", false, null), new Property(\"/^Ice\\.Admin\\.Logger\\.Properties/\", false, null), new Property(\"/^Ice\\.Admin\\.ServerId/\", false, null), new Property(\"/^Ice\\.BackgroundLocatorCacheUpdates/\", false, null), new Property(\"/^Ice\\.BatchAutoFlush/\", true, null), new Property(\"/^Ice\\.BatchAutoFlushSize/\", false, null), new Property(\"/^Ice\\.ChangeUser/\", false, null), new Property(\"/^Ice\\.ClassGraphDepthMax/\", false, null), new Property(\"/^Ice\\.ClientAccessPolicyProtocol/\", false, null), new Property(\"/^Ice\\.Compression\\.Level/\", false, null), new Property(\"/^Ice\\.CollectObjects/\", false, null), new Property(\"/^Ice\\.Config/\", false, null), new Property(\"/^Ice\\.ConsoleListener/\", false, null), new Property(\"/^Ice\\.Default\\.CollocationOptimized/\", false, null), new Property(\"/^Ice\\.Default\\.EncodingVersion/\", false, null), new Property(\"/^Ice\\.Default\\.EndpointSelection/\", false, null), new Property(\"/^Ice\\.Default\\.Host/\", false, null), new Property(\"/^Ice\\.Default\\.Locator\\.EndpointSelection/\", false, null), new Property(\"/^Ice\\.Default\\.Locator\\.ConnectionCached/\", false, null), new Property(\"/^Ice\\.Default\\.Locator\\.PreferSecure/\", false, null), new Property(\"/^Ice\\.Default\\.Locator\\.LocatorCacheTimeout/\", false, null), new Property(\"/^Ice\\.Default\\.Locator\\.InvocationTimeout/\", false, null), new Property(\"/^Ice\\.Default\\.Locator\\.Locator/\", false, null), new Property(\"/^Ice\\.Default\\.Locator\\.Router/\", false, null), new Property(\"/^Ice\\.Default\\.Locator\\.CollocationOptimized/\", false, null), new Property(\"/^Ice\\.Default\\.Locator\\.Context\\../\", false, null), new Property(\"/^Ice\\.Default\\.Locator/\", false, null), new Property(\"/^Ice\\.Default\\.LocatorCacheTimeout/\", false, null), new Property(\"/^Ice\\.Default\\.InvocationTimeout/\", false, null), new Property(\"/^Ice\\.Default\\.Package/\", false, null), new Property(\"/^Ice\\.Default\\.PreferSecure/\", false, null), new Property(\"/^Ice\\.Default\\.Protocol/\", false, null), new Property(\"/^Ice\\.Default\\.Router\\.EndpointSelection/\", false, null), new Property(\"/^Ice\\.Default\\.Router\\.ConnectionCached/\", false, null), new Property(\"/^Ice\\.Default\\.Router\\.PreferSecure/\", false, null), new Property(\"/^Ice\\.Default\\.Router\\.LocatorCacheTimeout/\", false, null), new Property(\"/^Ice\\.Default\\.Router\\.InvocationTimeout/\", false, null), new Property(\"/^Ice\\.Default\\.Router\\.Locator/\", false, null), new Property(\"/^Ice\\.Default\\.Router\\.Router/\", false, null), new Property(\"/^Ice\\.Default\\.Router\\.CollocationOptimized/\", false, null), new Property(\"/^Ice\\.Default\\.Router\\.Context\\../\", false, null), new Property(\"/^Ice\\.Default\\.Router/\", false, null), new Property(\"/^Ice\\.Default\\.SlicedFormat/\", false, null), new Property(\"/^Ice\\.Default\\.SourceAddress/\", false, null), new Property(\"/^Ice\\.Default\\.Timeout/\", false, null), new Property(\"/^Ice\\.EventLog\\.Source/\", false, null), new Property(\"/^Ice\\.FactoryAssemblies/\", false, null), new Property(\"/^Ice\\.HTTPProxyHost/\", false, null), new Property(\"/^Ice\\.HTTPProxyPort/\", false, null), new Property(\"/^Ice\\.ImplicitContext/\", false, null), new Property(\"/^Ice\\.InitPlugins/\", false, null), new Property(\"/^Ice\\.IPv4/\", false, null), new Property(\"/^Ice\\.IPv6/\", false, null), new Property(\"/^Ice\\.LogFile/\", false, null), new Property(\"/^Ice\\.LogFile\\.SizeMax/\", false, null), new Property(\"/^Ice\\.LogStdErr\\.Convert/\", false, null), new Property(\"/^Ice\\.MessageSizeMax/\", false, null), new Property(\"/^Ice\\.Nohup/\", false, null), new Property(\"/^Ice\\.NullHandleAbort/\", false, null), new Property(\"/^Ice\\.Override\\.CloseTimeout/\", false, null), new Property(\"/^Ice\\.Override\\.Compress/\", false, null), new Property(\"/^Ice\\.Override\\.ConnectTimeout/\", false, null), new Property(\"/^Ice\\.Override\\.Timeout/\", false, null), new Property(\"/^Ice\\.Override\\.Secure/\", false, null), new Property(\"/^Ice\\.Package\\../\", false, null), new Property(\"/^Ice\\.Plugin\\../\", false, null), new Property(\"/^Ice\\.PluginLoadOrder/\", false, null), new Property(\"/^Ice\\.PreferIPv6Address/\", false, null), new Property(\"/^Ice\\.PreloadAssemblies/\", false, null), new Property(\"/^Ice\\.PrintAdapterReady/\", false, null), new Property(\"/^Ice\\.PrintProcessId/\", false, null), new Property(\"/^Ice\\.PrintStackTraces/\", false, null), new Property(\"/^Ice\\.ProgramName/\", false, null), new Property(\"/^Ice\\.RetryIntervals/\", false, null), new Property(\"/^Ice\\.ServerIdleTime/\", false, null), new Property(\"/^Ice\\.SOCKSProxyHost/\", false, null), new Property(\"/^Ice\\.SOCKSProxyPort/\", false, null), new Property(\"/^Ice\\.StdErr/\", false, null), new Property(\"/^Ice\\.StdOut/\", false, null), new Property(\"/^Ice\\.SyslogFacility/\", false, null), new Property(\"/^Ice\\.ThreadPool\\.Client\\.Size/\", false, null), new Property(\"/^Ice\\.ThreadPool\\.Client\\.SizeMax/\", false, null), new Property(\"/^Ice\\.ThreadPool\\.Client\\.SizeWarn/\", false, null), new Property(\"/^Ice\\.ThreadPool\\.Client\\.StackSize/\", false, null), new Property(\"/^Ice\\.ThreadPool\\.Client\\.Serialize/\", false, null), new Property(\"/^Ice\\.ThreadPool\\.Client\\.ThreadIdleTime/\", false, null), new Property(\"/^Ice\\.ThreadPool\\.Client\\.ThreadPriority/\", false, null), new Property(\"/^Ice\\.ThreadPool\\.Server\\.Size/\", false, null), new Property(\"/^Ice\\.ThreadPool\\.Server\\.SizeMax/\", false, null), new Property(\"/^Ice\\.ThreadPool\\.Server\\.SizeWarn/\", false, null), new Property(\"/^Ice\\.ThreadPool\\.Server\\.StackSize/\", false, null), new Property(\"/^Ice\\.ThreadPool\\.Server\\.Serialize/\", false, null), new Property(\"/^Ice\\.ThreadPool\\.Server\\.ThreadIdleTime/\", false, null), new Property(\"/^Ice\\.ThreadPool\\.Server\\.ThreadPriority/\", false, null), new Property(\"/^Ice\\.ThreadPriority/\", false, null), new Property(\"/^Ice\\.ToStringMode/\", false, null), new Property(\"/^Ice\\.Trace\\.Admin\\.Properties/\", false, null), new Property(\"/^Ice\\.Trace\\.Admin\\.Logger/\", false, null), new Property(\"/^Ice\\.Trace\\.Locator/\", false, null), new Property(\"/^Ice\\.Trace\\.Network/\", false, null), new Property(\"/^Ice\\.Trace\\.Protocol/\", false, null), new Property(\"/^Ice\\.Trace\\.Retry/\", false, null), new Property(\"/^Ice\\.Trace\\.Slicing/\", false, null), new Property(\"/^Ice\\.Trace\\.ThreadPool/\", false, null), new Property(\"/^Ice\\.UDP\\.RcvSize/\", false, null), new Property(\"/^Ice\\.UDP\\.SndSize/\", false, null), new Property(\"/^Ice\\.TCP\\.Backlog/\", false, null), new Property(\"/^Ice\\.TCP\\.RcvSize/\", false, null), new Property(\"/^Ice\\.TCP\\.SndSize/\", false, null), new Property(\"/^Ice\\.UseApplicationClassLoader/\", false, null), new Property(\"/^Ice\\.UseOSLog/\", false, null), new Property(\"/^Ice\\.UseSyslog/\", false, null), new Property(\"/^Ice\\.UseSystemdJournal/\", false, null), new Property(\"/^Ice\\.Warn\\.AMICallback/\", false, null), new Property(\"/^Ice\\.Warn\\.Connections/\", false, null), new Property(\"/^Ice\\.Warn\\.Datagrams/\", false, null), new Property(\"/^Ice\\.Warn\\.Dispatch/\", false, null), new Property(\"/^Ice\\.Warn\\.Endpoints/\", false, null), new Property(\"/^Ice\\.Warn\\.UnknownProperties/\", false, null), new Property(\"/^Ice\\.Warn\\.UnusedProperties/\", false, null), new Property(\"/^Ice\\.CacheMessageBuffers/\", false, null), new Property(\"/^Ice\\.ThreadInterruptSafe/\", false, null)];\nPropertyNames.validProps = [PropertyNames.IceProps];\nPropertyNames.clPropNames = [\"Ice\"];\nIce.PropertyNames = PropertyNames;\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/PropertyNames.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Protocol.js":
/*!**********************************************!*\
  !*** ./node_modules/ice/src/Ice/Protocol.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n__webpack_require__(/*! ../Ice/Buffer */ \"./node_modules/ice/src/Ice/Buffer.js\");\n__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\");\n__webpack_require__(/*! ../Ice/StringUtil */ \"./node_modules/ice/src/Ice/StringUtil.js\");\n__webpack_require__(/*! ../Ice/Version */ \"./node_modules/ice/src/Ice/Version.js\");\nvar StringUtil = Ice.StringUtil;\nvar Protocol = {};\nIce.Encoding_1_0 = new Ice.EncodingVersion(1, 0);\nIce.Encoding_1_1 = new Ice.EncodingVersion(1, 1);\nIce.Protocol_1_0 = new Ice.ProtocolVersion(1, 0);\n\n//\n// Size of the Ice protocol header\n//\n// Magic number (4 bytes)\n// Protocol version major (Byte)\n// Protocol version minor (Byte)\n// Encoding version major (Byte)\n// Encoding version minor (Byte)\n// Message type (Byte)\n// Compression status (Byte)\n// Message size (Int)\n//\nProtocol.headerSize = 14;\n\n//\n// The magic number at the front of each message ['I', 'c', 'e', 'P']\n//\nProtocol.magic = new Uint8Array([0x49, 0x63, 0x65, 0x50]);\n\n//\n// The current Ice protocol and encoding version\n//\nProtocol.protocolMajor = 1;\nProtocol.protocolMinor = 0;\nProtocol.protocolEncodingMajor = 1;\nProtocol.protocolEncodingMinor = 0;\nProtocol.encodingMajor = 1;\nProtocol.encodingMinor = 1;\n\n//\n// The Ice protocol message types\n//\nProtocol.requestMsg = 0;\nProtocol.requestBatchMsg = 1;\nProtocol.replyMsg = 2;\nProtocol.validateConnectionMsg = 3;\nProtocol.closeConnectionMsg = 4;\n\n//\n// Reply status\n//\nProtocol.replyOK = 0;\nProtocol.replyUserException = 1;\nProtocol.replyObjectNotExist = 2;\nProtocol.replyFacetNotExist = 3;\nProtocol.replyOperationNotExist = 4;\nProtocol.replyUnknownLocalException = 5;\nProtocol.replyUnknownUserException = 6;\nProtocol.replyUnknownException = 7;\nProtocol.requestHdr = new Uint8Array([Protocol.magic[0], Protocol.magic[1], Protocol.magic[2], Protocol.magic[3], Protocol.protocolMajor, Protocol.protocolMinor, Protocol.protocolEncodingMajor, Protocol.protocolEncodingMinor, Protocol.requestMsg, 0,\n// Compression status.\n0, 0, 0, 0,\n// Message size (placeholder).\n0, 0, 0, 0 // Request ID (placeholder).\n]);\nProtocol.requestBatchHdr = new Uint8Array([Protocol.magic[0], Protocol.magic[1], Protocol.magic[2], Protocol.magic[3], Protocol.protocolMajor, Protocol.protocolMinor, Protocol.protocolEncodingMajor, Protocol.protocolEncodingMinor, Protocol.requestBatchMsg, 0,\n// Compression status.\n0, 0, 0, 0,\n// Message size (placeholder).\n0, 0, 0, 0 // Number of requests in batch (placeholder).\n]);\nProtocol.replyHdr = new Uint8Array([Protocol.magic[0], Protocol.magic[1], Protocol.magic[2], Protocol.magic[3], Protocol.protocolMajor, Protocol.protocolMinor, Protocol.protocolEncodingMajor, Protocol.protocolEncodingMinor, Protocol.replyMsg, 0,\n// Compression status.\n0, 0, 0, 0 // Message size (placeholder).\n]);\nProtocol.currentProtocol = new Ice.ProtocolVersion(Protocol.protocolMajor, Protocol.protocolMinor);\nProtocol.currentProtocolEncoding = new Ice.EncodingVersion(Protocol.protocolEncodingMajor, Protocol.protocolEncodingMinor);\nProtocol.currentEncoding = new Ice.EncodingVersion(Protocol.encodingMajor, Protocol.encodingMinor);\nProtocol.checkSupportedProtocol = function (v) {\n  if (v.major !== Protocol.currentProtocol.major || v.minor > Protocol.currentProtocol.minor) {\n    throw new Ice.UnsupportedProtocolException(\"\", v, Protocol.currentProtocol);\n  }\n};\nProtocol.checkSupportedProtocolEncoding = function (v) {\n  if (v.major !== Protocol.currentProtocolEncoding.major || v.minor > Protocol.currentProtocolEncoding.minor) {\n    throw new Ice.UnsupportedEncodingException(\"\", v, Protocol.currentProtocolEncoding);\n  }\n};\nProtocol.checkSupportedEncoding = function (v) {\n  if (v.major !== Protocol.currentEncoding.major || v.minor > Protocol.currentEncoding.minor) {\n    throw new Ice.UnsupportedEncodingException(\"\", v, Protocol.currentEncoding);\n  }\n};\n\n//\n// Either return the given protocol if not compatible, or the greatest\n// supported protocol otherwise.\n//\nProtocol.getCompatibleProtocol = function (v) {\n  if (v.major !== Protocol.currentProtocol.major) {\n    return v; // Unsupported protocol, return as is.\n  } else if (v.minor < Protocol.currentProtocol.minor) {\n    return v; // Supported protocol.\n  } else {\n    //\n    // Unsupported but compatible, use the currently supported\n    // protocol, that's the best we can do.\n    //\n    return Protocol.currentProtocol;\n  }\n};\n\n//\n// Either return the given encoding if not compatible, or the greatest\n// supported encoding otherwise.\n//\nProtocol.getCompatibleEncoding = function (v) {\n  if (v.major !== Protocol.currentEncoding.major) {\n    return v; // Unsupported encoding, return as is.\n  } else if (v.minor < Protocol.currentEncoding.minor) {\n    return v; // Supported encoding.\n  } else {\n    //\n    // Unsupported but compatible, use the currently supported\n    // encoding, that's the best we can do.\n    //\n    return Protocol.currentEncoding;\n  }\n};\nProtocol.isSupported = function (version, supported) {\n  return version.major === supported.major && version.minor <= supported.minor;\n};\n\n/**\n* Converts a string to a protocol version.\n*\n* @param version The string to convert.\n*\n* @return The converted protocol version.\n**/\nIce.stringToProtocolVersion = function (version) {\n  return new Ice.ProtocolVersion(stringToMajor(version), stringToMinor(version));\n};\n\n/**\n* Converts a string to an encoding version.\n*\n* @param version The string to convert.\n*\n* @return The converted object identity.\n**/\nIce.stringToEncodingVersion = function (version) {\n  return new Ice.EncodingVersion(stringToMajor(version), stringToMinor(version));\n};\n\n/**\n* Converts a protocol version to a string.\n*\n* @param v The protocol version to convert.\n*\n* @return The converted string.\n**/\nIce.protocolVersionToString = function (v) {\n  return majorMinorToString(v.major, v.minor);\n};\n\n/**\n * Converts an encoding version to a string.\n *\n * @param v The encoding version to convert.\n *\n * @return The converted string.\n **/\nIce.encodingVersionToString = function (v) {\n  return majorMinorToString(v.major, v.minor);\n};\nProtocol.OPTIONAL_END_MARKER = 0xFF;\nProtocol.FLAG_HAS_TYPE_ID_STRING = 1 << 0;\nProtocol.FLAG_HAS_TYPE_ID_INDEX = 1 << 1;\nProtocol.FLAG_HAS_TYPE_ID_COMPACT = 1 << 1 | 1 << 0;\nProtocol.FLAG_HAS_OPTIONAL_MEMBERS = 1 << 2;\nProtocol.FLAG_HAS_INDIRECTION_TABLE = 1 << 3;\nProtocol.FLAG_HAS_SLICE_SIZE = 1 << 4;\nProtocol.FLAG_IS_LAST_SLICE = 1 << 5;\nIce.Protocol = Protocol;\nmodule.exports.Ice = Ice;\nfunction stringToMajor(str) {\n  var pos = str.indexOf('.');\n  if (pos === -1) {\n    throw new Ice.VersionParseException(\"malformed version value `\" + str + \"'\");\n  }\n  try {\n    var majVersion = StringUtil.toInt(str.substring(0, pos));\n    if (majVersion < 1 || majVersion > 255) {\n      throw new Ice.VersionParseException(\"range error in version `\" + str + \"'\");\n    }\n    return majVersion;\n  } catch (ex) {\n    throw new Ice.VersionParseException(\"invalid version value `\" + str + \"'\");\n  }\n}\nfunction stringToMinor(str) {\n  var pos = str.indexOf('.');\n  if (pos === -1) {\n    throw new Ice.VersionParseException(\"malformed version value `\" + str + \"'\");\n  }\n  try {\n    var minVersion = StringUtil.toInt(str.substring(pos + 1));\n    if (minVersion < 0 || minVersion > 255) {\n      throw new Ice.VersionParseException(\"range error in version `\" + str + \"'\");\n    }\n    return minVersion;\n  } catch (ex) {\n    throw new Ice.VersionParseException(\"invalid version value `\" + str + \"'\");\n  }\n}\nfunction majorMinorToString(major, minor) {\n  return major + \".\" + minor;\n}\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/Protocol.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/ProtocolInstance.js":
/*!******************************************************!*\
  !*** ./node_modules/ice/src/Ice/ProtocolInstance.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\nvar ProtocolInstance = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function ProtocolInstance(instance, type, protocol, secure) {\n    _classCallCheck(this, ProtocolInstance);\n    this._instance = instance;\n    this._traceLevel = instance.traceLevels().network;\n    this._traceCategory = instance.traceLevels().networkCat;\n    this._logger = instance.initializationData().logger;\n    this._properties = instance.initializationData().properties;\n    this._type = type;\n    this._protocol = protocol;\n    this._secure = secure;\n  }\n  return _createClass(ProtocolInstance, [{\n    key: \"traceLevel\",\n    value: function traceLevel() {\n      return this._traceLevel;\n    }\n  }, {\n    key: \"traceCategory\",\n    value: function traceCategory() {\n      return this._traceCategory;\n    }\n  }, {\n    key: \"logger\",\n    value: function logger() {\n      return this._logger;\n    }\n  }, {\n    key: \"protocol\",\n    value: function protocol() {\n      return this._protocol;\n    }\n  }, {\n    key: \"type\",\n    value: function type() {\n      return this._type;\n    }\n  }, {\n    key: \"secure\",\n    value: function secure() {\n      return this._secure;\n    }\n  }, {\n    key: \"properties\",\n    value: function properties() {\n      return this._properties;\n    }\n  }, {\n    key: \"defaultHost\",\n    value: function defaultHost() {\n      return this._instance.defaultsAndOverrides().defaultHost;\n    }\n  }, {\n    key: \"defaultSourceAddress\",\n    value: function defaultSourceAddress() {\n      return this._instance.defaultsAndOverrides().defaultSourceAddress;\n    }\n  }, {\n    key: \"defaultEncoding\",\n    value: function defaultEncoding() {\n      return this._instance.defaultsAndOverrides().defaultEncoding;\n    }\n  }, {\n    key: \"defaultTimeout\",\n    value: function defaultTimeout() {\n      return this._instance.defaultsAndOverrides().defaultTimeout;\n    }\n  }, {\n    key: \"messageSizeMax\",\n    value: function messageSizeMax() {\n      return this._instance.messageSizeMax();\n    }\n  }]);\n}();\nIce.ProtocolInstance = ProtocolInstance;\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/ProtocolInstance.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/ProxyFactory.js":
/*!**************************************************!*\
  !*** ./node_modules/ice/src/Ice/ProxyFactory.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n__webpack_require__(/*! ../Ice/Debug */ \"./node_modules/ice/src/Ice/Debug.js\");\n__webpack_require__(/*! ../Ice/Identity */ \"./node_modules/ice/src/Ice/Identity.js\");\n__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\");\n__webpack_require__(/*! ../Ice/ObjectPrx */ \"./node_modules/ice/src/Ice/ObjectPrx.js\");\n__webpack_require__(/*! ../Ice/Reference */ \"./node_modules/ice/src/Ice/Reference.js\");\n__webpack_require__(/*! ../Ice/StringUtil */ \"./node_modules/ice/src/Ice/StringUtil.js\");\nvar Debug = Ice.Debug;\nvar Identity = Ice.Identity;\nvar ObjectPrx = Ice.ObjectPrx;\nvar StringUtil = Ice.StringUtil;\n\n//\n// Only for use by Instance.\n//\nvar ProxyFactory = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function ProxyFactory(instance) {\n    _classCallCheck(this, ProxyFactory);\n    this._instance = instance;\n    var arr = this._instance.initializationData().properties.getPropertyAsList(\"Ice.RetryIntervals\");\n    if (arr.length > 0) {\n      this._retryIntervals = [];\n      for (var i = 0; i < arr.length; i++) {\n        var v = void 0;\n        try {\n          v = StringUtil.toInt(arr[i]);\n        } catch (ex) {\n          v = 0;\n        }\n\n        //\n        // If -1 is the first value, no retry and wait intervals.\n        //\n        if (i === 0 && v === -1) {\n          break;\n        }\n        this._retryIntervals[i] = v > 0 ? v : 0;\n      }\n    } else {\n      this._retryIntervals = [0];\n    }\n  }\n  return _createClass(ProxyFactory, [{\n    key: \"stringToProxy\",\n    value: function stringToProxy(str) {\n      return this.referenceToProxy(this._instance.referenceFactory().createFromString(str, null));\n    }\n  }, {\n    key: \"proxyToString\",\n    value: function proxyToString(proxy) {\n      return proxy === null ? \"\" : proxy._getReference().toString();\n    }\n  }, {\n    key: \"propertyToProxy\",\n    value: function propertyToProxy(prefix) {\n      var proxy = this._instance.initializationData().properties.getProperty(prefix);\n      var ref = this._instance.referenceFactory().createFromString(proxy, prefix);\n      return this.referenceToProxy(ref);\n    }\n  }, {\n    key: \"proxyToProperty\",\n    value: function proxyToProperty(proxy, prefix) {\n      return proxy === null ? new Map() : proxy._getReference().toProperty(prefix);\n    }\n  }, {\n    key: \"streamToProxy\",\n    value: function streamToProxy(s, type) {\n      var ident = new Identity();\n      ident._read(s);\n      return this.referenceToProxy(this._instance.referenceFactory().createFromStream(ident, s), type);\n    }\n  }, {\n    key: \"referenceToProxy\",\n    value: function referenceToProxy(ref, type) {\n      if (ref !== null) {\n        var proxy = type ? new type() : new ObjectPrx();\n        proxy._setup(ref);\n        return proxy;\n      } else {\n        return null;\n      }\n    }\n  }, {\n    key: \"checkRetryAfterException\",\n    value: function checkRetryAfterException(ex, ref, sleepInterval, cnt) {\n      var traceLevels = this._instance.traceLevels();\n      var logger = this._instance.initializationData().logger;\n\n      //\n      // We don't retry batch requests because the exception might have caused\n      // the all the requests batched with the connection to be aborted and we\n      // want the application to be notified.\n      //\n      if (ref.getMode() === Ice.Reference.ModeBatchOneway || ref.getMode() === Ice.Reference.ModeBatchDatagram) {\n        throw ex;\n      }\n\n      //\n      // If it's a fixed proxy, retrying isn't useful as the proxy is tied to\n      // the connection and the request will fail with the exception.\n      //\n      if (ref instanceof Ice.FixedReference) {\n        throw ex;\n      }\n      if (ex instanceof Ice.ObjectNotExistException) {\n        if (ref.getRouterInfo() !== null && ex.operation === \"ice_add_proxy\") {\n          //\n          // If we have a router, an ObjectNotExistException with an\n          // operation name \"ice_add_proxy\" indicates to the client\n          // that the router isn't aware of the proxy (for example,\n          // because it was evicted by the router). In this case, we\n          // must *always* retry, so that the missing proxy is added\n          // to the router.\n          //\n\n          ref.getRouterInfo().clearCache(ref);\n          if (traceLevels.retry >= 1) {\n            logger.trace(traceLevels.retryCat, \"retrying operation call to add proxy to router\\n\" + ex.toString());\n          }\n          if (sleepInterval !== null) {\n            sleepInterval.value = 0;\n          }\n          return cnt; // We must always retry, so we don't look at the retry count.\n        } else if (ref.isIndirect()) {\n          //\n          // We retry ObjectNotExistException if the reference is\n          // indirect.\n          //\n\n          if (ref.isWellKnown()) {\n            var li = ref.getLocatorInfo();\n            if (li !== null) {\n              li.clearCache(ref);\n            }\n          }\n        } else {\n          //\n          // For all other cases, we don't retry ObjectNotExistException.\n          //\n          throw ex;\n        }\n      } else if (ex instanceof Ice.RequestFailedException) {\n        //\n        // For all other cases, we don't retry ObjectNotExistException\n        //\n        throw ex;\n      }\n\n      //\n      // There is no point in retrying an operation that resulted in a\n      // MarshalException. This must have been raised locally (because\n      // if it happened in a server it would result in an\n      // UnknownLocalException instead), which means there was a problem\n      // in this process that will not change if we try again.\n      //\n      // The most likely cause for a MarshalException is exceeding the\n      // maximum message size, which is represented by the the subclass\n      // MemoryLimitException. For example, a client can attempt to send\n      // a message that exceeds the maximum memory size, or accumulate\n      // enough batch requests without flushing that the maximum size is\n      // reached.\n      //\n      // This latter case is especially problematic, because if we were\n      // to retry a batch request after a MarshalException, we would in\n      // fact silently discard the accumulated requests and allow new\n      // batch requests to accumulate. If the subsequent batched\n      // requests do not exceed the maximum message size, it appears to\n      // the client that all of the batched requests were accepted, when\n      // in reality only the last few are actually sent.\n      //\n      if (ex instanceof Ice.MarshalException) {\n        throw ex;\n      }\n\n      //\n      // Don't retry if the communicator is destroyed, object adapter is deactivated,\n      // or connection is manually closed.\n      //\n      if (ex instanceof Ice.CommunicatorDestroyedException || ex instanceof Ice.ObjectAdapterDeactivatedException || ex instanceof Ice.ConnectionManuallyClosedException) {\n        throw ex;\n      }\n\n      //\n      // Don't retry invocation timeouts.\n      //\n      if (ex instanceof Ice.InvocationTimeoutException || ex instanceof Ice.InvocationCanceledException) {\n        throw ex;\n      }\n      ++cnt;\n      Debug.assert(cnt > 0);\n      var interval;\n      if (cnt === this._retryIntervals.length + 1 && ex instanceof Ice.CloseConnectionException) {\n        //\n        // A close connection exception is always retried at least once, even if the retry\n        // limit is reached.\n        //\n        interval = 0;\n      } else if (cnt > this._retryIntervals.length) {\n        if (traceLevels.retry >= 1) {\n          logger.trace(traceLevels.retryCat, \"cannot retry operation call because retry limit has been exceeded\\n\" + ex.toString());\n        }\n        throw ex;\n      } else {\n        interval = this._retryIntervals[cnt - 1];\n      }\n      if (traceLevels.retry >= 1) {\n        var msg = \"retrying operation call\";\n        if (interval > 0) {\n          msg += \" in \" + interval + \"ms\";\n        }\n        msg += \" because of exception\\n\" + ex.toString();\n        logger.trace(traceLevels.retryCat, msg);\n      }\n      Debug.assert(sleepInterval !== null);\n      sleepInterval.value = interval;\n      return cnt;\n    }\n  }]);\n}();\nIce.ProxyFactory = ProxyFactory;\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/ProxyFactory.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Reference.js":
/*!***********************************************!*\
  !*** ./node_modules/ice/src/Ice/Reference.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && \"function\" == typeof p ? function (t) { return p.apply(e, t); } : p; }\nfunction _get() { return _get = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }\nfunction _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/BatchRequestQueue */ \"./node_modules/ice/src/Ice/BatchRequestQueue.js\");\n__webpack_require__(/*! ../Ice/BuiltinSequences */ \"./node_modules/ice/src/Ice/BuiltinSequences.js\");\n__webpack_require__(/*! ../Ice/ConnectionRequestHandler */ \"./node_modules/ice/src/Ice/ConnectionRequestHandler.js\");\n__webpack_require__(/*! ../Ice/Debug */ \"./node_modules/ice/src/Ice/Debug.js\");\n__webpack_require__(/*! ../Ice/EndpointTypes */ \"./node_modules/ice/src/Ice/EndpointTypes.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/Identity */ \"./node_modules/ice/src/Ice/Identity.js\");\n__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\");\n__webpack_require__(/*! ../Ice/Locator */ \"./node_modules/ice/src/Ice/Locator.js\");\n__webpack_require__(/*! ../Ice/MapUtil */ \"./node_modules/ice/src/Ice/MapUtil.js\");\n__webpack_require__(/*! ../Ice/OpaqueEndpointI */ \"./node_modules/ice/src/Ice/OpaqueEndpointI.js\");\n__webpack_require__(/*! ../Ice/Promise */ \"./node_modules/ice/src/Ice/Promise.js\");\n__webpack_require__(/*! ../Ice/PropertyNames */ \"./node_modules/ice/src/Ice/PropertyNames.js\");\n__webpack_require__(/*! ../Ice/ReferenceMode */ \"./node_modules/ice/src/Ice/ReferenceMode.js\");\n__webpack_require__(/*! ../Ice/Router */ \"./node_modules/ice/src/Ice/Router.js\");\n__webpack_require__(/*! ../Ice/StringUtil */ \"./node_modules/ice/src/Ice/StringUtil.js\");\n__webpack_require__(/*! ../Ice/Version */ \"./node_modules/ice/src/Ice/Version.js\");\nvar ArrayUtil = Ice.ArrayUtil;\nvar BatchRequestQueue = Ice.BatchRequestQueue;\nvar ConnectionRequestHandler = Ice.ConnectionRequestHandler;\nvar Debug = Ice.Debug;\nvar EndpointSelectionType = Ice.EndpointSelectionType;\nvar HashUtil = Ice.HashUtil;\nvar Identity = Ice.Identity;\nvar LocatorPrx = Ice.LocatorPrx;\nvar MapUtil = Ice.MapUtil;\nvar OpaqueEndpointI = Ice.OpaqueEndpointI;\nvar PropertyNames = Ice.PropertyNames;\nvar RefMode = Ice.ReferenceMode;\nvar RouterPrx = Ice.RouterPrx;\nvar StringSeqHelper = Ice.StringSeqHelper;\nvar StringUtil = Ice.StringUtil;\nvar suffixes = [\"EndpointSelection\", \"ConnectionCached\", \"PreferSecure\", \"EncodingVersion\", \"LocatorCacheTimeout\", \"InvocationTimeout\", \"Locator\", \"Router\", \"CollocationOptimized\"];\n\n//\n// Only for use by Instance\n//\nvar ReferenceFactory = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function ReferenceFactory(instance, communicator) {\n    _classCallCheck(this, ReferenceFactory);\n    this._instance = instance;\n    this._communicator = communicator;\n    this._defaultRouter = null;\n    this._defaultLocator = null;\n  }\n  return _createClass(ReferenceFactory, [{\n    key: \"create\",\n    value: function create(ident, facet, tmpl, endpoints) {\n      if (ident.name.length === 0 && ident.category.length === 0) {\n        return null;\n      }\n      return this.createImpl(ident, facet, tmpl.getMode(), tmpl.getSecure(), tmpl.getProtocol(), tmpl.getEncoding(), endpoints, null, null);\n    }\n  }, {\n    key: \"createWithAdapterId\",\n    value: function createWithAdapterId(ident, facet, tmpl, adapterId) {\n      if (ident.name.length === 0 && ident.category.length === 0) {\n        return null;\n      }\n      return this.createImpl(ident, facet, tmpl.getMode(), tmpl.getSecure(), tmpl.getProtocol(), tmpl.getEncoding(), null, adapterId, null);\n    }\n  }, {\n    key: \"createFixed\",\n    value: function createFixed(ident, fixedConnection) {\n      if (ident.name.length === 0 && ident.category.length === 0) {\n        return null;\n      }\n\n      //\n      // Create new reference\n      //\n      return new FixedReference(this._instance, this._communicator, ident, \"\",\n      // Facet\n      fixedConnection.endpoint().datagram() ? RefMode.ModeDatagram : RefMode.ModeTwoway, fixedConnection.endpoint().secure(), Ice.Protocol_1_0, this._instance.defaultsAndOverrides().defaultEncoding, fixedConnection, -1, null);\n    }\n  }, {\n    key: \"copy\",\n    value: function copy(r) {\n      var ident = r.getIdentity();\n      if (ident.name.length === 0 && ident.category.length === 0) {\n        return null;\n      }\n      return r.clone();\n    }\n  }, {\n    key: \"createFromString\",\n    value: function createFromString(s, propertyPrefix) {\n      if (s === undefined || s === null || s.length === 0) {\n        return null;\n      }\n      var delim = \" \\t\\n\\r\";\n      var end = 0;\n      var beg = StringUtil.findFirstNotOf(s, delim, end);\n      if (beg == -1) {\n        throw new Ice.ProxyParseException(\"no non-whitespace characters found in `\" + s + \"'\");\n      }\n\n      //\n      // Extract the identity, which may be enclosed in single\n      // or double quotation marks.\n      //\n      var idstr = null;\n      end = StringUtil.checkQuote(s, beg);\n      if (end === -1) {\n        throw new Ice.ProxyParseException(\"mismatched quotes around identity in `\" + s + \"'\");\n      } else if (end === 0) {\n        end = StringUtil.findFirstOf(s, delim + \":@\", beg);\n        if (end === -1) {\n          end = s.length;\n        }\n        idstr = s.substring(beg, end);\n      } else {\n        beg++; // Skip leading quote\n        idstr = s.substring(beg, end);\n        end++; // Skip trailing quote\n      }\n      if (beg === end) {\n        throw new Ice.ProxyParseException(\"no identity in `\" + s + \"'\");\n      }\n\n      //\n      // Parsing the identity may raise IdentityParseException.\n      //\n      var ident = Ice.stringToIdentity(idstr);\n      if (ident.name.length === 0) {\n        //\n        // An identity with an empty name and a non-empty\n        // category is illegal.\n        //\n        if (ident.category.length > 0) {\n          throw new Ice.IllegalIdentityException(ident);\n        }\n        //\n        // Treat a stringified proxy containing two double\n        // quotes (\"\") the same as an empty string, i.e.,\n        // a null proxy, but only if nothing follows the\n        // quotes.\n        //\n        else if (StringUtil.findFirstNotOf(s, delim, end) != -1) {\n          throw new Ice.ProxyParseException(\"invalid characters after identity in `\" + s + \"'\");\n        } else {\n          return null;\n        }\n      }\n      var facet = \"\";\n      var mode = RefMode.ModeTwoway;\n      var secure = false;\n      var encoding = this._instance.defaultsAndOverrides().defaultEncoding;\n      var protocol = Ice.Protocol_1_0;\n      var adapter = \"\";\n      while (true) {\n        beg = StringUtil.findFirstNotOf(s, delim, end);\n        if (beg === -1) {\n          break;\n        }\n        if (s.charAt(beg) == ':' || s.charAt(beg) == '@') {\n          break;\n        }\n        end = StringUtil.findFirstOf(s, delim + \":@\", beg);\n        if (end == -1) {\n          end = s.length;\n        }\n        if (beg == end) {\n          break;\n        }\n        var option = s.substring(beg, end);\n        if (option.length != 2 || option.charAt(0) != '-') {\n          throw new Ice.ProxyParseException(\"expected a proxy option but found `\" + option + \"' in `\" + s + \"'\");\n        }\n\n        //\n        // Check for the presence of an option argument. The\n        // argument may be enclosed in single or double\n        // quotation marks.\n        //\n        var argument = null;\n        var argumentBeg = StringUtil.findFirstNotOf(s, delim, end);\n        if (argumentBeg != -1) {\n          var ch = s.charAt(argumentBeg);\n          if (ch != \"@\" && ch != \":\" && ch != \"-\") {\n            beg = argumentBeg;\n            end = StringUtil.checkQuote(s, beg);\n            if (end == -1) {\n              throw new Ice.ProxyParseException(\"mismatched quotes around value for \" + option + \" option in `\" + s + \"'\");\n            } else if (end === 0) {\n              end = StringUtil.findFirstOf(s, delim + \":@\", beg);\n              if (end === -1) {\n                end = s.length;\n              }\n              argument = s.substring(beg, end);\n            } else {\n              beg++; // Skip leading quote\n              argument = s.substring(beg, end);\n              end++; // Skip trailing quote\n            }\n          }\n        }\n\n        //\n        // If any new options are added here,\n        // IceInternal::Reference::toString() and its derived classes must be updated as well.\n        //\n        switch (option.charAt(1)) {\n          case 'f':\n            {\n              if (argument === null) {\n                throw new Ice.ProxyParseException(\"no argument provided for -f option in `\" + s + \"'\");\n              }\n              try {\n                facet = StringUtil.unescapeString(argument, 0, argument.length);\n              } catch (ex) {\n                throw new Ice.ProxyParseException(\"invalid facet in `\" + s + \"': \" + ex.message);\n              }\n              break;\n            }\n          case 't':\n            {\n              if (argument !== null) {\n                throw new Ice.ProxyParseException(\"unexpected argument `\" + argument + \"' provided for -t option in `\" + s + \"'\");\n              }\n              mode = RefMode.ModeTwoway;\n              break;\n            }\n          case 'o':\n            {\n              if (argument !== null) {\n                throw new Ice.ProxyParseException(\"unexpected argument `\" + argument + \"' provided for -o option in `\" + s + \"'\");\n              }\n              mode = RefMode.ModeOneway;\n              break;\n            }\n          case 'O':\n            {\n              if (argument !== null) {\n                throw new Ice.ProxyParseException(\"unexpected argument `\" + argument + \"' provided for -O option in `\" + s + \"'\");\n              }\n              mode = RefMode.ModeBatchOneway;\n              break;\n            }\n          case 'd':\n            {\n              if (argument !== null) {\n                throw new Ice.ProxyParseException(\"unexpected argument `\" + argument + \"' provided for -d option in `\" + s + \"'\");\n              }\n              mode = RefMode.ModeDatagram;\n              break;\n            }\n          case 'D':\n            {\n              if (argument !== null) {\n                throw new Ice.ProxyParseException(\"unexpected argument `\" + argument + \"' provided for -D option in `\" + s + \"'\");\n              }\n              mode = RefMode.ModeBatchDatagram;\n              break;\n            }\n          case 's':\n            {\n              if (argument !== null) {\n                throw new Ice.ProxyParseException(\"unexpected argument `\" + argument + \"' provided for -s option in `\" + s + \"'\");\n              }\n              secure = true;\n              break;\n            }\n          case 'e':\n            {\n              if (argument === null) {\n                throw new Ice.ProxyParseException(\"no argument provided for -e option in `\" + s + \"'\");\n              }\n              try {\n                encoding = Ice.stringToEncodingVersion(argument);\n              } catch (e)\n              // VersionParseException\n              {\n                throw new Ice.ProxyParseException(\"invalid encoding version `\" + argument + \"' in `\" + s + \"':\\n\" + e.str);\n              }\n              break;\n            }\n          case 'p':\n            {\n              if (argument === null) {\n                throw new Ice.ProxyParseException(\"no argument provided for -p option in `\" + s + \"'\");\n              }\n              try {\n                protocol = Ice.stringToProtocolVersion(argument);\n              } catch (e)\n              // VersionParseException\n              {\n                throw new Ice.ProxyParseException(\"invalid protocol version `\" + argument + \"' in `\" + s + \"':\\n\" + e.str);\n              }\n              break;\n            }\n          default:\n            {\n              throw new Ice.ProxyParseException(\"unknown option `\" + option + \"' in `\" + s + \"'\");\n            }\n        }\n      }\n      if (beg === -1) {\n        return this.createImpl(ident, facet, mode, secure, protocol, encoding, null, null, propertyPrefix);\n      }\n      var endpoints = [];\n      if (s.charAt(beg) == ':') {\n        var unknownEndpoints = [];\n        end = beg;\n        while (end < s.length && s.charAt(end) == ':') {\n          beg = end + 1;\n          end = beg;\n          while (true) {\n            end = s.indexOf(':', end);\n            if (end == -1) {\n              end = s.length;\n              break;\n            } else {\n              var quoted = false;\n              var quote = beg;\n              while (true) {\n                quote = s.indexOf(\"\\\"\", quote);\n                if (quote == -1 || end < quote) {\n                  break;\n                } else {\n                  quote = s.indexOf(\"\\\"\", ++quote);\n                  if (quote == -1) {\n                    break;\n                  } else if (end < quote) {\n                    quoted = true;\n                    break;\n                  }\n                  ++quote;\n                }\n              }\n              if (!quoted) {\n                break;\n              }\n              ++end;\n            }\n          }\n          var es = s.substring(beg, end);\n          var endp = this._instance.endpointFactoryManager().create(es, false);\n          if (endp !== null) {\n            endpoints.push(endp);\n          } else {\n            unknownEndpoints.push(es);\n          }\n        }\n        if (endpoints.length === 0) {\n          Debug.assert(unknownEndpoints.length > 0);\n          throw new Ice.EndpointParseException(\"invalid endpoint `\" + unknownEndpoints[0] + \"' in `\" + s + \"'\");\n        } else if (unknownEndpoints.length !== 0 && this._instance.initializationData().properties.getPropertyAsIntWithDefault(\"Ice.Warn.Endpoints\", 1) > 0) {\n          var msg = [];\n          msg.push(\"Proxy contains unknown endpoints:\");\n          unknownEndpoints.forEach(function (unknownEndpoint) {\n            msg.push(\" `\");\n            msg.push(unknownEndpoint);\n            msg.push(\"'\");\n          });\n          this._instance.initializationData().logger.warning(msg.join(\"\"));\n        }\n        return this.createImpl(ident, facet, mode, secure, protocol, encoding, endpoints, null, propertyPrefix);\n      } else if (s.charAt(beg) == '@') {\n        beg = StringUtil.findFirstNotOf(s, delim, beg + 1);\n        if (beg == -1) {\n          throw new Ice.ProxyParseException(\"missing adapter id in `\" + s + \"'\");\n        }\n        var adapterstr = null;\n        end = StringUtil.checkQuote(s, beg);\n        if (end === -1) {\n          throw new Ice.ProxyParseException(\"mismatched quotes around adapter id in `\" + s + \"'\");\n        } else if (end === 0) {\n          end = StringUtil.findFirstOf(s, delim, beg);\n          if (end === -1) {\n            end = s.length;\n          }\n          adapterstr = s.substring(beg, end);\n        } else {\n          beg++; // Skip leading quote\n          adapterstr = s.substring(beg, end);\n          end++; // Skip trailing quote\n        }\n        if (end !== s.length && StringUtil.findFirstNotOf(s, delim, end) !== -1) {\n          throw new Ice.ProxyParseException(\"invalid trailing characters after `\" + s.substring(0, end + 1) + \"' in `\" + s + \"'\");\n        }\n        try {\n          adapter = StringUtil.unescapeString(adapterstr, 0, adapterstr.length);\n        } catch (ex) {\n          throw new Ice.ProxyParseException(\"invalid adapter id in `\" + s + \"': \" + ex.message);\n        }\n        if (adapter.length === 0) {\n          throw new Ice.ProxyParseException(\"empty adapter id in `\" + s + \"'\");\n        }\n        return this.createImpl(ident, facet, mode, secure, protocol, encoding, null, adapter, propertyPrefix);\n      }\n      throw new Ice.ProxyParseException(\"malformed proxy `\" + s + \"'\");\n    }\n  }, {\n    key: \"createFromStream\",\n    value: function createFromStream(ident, s) {\n      //\n      // Don't read the identity here. Operations calling this\n      // constructor read the identity, and pass it as a parameter.\n      //\n\n      if (ident.name.length === 0 && ident.category.length === 0) {\n        return null;\n      }\n\n      //\n      // For compatibility with the old FacetPath.\n      //\n      var facetPath = StringSeqHelper.read(s); // String[]\n      var facet;\n      if (facetPath.length > 0) {\n        if (facetPath.length > 1) {\n          throw new Ice.ProxyUnmarshalException();\n        }\n        facet = facetPath[0];\n      } else {\n        facet = \"\";\n      }\n      var mode = s.readByte();\n      if (mode < 0 || mode > RefMode.ModeLast) {\n        throw new Ice.ProxyUnmarshalException();\n      }\n      var secure = s.readBool();\n      var protocol = null;\n      var encoding = null;\n      if (!s.getEncoding().equals(Ice.Encoding_1_0)) {\n        protocol = new Ice.ProtocolVersion();\n        protocol._read(s);\n        encoding = new Ice.EncodingVersion();\n        encoding._read(s);\n      } else {\n        protocol = Ice.Protocol_1_0;\n        encoding = Ice.Encoding_1_0;\n      }\n      var endpoints = null; // EndpointI[]\n      var adapterId = null;\n      var sz = s.readSize();\n      if (sz > 0) {\n        endpoints = [];\n        for (var i = 0; i < sz; i++) {\n          endpoints[i] = this._instance.endpointFactoryManager().read(s);\n        }\n      } else {\n        adapterId = s.readString();\n      }\n      return this.createImpl(ident, facet, mode, secure, protocol, encoding, endpoints, adapterId, null);\n    }\n  }, {\n    key: \"setDefaultRouter\",\n    value: function setDefaultRouter(defaultRouter) {\n      if (this._defaultRouter === null ? defaultRouter === null : this._defaultRouter.equals(defaultRouter)) {\n        return this;\n      }\n      var factory = new ReferenceFactory(this._instance, this._communicator);\n      factory._defaultLocator = this._defaultLocator;\n      factory._defaultRouter = defaultRouter;\n      return factory;\n    }\n  }, {\n    key: \"getDefaultRouter\",\n    value: function getDefaultRouter() {\n      return this._defaultRouter;\n    }\n  }, {\n    key: \"setDefaultLocator\",\n    value: function setDefaultLocator(defaultLocator) {\n      if (this._defaultLocator === null ? defaultLocator === null : this._defaultLocator.equals(defaultLocator)) {\n        return this;\n      }\n      var factory = new ReferenceFactory(this._instance, this._communicator);\n      factory._defaultRouter = this._defaultRouter;\n      factory._defaultLocator = defaultLocator;\n      return factory;\n    }\n  }, {\n    key: \"getDefaultLocator\",\n    value: function getDefaultLocator() {\n      return this._defaultLocator;\n    }\n  }, {\n    key: \"checkForUnknownProperties\",\n    value: function checkForUnknownProperties(prefix) {\n      var unknownProps = [];\n      //\n      // Do not warn about unknown properties for Ice prefixes (Ice, Glacier2, etc.)\n      //\n      for (var i = 0; i < PropertyNames.clPropNames.length; ++i) {\n        if (prefix.indexOf(PropertyNames.clPropNames[i] + \".\") === 0) {\n          return;\n        }\n      }\n      var properties = this._instance.initializationData().properties.getPropertiesForPrefix(prefix + \".\");\n      unknownProps = unknownProps.concat(Array.from(properties.keys()).filter(function (key) {\n        return !suffixes.some(function (suffix) {\n          return key === prefix + \".\" + suffix;\n        });\n      }));\n      if (unknownProps.length > 0) {\n        var message = [];\n        message.push(\"found unknown properties for proxy '\");\n        message.push(prefix);\n        message.push(\"':\");\n        unknownProps.forEach(function (unknownProp) {\n          return message.push(\"\\n    \", unknownProp);\n        });\n        this._instance.initializationData().logger.warning(message.join(\"\"));\n      }\n    }\n  }, {\n    key: \"createImpl\",\n    value: function createImpl(ident, facet, mode, secure, protocol, encoding, endpoints, adapterId, propertyPrefix) {\n      var defaultsAndOverrides = this._instance.defaultsAndOverrides();\n\n      //\n      // Default local proxy options.\n      //\n      var locatorInfo = null;\n      if (this._defaultLocator !== null) {\n        if (!this._defaultLocator._getReference().getEncoding().equals(encoding)) {\n          locatorInfo = this._instance.locatorManager().find(this._defaultLocator.ice_encodingVersion(encoding));\n        } else {\n          locatorInfo = this._instance.locatorManager().find(this._defaultLocator);\n        }\n      }\n      var routerInfo = this._instance.routerManager().find(this._defaultRouter);\n      var cacheConnection = true;\n      var preferSecure = defaultsAndOverrides.defaultPreferSecure;\n      var endpointSelection = defaultsAndOverrides.defaultEndpointSelection;\n      var locatorCacheTimeout = defaultsAndOverrides.defaultLocatorCacheTimeout;\n      var invocationTimeout = defaultsAndOverrides.defaultInvocationTimeout;\n\n      //\n      // Override the defaults with the proxy properties if a property prefix is defined.\n      //\n      if (propertyPrefix !== null && propertyPrefix.length > 0) {\n        var properties = this._instance.initializationData().properties;\n\n        //\n        // Warn about unknown properties.\n        //\n        if (properties.getPropertyAsIntWithDefault(\"Ice.Warn.UnknownProperties\", 1) > 0) {\n          this.checkForUnknownProperties(propertyPrefix);\n        }\n        var property = propertyPrefix + \".Locator\";\n        var locator = LocatorPrx.uncheckedCast(this._communicator.propertyToProxy(property));\n        if (locator !== null) {\n          if (!locator._getReference().getEncoding().equals(encoding)) {\n            locatorInfo = this._instance.locatorManager().find(locator.ice_encodingVersion(encoding));\n          } else {\n            locatorInfo = this._instance.locatorManager().find(locator);\n          }\n        }\n        property = propertyPrefix + \".Router\";\n        var router = RouterPrx.uncheckedCast(this._communicator.propertyToProxy(property));\n        if (router !== null) {\n          if (propertyPrefix.endsWith(\"Router\")) {\n            this._instance.initializationData().logger.warning(\"`\" + property + \"=\" + properties.getProperty(property) + \"': cannot set a router on a router; setting ignored\");\n          } else {\n            routerInfo = this._instance.routerManager().find(router);\n          }\n        }\n        property = propertyPrefix + \".ConnectionCached\";\n        cacheConnection = properties.getPropertyAsIntWithDefault(property, cacheConnection ? 1 : 0) > 0;\n        property = propertyPrefix + \".PreferSecure\";\n        preferSecure = properties.getPropertyAsIntWithDefault(property, preferSecure ? 1 : 0) > 0;\n        property = propertyPrefix + \".EndpointSelection\";\n        if (properties.getProperty(property).length > 0) {\n          var type = properties.getProperty(property);\n          if (type == \"Random\") {\n            endpointSelection = EndpointSelectionType.Random;\n          } else if (type == \"Ordered\") {\n            endpointSelection = EndpointSelectionType.Ordered;\n          } else {\n            throw new Ice.EndpointSelectionTypeParseException(\"illegal value `\" + type + \"'; expected `Random' or `Ordered'\");\n          }\n        }\n        property = propertyPrefix + \".LocatorCacheTimeout\";\n        var value = properties.getProperty(property);\n        if (value.length !== 0) {\n          locatorCacheTimeout = properties.getPropertyAsIntWithDefault(property, locatorCacheTimeout);\n          if (locatorCacheTimeout < -1) {\n            locatorCacheTimeout = -1;\n            this._instance.initializationData().logger.warning(\"invalid value for\" + property + \"`\" + properties.getProperty(property) + \"': defaulting to -1\");\n          }\n        }\n        property = propertyPrefix + \".InvocationTimeout\";\n        value = properties.getProperty(property);\n        if (value.length !== 0) {\n          invocationTimeout = properties.getPropertyAsIntWithDefault(property, invocationTimeout);\n          if (invocationTimeout < 1 && invocationTimeout !== -1) {\n            invocationTimeout = -1;\n            this._instance.initializationData().logger.warning(\"invalid value for\" + property + \"`\" + properties.getProperty(property) + \"': defaulting to -1\");\n          }\n        }\n      }\n\n      //\n      // Create new reference\n      //\n      return new RoutableReference(this._instance, this._communicator, ident, facet, mode, secure, protocol, encoding, endpoints, adapterId, locatorInfo, routerInfo, cacheConnection, preferSecure, endpointSelection, locatorCacheTimeout, invocationTimeout);\n    }\n  }]);\n}();\nIce.ReferenceFactory = ReferenceFactory;\nvar Reference = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function Reference(instance, communicator, identity, facet, mode, secure, protocol, encoding, invocationTimeout, context) {\n    _classCallCheck(this, Reference);\n    //\n    // Validate string arguments.\n    //\n    Debug.assert(identity === undefined || identity.name !== null);\n    Debug.assert(identity === undefined || identity.category !== null);\n    Debug.assert(facet === undefined || facet !== null);\n    this._instance = instance;\n    this._communicator = communicator;\n    this._mode = mode;\n    this._secure = secure;\n    this._identity = identity;\n    this._context = context === undefined ? Reference._emptyContext : context;\n    this._facet = facet;\n    this._protocol = protocol;\n    this._encoding = encoding;\n    this._invocationTimeout = invocationTimeout;\n    this._hashInitialized = false;\n  }\n  return _createClass(Reference, [{\n    key: \"getMode\",\n    value: function getMode() {\n      return this._mode;\n    }\n  }, {\n    key: \"getSecure\",\n    value: function getSecure() {\n      return this._secure;\n    }\n  }, {\n    key: \"getProtocol\",\n    value: function getProtocol() {\n      return this._protocol;\n    }\n  }, {\n    key: \"getEncoding\",\n    value: function getEncoding() {\n      return this._encoding;\n    }\n  }, {\n    key: \"getIdentity\",\n    value: function getIdentity() {\n      return this._identity;\n    }\n  }, {\n    key: \"getFacet\",\n    value: function getFacet() {\n      return this._facet;\n    }\n  }, {\n    key: \"getInstance\",\n    value: function getInstance() {\n      return this._instance;\n    }\n  }, {\n    key: \"getContext\",\n    value: function getContext() {\n      return this._context; // Map\n    }\n  }, {\n    key: \"getInvocationTimeout\",\n    value: function getInvocationTimeout() {\n      return this._invocationTimeout;\n    }\n  }, {\n    key: \"getCommunicator\",\n    value: function getCommunicator() {\n      return this._communicator;\n    }\n  }, {\n    key: \"getEndpoints\",\n    value: function getEndpoints() {\n      // Abstract\n      Debug.assert(false);\n      return null;\n    }\n  }, {\n    key: \"getAdapterId\",\n    value: function getAdapterId() {\n      // Abstract\n      Debug.assert(false);\n      return \"\";\n    }\n  }, {\n    key: \"getRouterInfo\",\n    value: function getRouterInfo() {\n      // Abstract\n      Debug.assert(false);\n      return null;\n    }\n  }, {\n    key: \"getLocatorInfo\",\n    value: function getLocatorInfo() {\n      // Abstract\n      Debug.assert(false);\n      return null;\n    }\n  }, {\n    key: \"getCacheConnection\",\n    value: function getCacheConnection() {\n      // Abstract\n      Debug.assert(false);\n      return false;\n    }\n  }, {\n    key: \"getPreferSecure\",\n    value: function getPreferSecure() {\n      // Abstract\n      Debug.assert(false);\n      return false;\n    }\n  }, {\n    key: \"getEndpointSelection\",\n    value: function getEndpointSelection() {\n      // Abstract\n      Debug.assert(false);\n      return null;\n    }\n  }, {\n    key: \"getLocatorCacheTimeout\",\n    value: function getLocatorCacheTimeout() {\n      // Abstract\n      Debug.assert(false);\n      return 0;\n    }\n  }, {\n    key: \"getConnectionId\",\n    value: function getConnectionId() {\n      // Abstract\n      Debug.assert(false);\n      return \"\";\n    }\n  }, {\n    key: \"getTimeout\",\n    value: function getTimeout() {\n      // Abstract\n      Debug.assert(false);\n      return \"\";\n    }\n\n    //\n    // The change* methods (here and in derived classes) create\n    // a new reference based on the existing one, with the\n    // corresponding value changed.\n    //\n  }, {\n    key: \"changeContext\",\n    value: function changeContext(newContext) {\n      if (newContext === undefined || newContext === null) {\n        newContext = Reference._emptyContext;\n      }\n      var r = this._instance.referenceFactory().copy(this);\n      if (newContext.size === 0) {\n        r._context = Reference._emptyContext;\n      } else {\n        r._context = new Map(newContext);\n      }\n      return r;\n    }\n  }, {\n    key: \"changeMode\",\n    value: function changeMode(newMode) {\n      if (newMode === this._mode) {\n        return this;\n      }\n      var r = this._instance.referenceFactory().copy(this);\n      r._mode = newMode;\n      return r;\n    }\n  }, {\n    key: \"changeSecure\",\n    value: function changeSecure(newSecure) {\n      if (newSecure === this._secure) {\n        return this;\n      }\n      var r = this._instance.referenceFactory().copy(this);\n      r._secure = newSecure;\n      return r;\n    }\n  }, {\n    key: \"changeIdentity\",\n    value: function changeIdentity(newIdentity) {\n      if (newIdentity.equals(this._identity)) {\n        return this;\n      }\n      var r = this._instance.referenceFactory().copy(this);\n      r._identity = new Identity(newIdentity.name, newIdentity.category);\n      return r;\n    }\n  }, {\n    key: \"changeFacet\",\n    value: function changeFacet(newFacet) {\n      if (newFacet === this._facet) {\n        return this;\n      }\n      var r = this._instance.referenceFactory().copy(this);\n      r._facet = newFacet;\n      return r;\n    }\n  }, {\n    key: \"changeInvocationTimeout\",\n    value: function changeInvocationTimeout(newInvocationTimeout) {\n      if (newInvocationTimeout === this._invocationTimeout) {\n        return this;\n      }\n      var r = this._instance.referenceFactory().copy(this);\n      r._invocationTimeout = newInvocationTimeout;\n      return r;\n    }\n  }, {\n    key: \"changeEncoding\",\n    value: function changeEncoding(newEncoding) {\n      if (newEncoding.equals(this._encoding)) {\n        return this;\n      }\n      var r = this._instance.referenceFactory().copy(this);\n      r._encoding = newEncoding;\n      return r;\n    }\n  }, {\n    key: \"changeAdapterId\",\n    value: function changeAdapterId(newAdapterId) {\n      // Abstract\n      Debug.assert(false);\n      return null;\n    }\n  }, {\n    key: \"changeEndpoints\",\n    value: function changeEndpoints(newEndpoints) {\n      // Abstract\n      Debug.assert(false);\n      return null;\n    }\n  }, {\n    key: \"changeLocator\",\n    value: function changeLocator(newLocator) {\n      // Abstract\n      Debug.assert(false);\n      return null;\n    }\n  }, {\n    key: \"changeRouter\",\n    value: function changeRouter(newRouter) {\n      // Abstract\n      Debug.assert(false);\n      return null;\n    }\n  }, {\n    key: \"changeCacheConnection\",\n    value: function changeCacheConnection(newCache) {\n      // Abstract\n      Debug.assert(false);\n      return null;\n    }\n  }, {\n    key: \"changePreferSecure\",\n    value: function changePreferSecure(newPreferSecure) {\n      // Abstract\n      Debug.assert(false);\n      return null;\n    }\n  }, {\n    key: \"changeEndpointSelection\",\n    value: function changeEndpointSelection(newType) {\n      // Abstract\n      Debug.assert(false);\n      return null;\n    }\n  }, {\n    key: \"changeLocatorCacheTimeout\",\n    value: function changeLocatorCacheTimeout(newTimeout) {\n      // Abstract\n      Debug.assert(false);\n      return null;\n    }\n  }, {\n    key: \"changeTimeout\",\n    value: function changeTimeout(newTimeout) {\n      // Abstract\n      Debug.assert(false);\n      return null;\n    }\n  }, {\n    key: \"changeConnectionId\",\n    value: function changeConnectionId(connectionId) {\n      // Abstract\n      Debug.assert(false);\n      return null;\n    }\n  }, {\n    key: \"changeConnection\",\n    value: function changeConnection(connection) {\n      // Abstract\n      Debug.assert(false);\n      return null;\n    }\n  }, {\n    key: \"hashCode\",\n    value: function hashCode() {\n      if (this._hashInitialized) {\n        return this._hashValue;\n      }\n      var h = 5381;\n      h = HashUtil.addNumber(h, this._mode);\n      h = HashUtil.addBoolean(h, this._secure);\n      h = HashUtil.addHashable(h, this._identity);\n      if (this._context !== null && this._context !== undefined) {\n        var _iterator = _createForOfIteratorHelper(this._context),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _step$value = _slicedToArray(_step.value, 2),\n              key = _step$value[0],\n              value = _step$value[1];\n            h = HashUtil.addString(h, key);\n            h = HashUtil.addString(h, value);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n      h = HashUtil.addString(h, this._facet);\n      h = HashUtil.addHashable(h, this._protocol);\n      h = HashUtil.addHashable(h, this._encoding);\n      h = HashUtil.addNumber(h, this._invocationTimeout);\n      this._hashValue = h;\n      this._hashInitialized = true;\n      return this._hashValue;\n    }\n\n    //\n    // Utility methods\n    //\n  }, {\n    key: \"isIndirect\",\n    value: function isIndirect() {\n      // Abstract\n      Debug.assert(false);\n      return false;\n    }\n  }, {\n    key: \"isWellKnown\",\n    value: function isWellKnown() {\n      // Abstract\n      Debug.assert(false);\n      return false;\n    }\n\n    //\n    // Marshal the reference.\n    //\n  }, {\n    key: \"streamWrite\",\n    value: function streamWrite(s) {\n      //\n      // Don't write the identity here. Operations calling streamWrite\n      // write the identity.\n      //\n\n      //\n      // For compatibility with the old FacetPath.\n      //\n      if (this._facet.length === 0) {\n        s.writeSize(0); // Empty string sequence\n      } else {\n        s.writeSize(1); // String sequence with one element\n        s.writeString(this._facet);\n      }\n      s.writeByte(this._mode);\n      s.writeBool(this._secure);\n      if (!s.getEncoding().equals(Ice.Encoding_1_0)) {\n        this._protocol._write(s);\n        this._encoding._write(s);\n      }\n\n      // Derived class writes the remainder of the reference.\n    }\n\n    //\n    // Convert the reference to its string form.\n    //\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      //\n      // WARNING: Certain features, such as proxy validation in Glacier2,\n      // depend on the format of proxy strings. Changes to toString() and\n      // methods called to generate parts of the reference string could break\n      // these features. Please review for all features that depend on the\n      // format of proxyToString() before changing this and related code.\n      //\n      var s = [];\n      var toStringMode = this._instance.toStringMode();\n\n      //\n      // If the encoded identity string contains characters which\n      // the reference parser uses as separators, then we enclose\n      // the identity string in quotes.\n      //\n\n      var id = Ice.identityToString(this._identity, toStringMode);\n      if (id.search(/[ :@]/) != -1) {\n        s.push('\"');\n        s.push(id);\n        s.push('\"');\n      } else {\n        s.push(id);\n      }\n      if (this._facet.length > 0) {\n        //\n        // If the encoded facet string contains characters which\n        // the reference parser uses as separators, then we enclose\n        // the facet string in quotes.\n        //\n        s.push(\" -f \");\n        var fs = StringUtil.escapeString(this._facet, \"\", toStringMode);\n        if (fs.search(/[ :@]/) != -1) {\n          s.push('\"');\n          s.push(fs);\n          s.push('\"');\n        } else {\n          s.push(fs);\n        }\n      }\n      switch (this._mode) {\n        case RefMode.ModeTwoway:\n          {\n            s.push(\" -t\");\n            break;\n          }\n        case RefMode.ModeOneway:\n          {\n            s.push(\" -o\");\n            break;\n          }\n        case RefMode.ModeBatchOneway:\n          {\n            s.push(\" -O\");\n            break;\n          }\n        case RefMode.ModeDatagram:\n          {\n            s.push(\" -d\");\n            break;\n          }\n        case RefMode.ModeBatchDatagram:\n          {\n            s.push(\" -D\");\n            break;\n          }\n        default:\n          {\n            Debug.assert(false);\n            break;\n          }\n      }\n      if (this._secure) {\n        s.push(\" -s\");\n      }\n      if (!this._protocol.equals(Ice.Protocol_1_0)) {\n        //\n        // We only print the protocol if it's not 1.0. It's fine as\n        // long as we don't add Ice.Default.ProtocolVersion, a\n        // stringified proxy will convert back to the same proxy with\n        // stringToProxy.\n        //\n        s.push(\" -p \");\n        s.push(Ice.protocolVersionToString(this._protocol));\n      }\n\n      //\n      // Always print the encoding version to ensure a stringified proxy\n      // will convert back to a proxy with the same encoding with\n      // stringToProxy (and won't use Ice.Default.EncodingVersion).\n      //\n      s.push(\" -e \");\n      s.push(Ice.encodingVersionToString(this._encoding));\n      return s.join(\"\");\n\n      // Derived class writes the remainder of the string.\n    }\n\n    //\n    // Convert the reference to its property form.\n    //\n  }, {\n    key: \"toProperty\",\n    value: function toProperty(prefix) {\n      // Abstract\n      Debug.assert(false);\n      return null;\n    }\n  }, {\n    key: \"getRequestHandler\",\n    value: function getRequestHandler(proxy) {\n      // Abstract\n      Debug.assert(false);\n    }\n  }, {\n    key: \"getBatchRequestQueue\",\n    value: function getBatchRequestQueue() {\n      // Abstract\n      Debug.assert(false);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(r) {\n      //\n      // Note: if(this === r) and type test are performed by each non-abstract derived class.\n      //\n\n      if (this._mode !== r._mode) {\n        return false;\n      }\n      if (this._secure !== r._secure) {\n        return false;\n      }\n      if (!this._identity.equals(r._identity)) {\n        return false;\n      }\n      if (!MapUtil.equals(this._context, r._context)) {\n        return false;\n      }\n      if (this._facet !== r._facet) {\n        return false;\n      }\n      if (!this._protocol.equals(r._protocol)) {\n        return false;\n      }\n      if (!this._encoding.equals(r._encoding)) {\n        return false;\n      }\n      if (this._invocationTimeout !== r._invocationTimeout) {\n        return false;\n      }\n      return true;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      // Abstract\n      Debug.assert(false);\n      return null;\n    }\n  }, {\n    key: \"copyMembers\",\n    value: function copyMembers(r) {\n      //\n      // Copy the members that are not passed to the constructor.\n      //\n      r._context = this._context;\n    }\n  }]);\n}();\nReference._emptyContext = new Map();\nReference._emptyEndpoints = [];\nIce.Reference = Reference;\nvar FixedReference = /*#__PURE__*/function (_Reference) {\n  \"use strict\";\n\n  function FixedReference(instance, communicator, identity, facet, mode, secure, protocol, encoding, connection, invocationTimeout, context) {\n    var _this;\n    _classCallCheck(this, FixedReference);\n    _this = _callSuper(this, FixedReference, [instance, communicator, identity, facet, mode, secure, protocol, encoding, invocationTimeout, context]);\n    _this._fixedConnection = connection;\n    return _this;\n  }\n  _inherits(FixedReference, _Reference);\n  return _createClass(FixedReference, [{\n    key: \"getEndpoints\",\n    value: function getEndpoints() {\n      return Reference._emptyEndpoints;\n    }\n  }, {\n    key: \"getAdapterId\",\n    value: function getAdapterId() {\n      return \"\";\n    }\n  }, {\n    key: \"getRouterInfo\",\n    value: function getRouterInfo() {\n      return null;\n    }\n  }, {\n    key: \"getLocatorInfo\",\n    value: function getLocatorInfo() {\n      return null;\n    }\n  }, {\n    key: \"getCacheConnection\",\n    value: function getCacheConnection() {\n      return true;\n    }\n  }, {\n    key: \"getPreferSecure\",\n    value: function getPreferSecure() {\n      return false;\n    }\n  }, {\n    key: \"getEndpointSelection\",\n    value: function getEndpointSelection() {\n      return EndpointSelectionType.Random;\n    }\n  }, {\n    key: \"getLocatorCacheTimeout\",\n    value: function getLocatorCacheTimeout() {\n      return 0;\n    }\n  }, {\n    key: \"getConnectionId\",\n    value: function getConnectionId() {\n      return \"\";\n    }\n  }, {\n    key: \"getTimeout\",\n    value: function getTimeout() {\n      return undefined;\n    }\n  }, {\n    key: \"changeAdapterId\",\n    value: function changeAdapterId(newAdapterId) {\n      throw new Ice.FixedProxyException();\n    }\n  }, {\n    key: \"changeEndpoints\",\n    value: function changeEndpoints(newEndpoints) {\n      throw new Ice.FixedProxyException();\n    }\n  }, {\n    key: \"changeLocato\",\n    value: function changeLocato(newLocator) {\n      throw new Ice.FixedProxyException();\n    }\n  }, {\n    key: \"changeRouter\",\n    value: function changeRouter(newRouter) {\n      throw new Ice.FixedProxyException();\n    }\n  }, {\n    key: \"changeCacheConnection\",\n    value: function changeCacheConnection(newCache) {\n      throw new Ice.FixedProxyException();\n    }\n  }, {\n    key: \"changePreferSecure\",\n    value: function changePreferSecure(prefSec) {\n      throw new Ice.FixedProxyException();\n    }\n  }, {\n    key: \"changeEndpointSelection\",\n    value: function changeEndpointSelection(newType) {\n      throw new Ice.FixedProxyException();\n    }\n  }, {\n    key: \"changeLocatorCacheTimeout\",\n    value: function changeLocatorCacheTimeout(newTimeout) {\n      throw new Ice.FixedProxyException();\n    }\n  }, {\n    key: \"changeTimeout\",\n    value: function changeTimeout(newTimeout) {\n      throw new Ice.FixedProxyException();\n    }\n  }, {\n    key: \"changeConnectionId\",\n    value: function changeConnectionId(connectionId) {\n      throw new Ice.FixedProxyException();\n    }\n  }, {\n    key: \"changeConnection\",\n    value: function changeConnection(newConnection) {\n      if (newConnection == this._fixedConnection) {\n        return this;\n      }\n      var r = this.getInstance().referenceFactory().copy(this);\n      r._fixedConnection = newConnection;\n      return r;\n    }\n  }, {\n    key: \"isIndirect\",\n    value: function isIndirect() {\n      return false;\n    }\n  }, {\n    key: \"isWellKnown\",\n    value: function isWellKnown() {\n      return false;\n    }\n  }, {\n    key: \"streamWrite\",\n    value: function streamWrite(s) {\n      throw new Ice.FixedProxyException();\n    }\n  }, {\n    key: \"toProperty\",\n    value: function toProperty(prefix) {\n      throw new Ice.FixedProxyException();\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      var r = new FixedReference(this.getInstance(), this.getCommunicator(), this.getIdentity(), this.getFacet(), this.getMode(), this.getSecure(), this.getProtocol(), this.getEncoding(), this._fixedConnection, this.getInvocationTimeout(), this.getContext());\n      this.copyMembers(r);\n      return r;\n    }\n  }, {\n    key: \"getRequestHandler\",\n    value: function getRequestHandler(proxy) {\n      switch (this.getMode()) {\n        case RefMode.ModeTwoway:\n        case RefMode.ModeOneway:\n        case RefMode.ModeBatchOneway:\n          {\n            if (this._fixedConnection.endpoint().datagram()) {\n              throw new Ice.NoEndpointException(this.toString());\n            }\n            break;\n          }\n        case RefMode.ModeDatagram:\n        case RefMode.ModeBatchDatagram:\n          {\n            if (!this._fixedConnection.endpoint().datagram()) {\n              throw new Ice.NoEndpointException(this.toString());\n            }\n            break;\n          }\n        default:\n          {\n            Debug.assert(false);\n            break;\n          }\n      }\n\n      //\n      // If a secure connection is requested or secure overrides is set,\n      // check if the connection is secure.\n      //\n      var defaultsAndOverrides = this.getInstance().defaultsAndOverrides();\n      var secure = defaultsAndOverrides.overrideSecure ? defaultsAndOverrides.overrideSecureValue : this.getSecure();\n      if (secure && !this._fixedConnection.endpoint().secure()) {\n        throw new Ice.NoEndpointException(this.toString());\n      }\n      this._fixedConnection.throwException(); // Throw in case our connection is already destroyed.\n\n      return proxy._setRequestHandler(new ConnectionRequestHandler(this, this._fixedConnection));\n    }\n  }, {\n    key: \"getBatchRequestQueue\",\n    value: function getBatchRequestQueue() {\n      return this._fixedConnection.getBatchRequestQueue();\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(rhs) {\n      if (this === rhs) {\n        return true;\n      }\n      if (!(rhs instanceof FixedReference)) {\n        return false;\n      }\n      if (!_superPropGet(FixedReference, \"equals\", this, 3)([rhs])) {\n        return false;\n      }\n      return this._fixedConnection == rhs._fixedConnection;\n    }\n  }]);\n}(Reference);\nIce.FixedReference = FixedReference;\nvar RoutableReference = /*#__PURE__*/function (_Reference2) {\n  \"use strict\";\n\n  function RoutableReference(instance, communicator, identity, facet, mode, secure, protocol, encoding, endpoints, adapterId, locatorInfo, routerInfo, cacheConnection, preferSecure, endpointSelection, locatorCacheTimeout, invocationTimeout, context) {\n    var _this2;\n    _classCallCheck(this, RoutableReference);\n    _this2 = _callSuper(this, RoutableReference, [instance, communicator, identity, facet, mode, secure, protocol, encoding, invocationTimeout, context]);\n    _this2._endpoints = endpoints;\n    _this2._adapterId = adapterId;\n    _this2._locatorInfo = locatorInfo;\n    _this2._routerInfo = routerInfo;\n    _this2._cacheConnection = cacheConnection;\n    _this2._preferSecure = preferSecure;\n    _this2._endpointSelection = endpointSelection;\n    _this2._locatorCacheTimeout = locatorCacheTimeout;\n    _this2._overrideTimeout = false;\n    _this2._timeout = -1;\n    if (_this2._endpoints === null) {\n      _this2._endpoints = Reference._emptyEndpoints;\n    }\n    if (_this2._adapterId === null) {\n      _this2._adapterId = \"\";\n    }\n    _this2._connectionId = \"\";\n    Debug.assert(_this2._adapterId.length === 0 || _this2._endpoints.length === 0);\n    return _this2;\n  }\n  _inherits(RoutableReference, _Reference2);\n  return _createClass(RoutableReference, [{\n    key: \"getEndpoints\",\n    value: function getEndpoints() {\n      return this._endpoints;\n    }\n  }, {\n    key: \"getAdapterId\",\n    value: function getAdapterId() {\n      return this._adapterId;\n    }\n  }, {\n    key: \"getRouterInfo\",\n    value: function getRouterInfo() {\n      return this._routerInfo;\n    }\n  }, {\n    key: \"getLocatorInfo\",\n    value: function getLocatorInfo() {\n      return this._locatorInfo;\n    }\n  }, {\n    key: \"getCacheConnection\",\n    value: function getCacheConnection() {\n      return this._cacheConnection;\n    }\n  }, {\n    key: \"getPreferSecure\",\n    value: function getPreferSecure() {\n      return this._preferSecure;\n    }\n  }, {\n    key: \"getEndpointSelection\",\n    value: function getEndpointSelection() {\n      return this._endpointSelection;\n    }\n  }, {\n    key: \"getLocatorCacheTimeout\",\n    value: function getLocatorCacheTimeout() {\n      return this._locatorCacheTimeout;\n    }\n  }, {\n    key: \"getConnectionId\",\n    value: function getConnectionId() {\n      return this._connectionId;\n    }\n  }, {\n    key: \"getTimeout\",\n    value: function getTimeout() {\n      return this._overrideTimeout ? this._timeout : undefined;\n    }\n  }, {\n    key: \"changeEncoding\",\n    value: function changeEncoding(newEncoding) {\n      var r = _superPropGet(RoutableReference, \"changeEncoding\", this, 3)([newEncoding]);\n      if (r !== this) {\n        if (r._locatorInfo !== null && !r._locatorInfo.getLocator().ice_getEncodingVersion().equals(newEncoding)) {\n          r._locatorInfo = this.getInstance().locatorManager().find(r._locatorInfo.getLocator().ice_encodingVersion(newEncoding));\n        }\n      }\n      return r;\n    }\n  }, {\n    key: \"changeAdapterId\",\n    value: function changeAdapterId(newAdapterId) {\n      if (this._adapterId === newAdapterId) {\n        return this;\n      }\n      var r = this.getInstance().referenceFactory().copy(this);\n      r._adapterId = newAdapterId;\n      r._endpoints = Reference._emptyEndpoints;\n      return r;\n    }\n  }, {\n    key: \"changeEndpoints\",\n    value: function changeEndpoints(newEndpoints) {\n      if (ArrayUtil.equals(newEndpoints, this._endpoints, function (e1, e2) {\n        return e1.equals(e2);\n      })) {\n        return this;\n      }\n      var r = this.getInstance().referenceFactory().copy(this);\n      r._endpoints = newEndpoints;\n      r._adapterId = \"\";\n      r.applyOverrides(r._endpoints);\n      return r;\n    }\n  }, {\n    key: \"changeLocator\",\n    value: function changeLocator(newLocator) {\n      var newLocatorInfo = this.getInstance().locatorManager().find(newLocator);\n      if (newLocatorInfo !== null && this._locatorInfo !== null && newLocatorInfo.equals(this._locatorInfo)) {\n        return this;\n      }\n      var r = this.getInstance().referenceFactory().copy(this);\n      r._locatorInfo = newLocatorInfo;\n      return r;\n    }\n  }, {\n    key: \"changeRouter\",\n    value: function changeRouter(newRouter) {\n      var newRouterInfo = this.getInstance().routerManager().find(newRouter);\n      if (newRouterInfo !== null && this._routerInfo !== null && newRouterInfo.equals(this._routerInfo)) {\n        return this;\n      }\n      var r = this.getInstance().referenceFactory().copy(this);\n      r._routerInfo = newRouterInfo;\n      return r;\n    }\n  }, {\n    key: \"changeCacheConnection\",\n    value: function changeCacheConnection(newCache) {\n      if (newCache === this._cacheConnection) {\n        return this;\n      }\n      var r = this.getInstance().referenceFactory().copy(this);\n      r._cacheConnection = newCache;\n      return r;\n    }\n  }, {\n    key: \"changePreferSecure\",\n    value: function changePreferSecure(newPreferSecure) {\n      if (newPreferSecure === this._preferSecure) {\n        return this;\n      }\n      var r = this.getInstance().referenceFactory().copy(this);\n      r._preferSecure = newPreferSecure;\n      return r;\n    }\n  }, {\n    key: \"changeEndpointSelection\",\n    value: function changeEndpointSelection(newType) {\n      if (newType === this._endpointSelection) {\n        return this;\n      }\n      var r = this.getInstance().referenceFactory().copy(this);\n      r._endpointSelection = newType;\n      return r;\n    }\n  }, {\n    key: \"changeLocatorCacheTimeout\",\n    value: function changeLocatorCacheTimeout(newTimeout) {\n      if (this._locatorCacheTimeout === newTimeout) {\n        return this;\n      }\n      var r = this.getInstance().referenceFactory().copy(this);\n      r._locatorCacheTimeout = newTimeout;\n      return r;\n    }\n  }, {\n    key: \"changeTimeout\",\n    value: function changeTimeout(newTimeout) {\n      if (this._overrideTimeout && this._timeout === newTimeout) {\n        return this;\n      }\n      var r = this.getInstance().referenceFactory().copy(this);\n      r._timeout = newTimeout;\n      r._overrideTimeout = true;\n      r._endpoints = this._endpoints.map(function (endpoint) {\n        return endpoint.changeTimeout(newTimeout);\n      });\n      return r;\n    }\n  }, {\n    key: \"changeConnectionId\",\n    value: function changeConnectionId(id) {\n      if (this._connectionId === id) {\n        return this;\n      }\n      var r = this.getInstance().referenceFactory().copy(this);\n      r._connectionId = id;\n      r._endpoints = this._endpoints.map(function (endpoint) {\n        return endpoint.changeConnectionId(id);\n      });\n      return r;\n    }\n  }, {\n    key: \"changeConnection\",\n    value: function changeConnection(newConnection) {\n      return new FixedReference(this.getInstance(), this.getCommunicator(), this.getIdentity(), this.getFacet(), this.getMode(), this.getSecure(), this.getProtocol(), this.getEncoding(), newConnection, this.getInvocationTimeout(), this.getContext());\n    }\n  }, {\n    key: \"isIndirect\",\n    value: function isIndirect() {\n      return this._endpoints.length === 0;\n    }\n  }, {\n    key: \"isWellKnown\",\n    value: function isWellKnown() {\n      return this._endpoints.length === 0 && this._adapterId.length === 0;\n    }\n  }, {\n    key: \"streamWrite\",\n    value: function streamWrite(s) {\n      _superPropGet(RoutableReference, \"streamWrite\", this, 3)([s]);\n      s.writeSize(this._endpoints.length);\n      if (this._endpoints.length > 0) {\n        Debug.assert(this._adapterId.length === 0);\n        this._endpoints.forEach(function (endpoint) {\n          s.writeShort(endpoint.type());\n          endpoint.streamWrite(s);\n        });\n      } else {\n        s.writeString(this._adapterId); // Adapter id.\n      }\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      //\n      // WARNING: Certain features, such as proxy validation in Glacier2,\n      // depend on the format of proxy strings. Changes to toString() and\n      // methods called to generate parts of the reference string could break\n      // these features. Please review for all features that depend on the\n      // format of proxyToString() before changing this and related code.\n      //\n      var s = [];\n      s.push(_superPropGet(RoutableReference, \"toString\", this, 3)([]));\n      if (this._endpoints.length > 0) {\n        this._endpoints.forEach(function (endpoint) {\n          var endp = endpoint.toString();\n          if (endp !== null && endp.length > 0) {\n            s.push(':');\n            s.push(endp);\n          }\n        });\n      } else if (this._adapterId.length > 0) {\n        s.push(\" @ \");\n\n        //\n        // If the encoded adapter id string contains characters which\n        // the reference parser uses as separators, then we enclose\n        // the adapter id string in quotes.\n        //\n        var a = StringUtil.escapeString(this._adapterId, null, this._instance.toStringMode());\n        if (a.search(/[ :@]/) != -1) {\n          s.push('\"');\n          s.push(a);\n          s.push('\"');\n        } else {\n          s.push(a);\n        }\n      }\n      return s.join(\"\");\n    }\n  }, {\n    key: \"toProperty\",\n    value: function toProperty(prefix) {\n      var properties = new Map();\n      properties.set(prefix, this.toString());\n      properties.set(prefix + \".CollocationOptimized\", \"0\");\n      properties.set(prefix + \".ConnectionCached\", this._cacheConnection ? \"1\" : \"0\");\n      properties.set(prefix + \".PreferSecure\", this._preferSecure ? \"1\" : \"0\");\n      properties.set(prefix + \".EndpointSelection\", this._endpointSelection === EndpointSelectionType.Random ? \"Random\" : \"Ordered\");\n      properties.set(prefix + \".LocatorCacheTimeout\", String(this._locatorCacheTimeout));\n      properties.set(prefix + \".InvocationTimeout\", String(this.getInvocationTimeout()));\n      if (this._routerInfo !== null) {\n        this._routerInfo.getRouter()._getReference().toProperty(prefix + \".Router\").forEach(function (value, key) {\n          return properties.set(key, value);\n        });\n      }\n      if (this._locatorInfo !== null) {\n        this._locatorInfo.getLocator()._getReference().toProperty(prefix + \".Locator\").forEach(function (value, key) {\n          return properties.set(key, value);\n        });\n      }\n      return properties;\n    }\n  }, {\n    key: \"hashCode\",\n    value: function hashCode() {\n      if (!this._hashInitialized) {\n        _superPropGet(RoutableReference, \"hashCode\", this, 3)([]); // Initializes _hashValue.\n        this._hashValue = HashUtil.addString(this._hashValue, this._adapterId);\n      }\n      return this._hashValue;\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(rhs) {\n      if (this === rhs) {\n        return true;\n      }\n      if (!(rhs instanceof RoutableReference)) {\n        return false;\n      }\n      if (!_superPropGet(RoutableReference, \"equals\", this, 3)([rhs])) {\n        return false;\n      }\n      if (this._locatorInfo === null ? rhs._locatorInfo !== null : !this._locatorInfo.equals(rhs._locatorInfo)) {\n        return false;\n      }\n      if (this._routerInfo === null ? rhs._routerInfo !== null : !this._routerInfo.equals(rhs._routerInfo)) {\n        return false;\n      }\n      if (this._cacheConnection !== rhs._cacheConnection) {\n        return false;\n      }\n      if (this._preferSecure !== rhs._preferSecure) {\n        return false;\n      }\n      if (this._endpointSelection !== rhs._endpointSelection) {\n        return false;\n      }\n      if (this._locatorCacheTimeout !== rhs._locatorCacheTimeout) {\n        return false;\n      }\n      if (this._connectionId !== rhs._connectionId) {\n        return false;\n      }\n      if (this._overrideTimeout !== rhs._overrideTimeout) {\n        return false;\n      }\n      if (this._overrideTimeout && this._timeout !== rhs._timeout) {\n        return false;\n      }\n      if (!ArrayUtil.equals(this._endpoints, rhs._endpoints, function (e1, e2) {\n        return e1.equals(e2);\n      })) {\n        return false;\n      }\n      if (this._adapterId !== rhs._adapterId) {\n        return false;\n      }\n      return true;\n    }\n  }, {\n    key: \"getRequestHandler\",\n    value: function getRequestHandler(proxy) {\n      return this._instance.requestHandlerFactory().getRequestHandler(this, proxy);\n    }\n  }, {\n    key: \"getBatchRequestQueue\",\n    value: function getBatchRequestQueue() {\n      return new BatchRequestQueue(this._instance, this._mode === RefMode.ModeBatchDatagram);\n    }\n  }, {\n    key: \"getConnection\",\n    value: function getConnection() {\n      var _this3 = this;\n      var p = new Ice.Promise(); // success callback receives (connection)\n\n      if (this._routerInfo !== null) {\n        //\n        // If we route, we send everything to the router's client\n        // proxy endpoints.\n        //\n        this._routerInfo.getClientEndpoints().then(function (endpts) {\n          if (endpts.length > 0) {\n            _this3.applyOverrides(endpts);\n            _this3.createConnection(endpts).then(p.resolve, p.reject);\n          } else {\n            _this3.getConnectionNoRouterInfo(p);\n          }\n        })[\"catch\"](p.reject);\n      } else {\n        this.getConnectionNoRouterInfo(p);\n      }\n      return p;\n    }\n  }, {\n    key: \"getConnectionNoRouterInfo\",\n    value: function getConnectionNoRouterInfo(p) {\n      var _this4 = this;\n      if (this._endpoints.length > 0) {\n        this.createConnection(this._endpoints).then(p.resolve)[\"catch\"](p.reject);\n        return;\n      }\n      if (this._locatorInfo !== null) {\n        this._locatorInfo.getEndpoints(this, null, this._locatorCacheTimeout).then(function (values) {\n          var _values = _slicedToArray(values, 2),\n            endpoints = _values[0],\n            cached = _values[1];\n          if (endpoints.length === 0) {\n            p.reject(new Ice.NoEndpointException(_this4.toString()));\n            return;\n          }\n          _this4.applyOverrides(endpoints);\n          _this4.createConnection(endpoints).then(p.resolve, function (ex) {\n            if (ex instanceof Ice.NoEndpointException) {\n              //\n              // No need to retry if there's no endpoints.\n              //\n              p.reject(ex);\n            } else {\n              Debug.assert(_this4._locatorInfo !== null);\n              _this4.getLocatorInfo().clearCache(_this4);\n              if (cached) {\n                var traceLevels = _this4.getInstance().traceLevels();\n                if (traceLevels.retry >= 2) {\n                  _this4.getInstance().initializationData().logger.trace(traceLevels.retryCat, \"connection to cached endpoints failed\\n\" + \"removing endpoints from cache and trying again\\n\" + ex.toString());\n                }\n                _this4.getConnectionNoRouterInfo(p); // Retry.\n                return;\n              }\n              p.reject(ex);\n            }\n          });\n        })[\"catch\"](p.reject);\n      } else {\n        p.reject(new Ice.NoEndpointException(this.toString()));\n      }\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      var r = new RoutableReference(this.getInstance(), this.getCommunicator(), this.getIdentity(), this.getFacet(), this.getMode(), this.getSecure(), this.getProtocol(), this.getEncoding(), this._endpoints, this._adapterId, this._locatorInfo, this._routerInfo, this._cacheConnection, this._preferSecure, this._endpointSelection, this._locatorCacheTimeout, this._invocationTimeout);\n      this.copyMembers(r);\n      return r;\n    }\n  }, {\n    key: \"copyMembers\",\n    value: function copyMembers(rhs) {\n      //\n      // Copy the members that are not passed to the constructor.\n      //\n      _superPropGet(RoutableReference, \"copyMembers\", this, 3)([rhs]);\n      rhs._overrideTimeout = this._overrideTimeout;\n      rhs._timeout = this._timeout;\n      rhs._connectionId = this._connectionId;\n    }\n  }, {\n    key: \"applyOverrides\",\n    value: function applyOverrides(endpts) {\n      //\n      // Apply the endpoint overrides to each endpoint.\n      //\n      for (var i = 0; i < endpts.length; ++i) {\n        endpts[i] = endpts[i].changeConnectionId(this._connectionId);\n        if (this._overrideTimeout) {\n          endpts[i] = endpts[i].changeTimeout(this._timeout);\n        }\n      }\n    }\n  }, {\n    key: \"filterEndpoints\",\n    value: function filterEndpoints(allEndpoints) {\n      //\n      // Filter out opaque endpoints or endpoints which can't connect.\n      //\n      var endpoints = allEndpoints.filter(function (e) {\n        return !(e instanceof OpaqueEndpointI) && e.connectable();\n      });\n\n      //\n      // Filter out endpoints according to the mode of the reference.\n      //\n      switch (this.getMode()) {\n        case RefMode.ModeTwoway:\n        case RefMode.ModeOneway:\n        case RefMode.ModeBatchOneway:\n          {\n            //\n            // Filter out datagram endpoints.\n            //\n            endpoints = endpoints.filter(function (e) {\n              return !e.datagram();\n            });\n            break;\n          }\n        case RefMode.ModeDatagram:\n        case RefMode.ModeBatchDatagram:\n          {\n            //\n            // Filter out non-datagram endpoints.\n            //\n            endpoints = endpoints.filter(function (e) {\n              return e.datagram();\n            });\n            break;\n          }\n        default:\n          {\n            Debug.assert(false);\n            break;\n          }\n      }\n\n      //\n      // Sort the endpoints according to the endpoint selection type.\n      //\n      switch (this.getEndpointSelection()) {\n        case EndpointSelectionType.Random:\n          {\n            //\n            // Shuffle the endpoints.\n            //\n            ArrayUtil.shuffle(endpoints);\n            break;\n          }\n        case EndpointSelectionType.Ordered:\n          {\n            // Nothing to do.\n            break;\n          }\n        default:\n          {\n            Debug.assert(false);\n            break;\n          }\n      }\n\n      //\n      // If a secure connection is requested or secure overrides is\n      // set, remove all non-secure endpoints. Otherwise if preferSecure is set\n      // make secure endpoints prefered. By default make non-secure\n      // endpoints preferred over secure endpoints.\n      //\n      var overrides = this.getInstance().defaultsAndOverrides();\n      if (overrides.overrideSecure ? overrides.overrideSecureValue : this.getSecure()) {\n        endpoints = endpoints.filter(function (e) {\n          return e.secure();\n        });\n      } else {\n        var preferSecure = this.getPreferSecure();\n        var compare = function compare(e1, e2) {\n          var ls = e1.secure();\n          var rs = e2.secure();\n          if (ls && rs || !ls && !rs) {\n            return 0;\n          } else if (!ls && rs) {\n            return preferSecure ? 1 : -1;\n          } else {\n            return preferSecure ? -1 : 1;\n          }\n        };\n        endpoints.sort(compare);\n      }\n      return endpoints;\n    }\n  }, {\n    key: \"createConnection\",\n    value: function createConnection(allEndpoints) {\n      var endpoints = this.filterEndpoints(allEndpoints);\n      if (endpoints.length === 0) {\n        return Ice.Promise.reject(new Ice.NoEndpointException(this.toString()));\n      }\n\n      //\n      // Finally, create the connection.\n      //\n      var promise = new Ice.Promise();\n      var factory = this.getInstance().outgoingConnectionFactory();\n      if (this.getCacheConnection() || endpoints.length == 1) {\n        //\n        // Get an existing connection or create one if there's no\n        // existing connection to one of the given endpoints.\n        //\n        var cb = new CreateConnectionCallback(this, null, promise);\n        factory.create(endpoints, false, this.getEndpointSelection()).then(function (connection) {\n          return cb.setConnection(connection);\n        })[\"catch\"](function (ex) {\n          return cb.setException(ex);\n        });\n      } else {\n        //\n        // Go through the list of endpoints and try to create the\n        // connection until it succeeds. This is different from just\n        // calling create() with the given endpoints since this might\n        // create a new connection even if there's an existing\n        // connection for one of the endpoints.\n        //\n        var _cb = new CreateConnectionCallback(this, endpoints, promise);\n        factory.create([endpoints[0]], true, this.getEndpointSelection()).then(function (connection) {\n          return _cb.setConnection(connection);\n        })[\"catch\"](function (ex) {\n          return _cb.setException(ex);\n        });\n      }\n      return promise;\n    }\n  }]);\n}(Reference);\nIce.RoutableReference = RoutableReference;\nmodule.exports.Ice = Ice;\nvar CreateConnectionCallback = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function CreateConnectionCallback(r, endpoints, promise) {\n    _classCallCheck(this, CreateConnectionCallback);\n    this.ref = r;\n    this.endpoints = endpoints;\n    this.promise = promise;\n    this.i = 0;\n    this.exception = null;\n  }\n  return _createClass(CreateConnectionCallback, [{\n    key: \"setConnection\",\n    value: function setConnection(connection) {\n      //\n      // If we have a router, set the object adapter for this router\n      // (if any) to the new connection, so that callbacks from the\n      // router can be received over this new connection.\n      //\n      if (this.ref.getRouterInfo() !== null && this.ref.getRouterInfo().getAdapter() !== null) {\n        connection.setAdapter(this.ref.getRouterInfo().getAdapter());\n      }\n      this.promise.resolve(connection);\n    }\n  }, {\n    key: \"setException\",\n    value: function setException(ex) {\n      var _this5 = this;\n      if (this.exception === null) {\n        this.exception = ex;\n      }\n      if (this.endpoints === null || ++this.i === this.endpoints.length) {\n        this.promise.reject(this.exception);\n        return;\n      }\n      this.ref.getInstance().outgoingConnectionFactory().create([this.endpoints[this.i]], this.i != this.endpoints.length - 1, this.ref.getEndpointSelection()).then(function (connection) {\n        return _this5.setConnection(connection);\n      })[\"catch\"](function (ex) {\n        return _this5.setException(ex);\n      });\n    }\n  }]);\n}();\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/Reference.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/ReferenceMode.js":
/*!***************************************************!*\
  !*** ./node_modules/ice/src/Ice/ReferenceMode.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n\n//\n// Using a separate module for these constants so that ObjectPrx does\n// not need to include Reference.\n//\nIce.ReferenceMode = {\n  ModeTwoway: 0,\n  ModeOneway: 1,\n  ModeBatchOneway: 2,\n  ModeDatagram: 3,\n  ModeBatchDatagram: 4,\n  ModeLast: 4\n};\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/ReferenceMode.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/RequestHandlerFactory.js":
/*!***********************************************************!*\
  !*** ./node_modules/ice/src/Ice/RequestHandlerFactory.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n__webpack_require__(/*! ../Ice/ConnectRequestHandler */ \"./node_modules/ice/src/Ice/ConnectRequestHandler.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/Reference */ \"./node_modules/ice/src/Ice/Reference.js\");\nvar ConnectRequestHandler = Ice.ConnectRequestHandler;\nvar HashMap = Ice.HashMap;\nvar RequestHandlerFactory = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function RequestHandlerFactory(instance) {\n    _classCallCheck(this, RequestHandlerFactory);\n    this._instance = instance;\n    this._handlers = new HashMap(HashMap.compareEquals);\n  }\n  return _createClass(RequestHandlerFactory, [{\n    key: \"getRequestHandler\",\n    value: function getRequestHandler(ref, proxy) {\n      var connect = false;\n      var handler;\n      if (ref.getCacheConnection()) {\n        handler = this._handlers.get(ref);\n        if (!handler) {\n          handler = new ConnectRequestHandler(ref, proxy);\n          this._handlers.set(ref, handler);\n          connect = true;\n        }\n      } else {\n        connect = true;\n        handler = new ConnectRequestHandler(ref, proxy);\n      }\n      if (connect) {\n        ref.getConnection().then(function (connection) {\n          handler.setConnection(connection);\n        }, function (ex) {\n          handler.setException(ex);\n        });\n      }\n      return proxy._setRequestHandler(handler.connect(proxy));\n    }\n  }, {\n    key: \"removeRequestHandler\",\n    value: function removeRequestHandler(ref, handler) {\n      if (ref.getCacheConnection()) {\n        if (this._handlers.get(ref) === handler) {\n          this._handlers[\"delete\"](ref);\n        }\n      }\n    }\n  }]);\n}();\nIce.RequestHandlerFactory = RequestHandlerFactory;\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/RequestHandlerFactory.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/RetryException.js":
/*!****************************************************!*\
  !*** ./node_modules/ice/src/Ice/RetryException.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _wrapNativeSuper(t) { var r = \"function\" == typeof Map ? new Map() : void 0; return _wrapNativeSuper = function _wrapNativeSuper(t) { if (null === t || !_isNativeFunction(t)) return t; if (\"function\" != typeof t) throw new TypeError(\"Super expression must either be null or a function\"); if (void 0 !== r) { if (r.has(t)) return r.get(t); r.set(t, Wrapper); } function Wrapper() { return _construct(t, arguments, _getPrototypeOf(this).constructor); } return Wrapper.prototype = Object.create(t.prototype, { constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf(Wrapper, t); }, _wrapNativeSuper(t); }\nfunction _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _isNativeFunction(t) { try { return -1 !== Function.toString.call(t).indexOf(\"[native code]\"); } catch (n) { return \"function\" == typeof t; } }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n__webpack_require__(/*! ../Ice/Debug */ \"./node_modules/ice/src/Ice/Debug.js\");\n__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\");\nvar RetryException = /*#__PURE__*/function (_Error) {\n  \"use strict\";\n\n  function RetryException(ex) {\n    var _this;\n    _classCallCheck(this, RetryException);\n    _this = _callSuper(this, RetryException);\n    if (ex instanceof Ice.LocalException) {\n      _this._ex = ex;\n    } else {\n      Ice.Debug.assert(ex instanceof RetryException);\n      _this._ex = ex._ex;\n    }\n    return _this;\n  }\n  _inherits(RetryException, _Error);\n  return _createClass(RetryException, [{\n    key: \"inner\",\n    get: function get() {\n      return this._ex;\n    }\n  }]);\n}(/*#__PURE__*/_wrapNativeSuper(Error));\nIce.RetryException = RetryException;\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/RetryException.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/RetryQueue.js":
/*!************************************************!*\
  !*** ./node_modules/ice/src/Ice/RetryQueue.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\").Ice);\nvar RetryTask = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function RetryTask(instance, queue, outAsync, interval) {\n    _classCallCheck(this, RetryTask);\n    this._instance = instance;\n    this._queue = queue;\n    this._outAsync = outAsync;\n  }\n  return _createClass(RetryTask, [{\n    key: \"run\",\n    value: function run() {\n      this._outAsync.retry();\n      this._queue.remove(this);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      try {\n        this._outAsync.abort(new Ice.CommunicatorDestroyedException());\n      } catch (ex) {\n        // Abort shouldn't throw if there's no callback, ignore.\n      }\n    }\n  }, {\n    key: \"asyncRequestCanceled\",\n    value: function asyncRequestCanceled(outAsync, ex) {\n      if (this._queue.cancel(this)) {\n        if (this._instance.traceLevels().retry >= 1) {\n          this._instance.initializationData().logger.trace(this._instance.traceLevels().retryCat, \"operation retry canceled\\n\" + ex.toString());\n        }\n        this._outAsync.completedEx(ex);\n      }\n    }\n  }]);\n}();\nvar RetryQueue = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function RetryQueue(instance) {\n    _classCallCheck(this, RetryQueue);\n    this._instance = instance;\n    this._requests = [];\n  }\n  return _createClass(RetryQueue, [{\n    key: \"add\",\n    value: function add(outAsync, interval) {\n      if (this._instance === null) {\n        throw new Ice.CommunicatorDestroyedException();\n      }\n      var task = new RetryTask(this._instance, this, outAsync);\n      outAsync.cancelable(task); // This will throw if the request is canceled\n      task.token = this._instance.timer().schedule(function () {\n        return task.run();\n      }, interval);\n      this._requests.push(task);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var _this = this;\n      this._requests.forEach(function (request) {\n        _this._instance.timer().cancel(request.token);\n        request.destroy();\n      });\n      this._requests = [];\n      this._instance = null;\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(task) {\n      var idx = this._requests.indexOf(task);\n      if (idx >= 0) {\n        this._requests.splice(idx, 1);\n      }\n    }\n  }, {\n    key: \"cancel\",\n    value: function cancel(task) {\n      var idx = this._requests.indexOf(task);\n      if (idx >= 0) {\n        this._requests.splice(idx, 1);\n        return this._instance.timer().cancel(task.token);\n      }\n      return false;\n    }\n  }]);\n}();\nIce.RetryQueue = RetryQueue;\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/RetryQueue.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Router.js":
/*!********************************************!*\
  !*** ./node_modules/ice/src/Ice/Router.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `Router.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nvar _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\");\n__webpack_require__(/*! ../Ice/ObjectPrx */ \"./node_modules/ice/src/Ice/ObjectPrx.js\");\n__webpack_require__(/*! ../Ice/Operation */ \"./node_modules/ice/src/Ice/Operation.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\n__webpack_require__(/*! ../Ice/BuiltinSequences */ \"./node_modules/ice/src/Ice/BuiltinSequences.js\");\nvar Ice = _ModuleRegistry.module(\"Ice\");\nvar Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n\nvar iceC_Ice_Router_ids = [\"::Ice::Object\", \"::Ice::Router\"];\n\n/**\n * The Ice router interface. Routers can be set either globally with\n * {@link Communicator#setDefaultRouter}, or with <code>ice_router</code> on specific\n * proxies.\n *\n **/\nIce.Router = /*#__PURE__*/function (_Ice$Object) {\n  \"use strict\";\n\n  function _class() {\n    _classCallCheck(this, _class);\n    return _callSuper(this, _class, arguments);\n  }\n  _inherits(_class, _Ice$Object);\n  return _createClass(_class);\n}(Ice.Object);\nIce.RouterPrx = /*#__PURE__*/function (_Ice$ObjectPrx) {\n  \"use strict\";\n\n  function _class2() {\n    _classCallCheck(this, _class2);\n    return _callSuper(this, _class2, arguments);\n  }\n  _inherits(_class2, _Ice$ObjectPrx);\n  return _createClass(_class2);\n}(Ice.ObjectPrx);\nSlice.defineOperations(Ice.Router, Ice.RouterPrx, iceC_Ice_Router_ids, 1, {\n  \"getClientProxy\": [, 2, 1,, [9],, [[1,, 1]],,,],\n  \"getServerProxy\": [, 2, 1,, [9],,,,,],\n  \"addProxies\": [, 2, 2,, [\"Ice.ObjectProxySeqHelper\"], [[\"Ice.ObjectProxySeqHelper\"]],,,,]\n});\nvar iceC_Ice_RouterFinder_ids = [\"::Ice::Object\", \"::Ice::RouterFinder\"];\n\n/**\n * This inferface should be implemented by services implementing the\n * Ice::Router interface. It should be advertised through an Ice\n * object with the identity `Ice/RouterFinder'. This allows clients to\n * retrieve the router proxy with just the endpoint information of the\n * service.\n *\n **/\nIce.RouterFinder = /*#__PURE__*/function (_Ice$Object2) {\n  \"use strict\";\n\n  function _class3() {\n    _classCallCheck(this, _class3);\n    return _callSuper(this, _class3, arguments);\n  }\n  _inherits(_class3, _Ice$Object2);\n  return _createClass(_class3);\n}(Ice.Object);\nIce.RouterFinderPrx = /*#__PURE__*/function (_Ice$ObjectPrx2) {\n  \"use strict\";\n\n  function _class4() {\n    _classCallCheck(this, _class4);\n    return _callSuper(this, _class4, arguments);\n  }\n  _inherits(_class4, _Ice$ObjectPrx2);\n  return _createClass(_class4);\n}(Ice.ObjectPrx);\nSlice.defineOperations(Ice.RouterFinder, Ice.RouterFinderPrx, iceC_Ice_RouterFinder_ids, 1, {\n  \"getRouter\": [,,,, [\"Ice.RouterPrx\"],,,,,]\n});\n/* slice2js browser-bundle-skip */\nexports.Ice = Ice;\n/* slice2js browser-bundle-skip-end */\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/Router.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/RouterInfo.js":
/*!************************************************!*\
  !*** ./node_modules/ice/src/Ice/RouterInfo.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n__webpack_require__(/*! ../Ice/Debug */ \"./node_modules/ice/src/Ice/Debug.js\");\n__webpack_require__(/*! ../Ice/Exception */ \"./node_modules/ice/src/Ice/Exception.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\");\n__webpack_require__(/*! ../Ice/Promise */ \"./node_modules/ice/src/Ice/Promise.js\");\nvar Debug = Ice.Debug;\nvar HashMap = Ice.HashMap;\nvar RouterInfo = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function RouterInfo(router) {\n    _classCallCheck(this, RouterInfo);\n    this._router = router;\n    Debug.assert(this._router !== null);\n    this._clientEndpoints = null;\n    this._adapter = null;\n    this._identities = new HashMap(HashMap.compareEquals); // Set<Identity> = Map<Identity, 1>\n    this._evictedIdentities = [];\n    this._hasRoutingTable = false;\n  }\n  return _createClass(RouterInfo, [{\n    key: \"destroy\",\n    value: function destroy() {\n      this._clientEndpoints = [];\n      this._adapter = null;\n      this._identities.clear();\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(rhs) {\n      if (this === rhs) {\n        return true;\n      }\n      if (rhs instanceof RouterInfo) {\n        return this._router.equals(rhs._router);\n      }\n      return false;\n    }\n  }, {\n    key: \"hashCode\",\n    value: function hashCode() {\n      return this._router.hashCode();\n    }\n  }, {\n    key: \"getRouter\",\n    value: function getRouter() {\n      //\n      // No mutex lock necessary, _router is immutable.\n      //\n      return this._router;\n    }\n  }, {\n    key: \"getClientEndpoints\",\n    value: function getClientEndpoints() {\n      var _this = this;\n      var promise = new Ice.Promise();\n      if (this._clientEndpoints !== null) {\n        promise.resolve(this._clientEndpoints);\n      } else {\n        this._router.getClientProxy().then(function (result) {\n          return _this.setClientEndpoints(result[0], result[1] !== undefined ? result[1] : true, promise);\n        })[\"catch\"](promise.reject);\n      }\n      return promise;\n    }\n  }, {\n    key: \"getServerEndpoints\",\n    value: function getServerEndpoints() {\n      return this._router.getServerProxy().then(function (serverProxy) {\n        if (serverProxy === null) {\n          throw new Ice.NoEndpointException();\n        }\n        serverProxy = serverProxy.ice_router(null); // The server proxy cannot be routed.\n        return serverProxy._getReference().getEndpoints();\n      });\n    }\n  }, {\n    key: \"addProxy\",\n    value: function addProxy(proxy) {\n      var _this2 = this;\n      Debug.assert(proxy !== null);\n      if (!this._hasRoutingTable) {\n        return Ice.Promise.resolve(); // The router implementation doesn't maintain a routing table.\n      } else if (this._identities.has(proxy.ice_getIdentity())) {\n        //\n        // Only add the proxy to the router if it's not already in our local map.\n        //\n        return Ice.Promise.resolve();\n      } else {\n        return this._router.addProxies([proxy]).then(function (evictedProxies) {\n          _this2.addAndEvictProxies(proxy, evictedProxies);\n        });\n      }\n    }\n  }, {\n    key: \"setAdapter\",\n    value: function setAdapter(adapter) {\n      this._adapter = adapter;\n    }\n  }, {\n    key: \"getAdapter\",\n    value: function getAdapter() {\n      return this._adapter;\n    }\n  }, {\n    key: \"clearCache\",\n    value: function clearCache(ref) {\n      this._identities[\"delete\"](ref.getIdentity());\n    }\n  }, {\n    key: \"setClientEndpoints\",\n    value: function setClientEndpoints(clientProxy, hasRoutingTable, promise) {\n      var _this3 = this;\n      if (this._clientEndpoints === null) {\n        this._hasRoutingTable = hasRoutingTable;\n        if (clientProxy === null) {\n          //\n          // If getClientProxy() return nil, use router endpoints.\n          //\n          this._clientEndpoints = this._router._getReference().getEndpoints();\n          promise.resolve(this._clientEndpoints);\n        } else {\n          clientProxy = clientProxy.ice_router(null); // The client proxy cannot be routed.\n\n          //\n          // In order to avoid creating a new connection to the\n          // router, we must use the same timeout as the already\n          // existing connection.\n          //\n          this._router.ice_getConnection().then(function (con) {\n            _this3._clientEndpoints = clientProxy.ice_timeout(con.timeout())._getReference().getEndpoints();\n            promise.resolve(_this3._clientEndpoints);\n          })[\"catch\"](promise.reject);\n        }\n      } else {\n        promise.resolve(this._clientEndpoints);\n      }\n    }\n  }, {\n    key: \"addAndEvictProxies\",\n    value: function addAndEvictProxies(proxy, evictedProxies) {\n      var _this4 = this;\n      //\n      // Check if the proxy hasn't already been evicted by a\n      // concurrent addProxies call. If it's the case, don't\n      // add it to our local map.\n      //\n      var index = this._evictedIdentities.findIndex(function (e) {\n        return e.equals(proxy.ice_getIdentity());\n      });\n      if (index >= 0) {\n        this._evictedIdentities.splice(index, 1);\n      } else {\n        //\n        // If we successfully added the proxy to the router,\n        // we add it to our local map.\n        //\n        this._identities.set(proxy.ice_getIdentity(), 1);\n      }\n\n      //\n      // We also must remove whatever proxies the router evicted.\n      //\n      evictedProxies.forEach(function (proxy) {\n        _this4._identities[\"delete\"](proxy.ice_getIdentity());\n      });\n    }\n  }]);\n}();\nIce.RouterInfo = RouterInfo;\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/RouterInfo.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/RouterManager.js":
/*!***************************************************!*\
  !*** ./node_modules/ice/src/Ice/RouterManager.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/Router */ \"./node_modules/ice/src/Ice/Router.js\");\n__webpack_require__(/*! ../Ice/RouterInfo */ \"./node_modules/ice/src/Ice/RouterInfo.js\");\nvar HashMap = Ice.HashMap;\nvar RouterInfo = Ice.RouterInfo;\nvar RouterPrx = Ice.RouterPrx;\nvar RouterManager = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function RouterManager() {\n    _classCallCheck(this, RouterManager);\n    this._table = new HashMap(HashMap.compareEquals); // Map<Ice.RouterPrx, RouterInfo>\n  }\n  return _createClass(RouterManager, [{\n    key: \"destroy\",\n    value: function destroy() {\n      var _iterator = _createForOfIteratorHelper(this._table.values()),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var router = _step.value;\n          router.destroy();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      this._table.clear();\n    }\n\n    //\n    // Returns router info for a given router. Automatically creates\n    // the router info if it doesn't exist yet.\n    //\n  }, {\n    key: \"find\",\n    value: function find(rtr) {\n      if (rtr === null) {\n        return null;\n      }\n\n      //\n      // The router cannot be routed.\n      //\n      var router = RouterPrx.uncheckedCast(rtr.ice_router(null));\n      var info = this._table.get(router);\n      if (info === undefined) {\n        info = new RouterInfo(router);\n        this._table.set(router, info);\n      }\n      return info;\n    }\n  }, {\n    key: \"erase\",\n    value: function erase(rtr) {\n      var info = null;\n      if (rtr !== null) {\n        // The router cannot be routed.\n        var router = RouterPrx.uncheckedCast(rtr.ice_router(null));\n        info = this._table.get(router);\n        this._table[\"delete\"](router);\n      }\n      return info;\n    }\n  }]);\n}();\nIce.RouterManager = RouterManager;\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/RouterManager.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/ServantManager.js":
/*!****************************************************!*\
  !*** ./node_modules/ice/src/Ice/ServantManager.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n__webpack_require__(/*! ../Ice/Debug */ \"./node_modules/ice/src/Ice/Debug.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/IdentityUtil */ \"./node_modules/ice/src/Ice/IdentityUtil.js\");\n__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\");\n__webpack_require__(/*! ../Ice/StringUtil */ \"./node_modules/ice/src/Ice/StringUtil.js\");\nvar Debug = Ice.Debug;\nvar HashMap = Ice.HashMap;\nvar StringUtil = Ice.StringUtil;\n\n//\n// Only for use by Ice.ObjectAdatperI.\n//\nvar ServantManager = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function ServantManager(instance, adapterName) {\n    _classCallCheck(this, ServantManager);\n    this._instance = instance;\n    this._adapterName = adapterName;\n    // Map<Ice.Identity, Map<String, Ice.Object> >\n    this._servantMapMap = new HashMap(HashMap.compareEquals);\n    // Map<String, Ice.Object>\n    this._defaultServantMap = new Map();\n    // Map<String, Ice.ServantLocator>\n    this._locatorMap = new Map();\n  }\n  return _createClass(ServantManager, [{\n    key: \"addServant\",\n    value: function addServant(servant, ident, facet) {\n      Debug.assert(this._instance !== null); // Must not be called after destruction.\n\n      if (facet === null) {\n        facet = \"\";\n      }\n      var m = this._servantMapMap.get(ident);\n      if (m === undefined) {\n        m = new Map();\n        this._servantMapMap.set(ident, m);\n      } else if (m.has(facet)) {\n        var ex = new Ice.AlreadyRegisteredException();\n        ex.id = Ice.identityToString(ident, this._instance.toStringMode());\n        ex.kindOfObject = \"servant\";\n        if (facet.length > 0) {\n          ex.id += \" -f \" + StringUtil.escapeString(facet, \"\", this._instance.toStringMode());\n        }\n        throw ex;\n      }\n      m.set(facet, servant);\n    }\n  }, {\n    key: \"addDefaultServant\",\n    value: function addDefaultServant(servant, category) {\n      Debug.assert(this._instance !== null); // Must not be called after destruction\n\n      if (this._defaultServantMap.has(category)) {\n        var ex = new Ice.AlreadyRegisteredException();\n        ex.kindOfObject = \"default servant\";\n        ex.id = category;\n        throw ex;\n      }\n      this._defaultServantMap.set(category, servant);\n    }\n  }, {\n    key: \"removeServant\",\n    value: function removeServant(ident, facet) {\n      Debug.assert(this._instance !== null); // Must not be called after destruction.\n\n      if (facet === null) {\n        facet = \"\";\n      }\n      var m = this._servantMapMap.get(ident);\n      if (m === undefined || !m.has(facet)) {\n        var ex = new Ice.NotRegisteredException();\n        ex.id = Ice.identityToString(ident, this._instance.toStringMode());\n        ex.kindOfObject = \"servant\";\n        if (facet.length > 0) {\n          ex.id += \" -f \" + StringUtil.escapeString(facet, \"\", this._instance.toStringMode());\n        }\n        throw ex;\n      }\n      var obj = m.get(facet);\n      m[\"delete\"](facet);\n      if (m.size === 0) {\n        this._servantMapMap[\"delete\"](ident);\n      }\n      return obj;\n    }\n  }, {\n    key: \"removeDefaultServant\",\n    value: function removeDefaultServant(category) {\n      Debug.assert(this._instance !== null); // Must not be called after destruction.\n\n      var obj = this._defaultServantMap.get(category);\n      if (obj === undefined) {\n        var ex = new Ice.NotRegisteredException();\n        ex.kindOfObject = \"default servant\";\n        ex.id = category;\n        throw ex;\n      }\n      this._defaultServantMap[\"delete\"](category);\n      return obj;\n    }\n  }, {\n    key: \"removeAllFacets\",\n    value: function removeAllFacets(ident) {\n      Debug.assert(this._instance !== null); // Must not be called after destruction.\n\n      var m = this._servantMapMap.get(ident);\n      if (m === undefined) {\n        var ex = new Ice.NotRegisteredException();\n        ex.id = Ice.identityToString(ident, this._instance.toStringMode());\n        ex.kindOfObject = \"servant\";\n        throw ex;\n      }\n      this._servantMapMap[\"delete\"](ident);\n      return m;\n    }\n  }, {\n    key: \"findServant\",\n    value: function findServant(ident, facet) {\n      if (facet === null) {\n        facet = \"\";\n      }\n      var m = this._servantMapMap.get(ident);\n      var obj = null;\n      if (m === undefined) {\n        obj = this._defaultServantMap.get(ident.category);\n        if (obj === undefined) {\n          obj = this._defaultServantMap.get(\"\");\n        }\n      } else {\n        obj = m.get(facet);\n      }\n      return obj === undefined ? null : obj;\n    }\n  }, {\n    key: \"findDefaultServant\",\n    value: function findDefaultServant(category) {\n      Debug.assert(this._instance !== null); // Must not be called after destruction.\n\n      var ds = this._defaultServantMap.get(category);\n      return ds === undefined ? null : ds;\n    }\n  }, {\n    key: \"findAllFacets\",\n    value: function findAllFacets(ident) {\n      Debug.assert(this._instance !== null); // Must not be called after destruction.\n\n      var m = this._servantMapMap.get(ident);\n      if (m !== undefined) {\n        return new Map(m);\n      }\n      return new Map();\n    }\n  }, {\n    key: \"hasServant\",\n    value: function hasServant(ident) {\n      var m = this._servantMapMap.get(ident);\n      if (m === undefined) {\n        return false;\n      } else {\n        Debug.assert(m.size > 0);\n        return true;\n      }\n    }\n  }, {\n    key: \"addServantLocator\",\n    value: function addServantLocator(locator, category) {\n      Debug.assert(this._instance !== null); // Must not be called after destruction.\n\n      if (this._locatorMap.has(category)) {\n        var ex = new Ice.AlreadyRegisteredException();\n        ex.id = StringUtil.escapeString(category, \"\", this._instance.toStringMode());\n        ex.kindOfObject = \"servant locator\";\n        throw ex;\n      }\n      this._locatorMap.set(category, locator);\n    }\n  }, {\n    key: \"removeServantLocator\",\n    value: function removeServantLocator(category) {\n      Debug.assert(this._instance !== null); // Must not be called after destruction.\n\n      var l = this._locatorMap.get(category);\n      if (l === undefined) {\n        var ex = new Ice.NotRegisteredException();\n        ex.id = StringUtil.escapeString(category, \"\", this._instance.toStringMode());\n        ex.kindOfObject = \"servant locator\";\n        throw ex;\n      }\n      this._locatorMap[\"delete\"](category);\n      return l;\n    }\n  }, {\n    key: \"findServantLocator\",\n    value: function findServantLocator(category) {\n      var l = this._locatorMap.get(category);\n      return l === undefined ? null : l;\n    }\n\n    //\n    // Only for use by Ice.ObjectAdapterI.\n    //\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      Debug.assert(this._instance !== null); // Must not be called after destruction.\n      var logger = this._instance.initializationData().logger;\n      this._servantMapMap.clear();\n      this._defaultServantMap.clear();\n      var locatorMap = new Map(this._locatorMap);\n      this._locatorMap.clear();\n      this._instance = null;\n      var _iterator = _createForOfIteratorHelper(locatorMap),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _slicedToArray(_step.value, 2),\n            key = _step$value[0],\n            locator = _step$value[1];\n          try {\n            locator.deactivate(key);\n          } catch (ex) {\n            logger.error(\"exception during locator deactivation:\\nobject adapter: `\" + this._adapterName + \"'\\nlocator category: `\" + key + \"'\\n\" + ex.toString());\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }]);\n}();\nIce.ServantManager = ServantManager;\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/ServantManager.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/SliceChecksumDict.js":
/*!*******************************************************!*\
  !*** ./node_modules/ice/src/Ice/SliceChecksumDict.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `SliceChecksumDict.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nvar _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\nvar Ice = _ModuleRegistry.module(\"Ice\");\nvar Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n\nSlice.defineDictionary(Ice, \"SliceChecksumDict\", \"SliceChecksumDictHelper\", \"Ice.StringHelper\", \"Ice.StringHelper\", false, undefined, undefined);\n/* slice2js browser-bundle-skip */\nexports.Ice = Ice;\n/* slice2js browser-bundle-skip-end */\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/SliceChecksumDict.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/SocketOperation.js":
/*!*****************************************************!*\
  !*** ./node_modules/ice/src/Ice/SocketOperation.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\nIce.SocketOperation = {\n  None: 0,\n  Read: 1,\n  Write: 2,\n  Connect: 2 // Same as Write\n};\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/SocketOperation.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Stream.js":
/*!********************************************!*\
  !*** ./node_modules/ice/src/Ice/Stream.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\nvar _ModuleRegistry = Ice._ModuleRegistry;\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/Buffer */ \"./node_modules/ice/src/Ice/Buffer.js\");\n__webpack_require__(/*! ../Ice/CompactIdRegistry */ \"./node_modules/ice/src/Ice/CompactIdRegistry.js\");\n__webpack_require__(/*! ../Ice/Debug */ \"./node_modules/ice/src/Ice/Debug.js\");\n__webpack_require__(/*! ../Ice/ExUtil */ \"./node_modules/ice/src/Ice/ExUtil.js\");\n__webpack_require__(/*! ../Ice/Exception */ \"./node_modules/ice/src/Ice/Exception.js\");\n__webpack_require__(/*! ../Ice/FormatType */ \"./node_modules/ice/src/Ice/FormatType.js\");\n__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\");\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/OptionalFormat */ \"./node_modules/ice/src/Ice/OptionalFormat.js\");\n__webpack_require__(/*! ../Ice/Protocol */ \"./node_modules/ice/src/Ice/Protocol.js\");\n__webpack_require__(/*! ../Ice/TraceUtil */ \"./node_modules/ice/src/Ice/TraceUtil.js\");\n__webpack_require__(/*! ../Ice/UnknownSlicedValue */ \"./node_modules/ice/src/Ice/UnknownSlicedValue.js\");\n__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\");\n__webpack_require__(/*! ../Ice/Version */ \"./node_modules/ice/src/Ice/Version.js\");\nvar ArrayUtil = Ice.ArrayUtil;\nvar Debug = Ice.Debug;\nvar ExUtil = Ice.ExUtil;\nvar FormatType = Ice.FormatType;\nvar OptionalFormat = Ice.OptionalFormat;\nvar Protocol = Ice.Protocol;\nvar SlicedData = Ice.SlicedData;\nvar TraceUtil = Ice.TraceUtil;\nvar SliceType = {\n  NoSlice: 0,\n  ValueSlice: 1,\n  ExceptionSlice: 2\n};\n\n//\n// Number.isNaN polyfill for compatibility with IE\n//\n// see: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN\n//\nNumber.isNaN = Number.isNaN || function (value) {\n  return typeof value === \"number\" && isNaN(value);\n};\n\n//\n// InputStream\n//\nvar IndirectPatchEntry = /*#__PURE__*/_createClass(function IndirectPatchEntry(index, cb) {\n  \"use strict\";\n\n  _classCallCheck(this, IndirectPatchEntry);\n  this.index = index;\n  this.cb = cb;\n});\nvar EncapsDecoder = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function EncapsDecoder(stream, encaps, sliceValues, f) {\n    _classCallCheck(this, EncapsDecoder);\n    this._stream = stream;\n    this._encaps = encaps;\n    this._sliceValues = sliceValues;\n    this._valueFactoryManager = f;\n    this._patchMap = null; // Lazy initialized, Map<int, Patcher[] >()\n    this._unmarshaledMap = new Map(); // Map<int, Ice.Value>()\n    this._typeIdMap = null; // Lazy initialized, Map<int, String>\n    this._typeIdIndex = 0;\n    this._valueList = null; // Lazy initialized. Ice.Value[]\n  }\n  return _createClass(EncapsDecoder, [{\n    key: \"readOptional\",\n    value: function readOptional() {\n      return false;\n    }\n  }, {\n    key: \"readPendingValues\",\n    value: function readPendingValues() {}\n  }, {\n    key: \"readTypeId\",\n    value: function readTypeId(isIndex) {\n      if (this._typeIdMap === null)\n        // Lazy initialization\n        {\n          this._typeIdMap = new Map(); // Map<int, String>();\n        }\n      var typeId;\n      if (isIndex) {\n        typeId = this._typeIdMap.get(this._stream.readSize());\n        if (typeId === undefined) {\n          throw new Ice.UnmarshalOutOfBoundsException();\n        }\n      } else {\n        typeId = this._stream.readString();\n        this._typeIdMap.set(++this._typeIdIndex, typeId);\n      }\n      return typeId;\n    }\n  }, {\n    key: \"newInstance\",\n    value: function newInstance(typeId) {\n      //\n      // Try to find a factory registered for the specific type.\n      //\n      var userFactory = this._valueFactoryManager.find(typeId);\n      var v = null;\n      if (userFactory !== undefined) {\n        v = userFactory(typeId);\n      }\n\n      //\n      // If that fails, invoke the default factory if one has been\n      // registered.\n      //\n      if (v === null || v === undefined) {\n        userFactory = this._valueFactoryManager.find(\"\");\n        if (userFactory !== undefined) {\n          v = userFactory(typeId);\n        }\n      }\n\n      //\n      // Last chance: try to instantiate the class dynamically.\n      //\n      if (v === null || v === undefined) {\n        v = this._stream.createInstance(typeId);\n      }\n      return v;\n    }\n  }, {\n    key: \"addPatchEntry\",\n    value: function addPatchEntry(index, cb) {\n      Debug.assert(index > 0);\n\n      //\n      // Check if we have already unmarshaled the instance. If that's the case,\n      // just call the callback and we're done.\n      //\n      var obj = this._unmarshaledMap.get(index);\n      if (obj !== undefined && obj !== null) {\n        cb(obj);\n        return;\n      }\n      if (this._patchMap === null)\n        // Lazy initialization\n        {\n          this._patchMap = new Map(); // Map<Integer, Patcher[] >();\n        }\n\n      //\n      // Add a patch entry if the instance isn't unmarshaled yet,\n      // the callback will be called when the instance is\n      // unmarshaled.\n      //\n      var l = this._patchMap.get(index);\n      if (l === undefined) {\n        //\n        // We have no outstanding instances to be patched for this\n        // index, so make a new entry in the patch map.\n        //\n        l = []; // ReadValueCallback[]\n        this._patchMap.set(index, l);\n      }\n\n      //\n      // Append a patch entry for this instance.\n      //\n      l.push(cb);\n    }\n  }, {\n    key: \"unmarshal\",\n    value: function unmarshal(index, v) {\n      //\n      // Add the instance to the map of unmarshaled instances, this must\n      // be done before reading the instances (for circular references).\n      //\n      this._unmarshaledMap.set(index, v);\n\n      //\n      // Read the instance.\n      //\n      v._iceRead(this._stream);\n      if (this._patchMap !== null) {\n        //\n        // Patch all instances now that the instance is unmarshaled.\n        //\n        var l = this._patchMap.get(index);\n        if (l !== undefined) {\n          Debug.assert(l.length > 0);\n\n          //\n          // Patch all pointers that refer to the instance.\n          //\n          for (var i = 0; i < l.length; ++i) {\n            l[i](v);\n          }\n\n          //\n          // Clear out the patch map for that index -- there is nothing left\n          // to patch for that index for the time being.\n          //\n          this._patchMap[\"delete\"](index);\n        }\n      }\n      if ((this._patchMap === null || this._patchMap.size === 0) && this._valueList === null) {\n        try {\n          v.ice_postUnmarshal();\n        } catch (ex) {\n          this._stream.instance.initializationData().logger.warning(\"exception raised by ice_postUnmarshal:\\n\" + ex.toString());\n        }\n      } else {\n        if (this._valueList === null)\n          // Lazy initialization\n          {\n            this._valueList = []; // Ice.Value[]\n          }\n        this._valueList.push(v);\n        if (this._patchMap === null || this._patchMap.size === 0) {\n          //\n          // Iterate over the instance list and invoke ice_postUnmarshal on\n          // each instance. We must do this after all instances have been\n          // unmarshaled in order to ensure that any instance data members\n          // have been properly patched.\n          //\n          for (var _i = 0; _i < this._valueList.length; _i++) {\n            try {\n              this._valueList[_i].ice_postUnmarshal();\n            } catch (ex) {\n              this._stream.instance.initializationData().logger.warning(\"exception raised by ice_postUnmarshal:\\n\" + ex.toString());\n            }\n          }\n          this._valueList = [];\n        }\n      }\n    }\n  }]);\n}();\nvar EncapsDecoder10 = /*#__PURE__*/function (_EncapsDecoder) {\n  \"use strict\";\n\n  function EncapsDecoder10(stream, encaps, sliceValues, f) {\n    var _this;\n    _classCallCheck(this, EncapsDecoder10);\n    _this = _callSuper(this, EncapsDecoder10, [stream, encaps, sliceValues, f]);\n    _this._sliceType = SliceType.NoSlice;\n    return _this;\n  }\n  _inherits(EncapsDecoder10, _EncapsDecoder);\n  return _createClass(EncapsDecoder10, [{\n    key: \"readValue\",\n    value: function readValue(cb) {\n      Debug.assert(cb !== null);\n\n      //\n      // Instance references are encoded as a negative integer in 1.0.\n      //\n      var index = this._stream.readInt();\n      if (index > 0) {\n        throw new Ice.MarshalException(\"invalid object id\");\n      }\n      index = -index;\n      if (index === 0) {\n        cb(null);\n      } else {\n        this.addPatchEntry(index, cb);\n      }\n    }\n  }, {\n    key: \"throwException\",\n    value: function throwException() {\n      Debug.assert(this._sliceType === SliceType.NoSlice);\n\n      //\n      // User exceptions with the 1.0 encoding start with a boolean flag\n      // that indicates whether or not the exception has classes.\n      //\n      // This allows reading the pending instances even if some part of\n      // the exception was sliced.\n      //\n      var usesClasses = this._stream.readBool();\n      this._sliceType = SliceType.ExceptionSlice;\n      this._skipFirstSlice = false;\n\n      //\n      // Read the first slice header.\n      //\n      this.startSlice();\n      var mostDerivedId = this._typeId;\n      while (true) {\n        var userEx = this._stream.createUserException(this._typeId);\n\n        //\n        // We found the exception.\n        //\n        if (userEx !== null) {\n          userEx._read(this._stream);\n          if (usesClasses) {\n            this.readPendingValues();\n          }\n          throw userEx;\n\n          // Never reached.\n        }\n\n        //\n        // Slice off what we don't understand.\n        //\n        this.skipSlice();\n        try {\n          this.startSlice();\n        } catch (ex) {\n          //\n          // An oversight in the 1.0 encoding means there is no marker to indicate\n          // the last slice of an exception. As a result, we just try to read the\n          // next type ID, which raises UnmarshalOutOfBoundsException when the\n          // input buffer underflows.\n          //\n          // Set the reason member to a more helpful message.\n          //\n          if (ex instanceof Ice.UnmarshalOutOfBoundsException) {\n            ex.reason = \"unknown exception type `\" + mostDerivedId + \"'\";\n          }\n          throw ex;\n        }\n      }\n    }\n  }, {\n    key: \"startInstance\",\n    value: function startInstance(sliceType) {\n      Debug.assert(this._sliceType === sliceType);\n      this._skipFirstSlice = true;\n    }\n  }, {\n    key: \"endInstance\",\n    value: function endInstance(preserve) {\n      //\n      // Read the Ice::Object slice.\n      //\n      if (this._sliceType === SliceType.ValueSlice) {\n        this.startSlice();\n        var sz = this._stream.readSize(); // For compatibility with the old AFM.\n        if (sz !== 0) {\n          throw new Ice.MarshalException(\"invalid Object slice\");\n        }\n        this.endSlice();\n      }\n      this._sliceType = SliceType.NoSlice;\n      return null;\n    }\n  }, {\n    key: \"startSlice\",\n    value: function startSlice() {\n      //\n      // If first slice, don't read the header, it was already read in\n      // readInstance or throwException to find the factory.\n      //\n      if (this._skipFirstSlice) {\n        this._skipFirstSlice = false;\n        return this._typeId;\n      }\n\n      //\n      // For instances, first read the type ID boolean which indicates\n      // whether or not the type ID is encoded as a string or as an\n      // index. For exceptions, the type ID is always encoded as a\n      // string.\n      //\n      if (this._sliceType === SliceType.ValueSlice)\n        // For exceptions, the type ID is always encoded as a string\n        {\n          var isIndex = this._stream.readBool();\n          this._typeId = this.readTypeId(isIndex);\n        } else {\n        this._typeId = this._stream.readString();\n      }\n      this._sliceSize = this._stream.readInt();\n      if (this._sliceSize < 4) {\n        throw new Ice.UnmarshalOutOfBoundsException();\n      }\n      return this._typeId;\n    }\n  }, {\n    key: \"endSlice\",\n    value: function endSlice() {}\n  }, {\n    key: \"skipSlice\",\n    value: function skipSlice() {\n      this._stream.traceSkipSlice(this._typeId, this._sliceType);\n      Debug.assert(this._sliceSize >= 4);\n      this._stream.skip(this._sliceSize - 4);\n    }\n  }, {\n    key: \"readPendingValues\",\n    value: function readPendingValues() {\n      var num;\n      do {\n        num = this._stream.readSize();\n        for (var k = num; k > 0; --k) {\n          this.readInstance();\n        }\n      } while (num > 0);\n      if (this._patchMap !== null && this._patchMap.size !== 0) {\n        //\n        // If any entries remain in the patch map, the sender has sent an index for an instance, but failed\n        // to supply the instance.\n        //\n        throw new Ice.MarshalException(\"index for class received, but no instance\");\n      }\n    }\n  }, {\n    key: \"readInstance\",\n    value: function readInstance() {\n      var index = this._stream.readInt();\n      var v = null;\n      if (index <= 0) {\n        throw new Ice.MarshalException(\"invalid object id\");\n      }\n      this._sliceType = SliceType.ValueSlice;\n      this._skipFirstSlice = false;\n\n      //\n      // Read the first slice header.\n      //\n      this.startSlice();\n      var mostDerivedId = this._typeId;\n      while (true) {\n        //\n        // For the 1.0 encoding, the type ID for the base Object class\n        // marks the last slice.\n        //\n        if (this._typeId == Ice.Value.ice_staticId()) {\n          throw new Ice.NoValueFactoryException(\"\", mostDerivedId);\n        }\n        v = this.newInstance(this._typeId);\n\n        //\n        // We found a factory, we get out of this loop.\n        //\n        if (v) {\n          break;\n        }\n\n        //\n        // If slicing is disabled, stop unmarshaling.\n        //\n        if (!this._sliceValues) {\n          throw new Ice.NoValueFactoryException(\"no value factory found and slicing is disabled\", this._typeId);\n        }\n\n        //\n        // Slice off what we don't understand.\n        //\n        this.skipSlice();\n        this.startSlice(); // Read next Slice header for next iteration.\n      }\n\n      //\n      // Unmarshal the instance and add it to the map of unmarshaled instances.\n      //\n      this.unmarshal(index, v);\n    }\n  }]);\n}(EncapsDecoder);\nvar EncapsDecoder11 = /*#__PURE__*/function (_EncapsDecoder2) {\n  \"use strict\";\n\n  function EncapsDecoder11(stream, encaps, sliceValues, f, r) {\n    var _this2;\n    _classCallCheck(this, EncapsDecoder11);\n    _this2 = _callSuper(this, EncapsDecoder11, [stream, encaps, sliceValues, f]);\n    _this2._compactIdResolver = r;\n    _this2._current = null;\n    _this2._valueIdIndex = 1;\n    return _this2;\n  }\n  _inherits(EncapsDecoder11, _EncapsDecoder2);\n  return _createClass(EncapsDecoder11, [{\n    key: \"readValue\",\n    value: function readValue(cb) {\n      var index = this._stream.readSize();\n      if (index < 0) {\n        throw new Ice.MarshalException(\"invalid object id\");\n      } else if (index === 0) {\n        if (cb !== null) {\n          cb(null);\n        }\n      } else if (this._current !== null && (this._current.sliceFlags & Protocol.FLAG_HAS_INDIRECTION_TABLE) !== 0) {\n        //\n        // When reading an instance within a slice and there's an\n        // indirect instance table, always read an indirect reference\n        // that points to an instance from the indirect instance table\n        // marshaled at the end of the Slice.\n        //\n        // Maintain a list of indirect references. Note that the\n        // indirect index starts at 1, so we decrement it by one to\n        // derive an index into the indirection table that we'll read\n        // at the end of the slice.\n        //\n        if (cb !== null) {\n          if (this._current.indirectPatchList === null)\n            // Lazy initialization\n            {\n              this._current.indirectPatchList = []; // IndirectPatchEntry[]\n            }\n          this._current.indirectPatchList.push(new IndirectPatchEntry(index - 1, cb));\n        }\n      } else {\n        this.readInstance(index, cb);\n      }\n    }\n  }, {\n    key: \"throwException\",\n    value: function throwException() {\n      Debug.assert(this._current === null);\n      this.push(SliceType.ExceptionSlice);\n\n      //\n      // Read the first slice header.\n      //\n      this.startSlice();\n      var mostDerivedId = this._current.typeId;\n      while (true) {\n        var userEx = this._stream.createUserException(this._current.typeId);\n\n        //\n        // We found the exception.\n        //\n        if (userEx !== null) {\n          userEx._read(this._stream);\n          throw userEx;\n\n          // Never reached.\n        }\n\n        //\n        // Slice off what we don't understand.\n        //\n        this.skipSlice();\n        if ((this._current.sliceFlags & Protocol.FLAG_IS_LAST_SLICE) !== 0) {\n          if (mostDerivedId.indexOf(\"::\") === 0) {\n            throw new Ice.UnknownUserException(mostDerivedId.substr(2));\n          }\n          throw new Ice.UnknownUserException(mostDerivedId);\n        }\n        this.startSlice();\n      }\n    }\n  }, {\n    key: \"startInstance\",\n    value: function startInstance(sliceType) {\n      Debug.assert(sliceType !== undefined);\n      Debug.assert(this._current.sliceType !== null && this._current.sliceType === sliceType);\n      this._current.skipFirstSlice = true;\n    }\n  }, {\n    key: \"endInstance\",\n    value: function endInstance(preserve) {\n      var slicedData = null;\n      if (preserve) {\n        slicedData = this.readSlicedData();\n      }\n      if (this._current.slices !== null) {\n        this._current.slices.length = 0; // Clear the array.\n        this._current.indirectionTables.length = 0; // Clear the array.\n      }\n      this._current = this._current.previous;\n      return slicedData;\n    }\n  }, {\n    key: \"startSlice\",\n    value: function startSlice() {\n      //\n      // If first slice, don't read the header, it was already read in\n      // readInstance or throwException to find the factory.\n      //\n      if (this._current.skipFirstSlice) {\n        this._current.skipFirstSlice = false;\n        return this._current.typeId;\n      }\n      this._current.sliceFlags = this._stream.readByte();\n\n      //\n      // Read the type ID, for instance slices the type ID is encoded as a\n      // string or as an index, for exceptions it's always encoded as a\n      // string.\n      //\n      if (this._current.sliceType === SliceType.ValueSlice) {\n        if ((this._current.sliceFlags & Protocol.FLAG_HAS_TYPE_ID_COMPACT) === Protocol.FLAG_HAS_TYPE_ID_COMPACT)\n          // Must be checked 1st!\n          {\n            this._current.typeId = \"\";\n            this._current.compactId = this._stream.readSize();\n          } else if ((this._current.sliceFlags & (Protocol.FLAG_HAS_TYPE_ID_INDEX | Protocol.FLAG_HAS_TYPE_ID_STRING)) !== 0) {\n          this._current.typeId = this.readTypeId((this._current.sliceFlags & Protocol.FLAG_HAS_TYPE_ID_INDEX) !== 0);\n          this._current.compactId = -1;\n        } else {\n          //\n          // Only the most derived slice encodes the type ID for the compact format.\n          //\n          this._current.typeId = \"\";\n          this._current.compactId = -1;\n        }\n      } else {\n        this._current.typeId = this._stream.readString();\n        this._current.compactId = -1;\n      }\n\n      //\n      // Read the slice size if necessary.\n      //\n      if ((this._current.sliceFlags & Protocol.FLAG_HAS_SLICE_SIZE) !== 0) {\n        this._current.sliceSize = this._stream.readInt();\n        if (this._current.sliceSize < 4) {\n          throw new Ice.UnmarshalOutOfBoundsException();\n        }\n      } else {\n        this._current.sliceSize = 0;\n      }\n      return this._current.typeId;\n    }\n  }, {\n    key: \"endSlice\",\n    value: function endSlice() {\n      var _this3 = this;\n      if ((this._current.sliceFlags & Protocol.FLAG_HAS_OPTIONAL_MEMBERS) !== 0) {\n        this._stream.skipOptionals();\n      }\n\n      //\n      // Read the indirection table if one is present and transform the\n      // indirect patch list into patch entries with direct references.\n      //\n      if ((this._current.sliceFlags & Protocol.FLAG_HAS_INDIRECTION_TABLE) !== 0) {\n        var indirectionTable = [];\n        //\n        // The table is written as a sequence<size> to conserve space.\n        //\n        var length = this._stream.readAndCheckSeqSize(1);\n        for (var i = 0; i < length; ++i) {\n          indirectionTable[i] = this.readInstance(this._stream.readSize(), null);\n        }\n\n        //\n        // Sanity checks. If there are optional members, it's possible\n        // that not all instance references were read if they are from\n        // unknown optional data members.\n        //\n        if (indirectionTable.length === 0) {\n          throw new Ice.MarshalException(\"empty indirection table\");\n        }\n        if ((this._current.indirectPatchList === null || this._current.indirectPatchList.length === 0) && (this._current.sliceFlags & Protocol.FLAG_HAS_OPTIONAL_MEMBERS) === 0) {\n          throw new Ice.MarshalException(\"no references to indirection table\");\n        }\n\n        //\n        // Convert indirect references into direct references.\n        //\n        if (this._current.indirectPatchList !== null) {\n          this._current.indirectPatchList.forEach(function (e) {\n            Debug.assert(e.index >= 0);\n            if (e.index >= indirectionTable.length) {\n              throw new Ice.MarshalException(\"indirection out of range\");\n            }\n            _this3.addPatchEntry(indirectionTable[e.index], e.cb);\n          });\n          this._current.indirectPatchList.length = 0;\n        }\n      }\n    }\n  }, {\n    key: \"skipSlice\",\n    value: function skipSlice() {\n      this._stream.traceSkipSlice(this._current.typeId, this._current.sliceType);\n      var start = this._stream.pos;\n      if ((this._current.sliceFlags & Protocol.FLAG_HAS_SLICE_SIZE) !== 0) {\n        Debug.assert(this._current.sliceSize >= 4);\n        this._stream.skip(this._current.sliceSize - 4);\n      } else if (this._current.sliceType === SliceType.ValueSlice) {\n        throw new Ice.NoValueFactoryException(\"no value factory found and compact format prevents slicing \" + \"(the sender should use the sliced format instead)\", this._current.typeId);\n      } else if (this._current.typeId.indexOf(\"::\") === 0) {\n        throw new Ice.UnknownUserException(this._current.typeId.substring(2));\n      } else {\n        throw new Ice.UnknownUserException(this._current.typeId);\n      }\n\n      //\n      // Preserve this slice.\n      //\n      var info = new Ice.SliceInfo();\n      info.typeId = this._current.typeId;\n      info.compactId = this._current.compactId;\n      info.hasOptionalMembers = (this._current.sliceFlags & Protocol.FLAG_HAS_OPTIONAL_MEMBERS) !== 0;\n      info.isLastSlice = (this._current.sliceFlags & Protocol.FLAG_IS_LAST_SLICE) !== 0;\n      var b = this._stream._buf;\n      var end = b.position;\n      var dataEnd = end;\n      if (info.hasOptionalMembers) {\n        //\n        // Don't include the optional member end marker. It will be re-written by\n        // endSlice when the sliced data is re-written.\n        //\n        --dataEnd;\n      }\n      b.position = start;\n      info.bytes = b.getArray(dataEnd - start);\n      b.position = end;\n      if (this._current.slices === null)\n        // Lazy initialization\n        {\n          this._current.slices = []; // Ice.SliceInfo[]\n          this._current.indirectionTables = []; // int[]\n        }\n\n      //\n      // Read the indirect instance table. We read the instances or their\n      // IDs if the instance is a reference to an already unmarshaled\n      // instance.\n      //\n\n      if ((this._current.sliceFlags & Protocol.FLAG_HAS_INDIRECTION_TABLE) !== 0) {\n        var length = this._stream.readAndCheckSeqSize(1);\n        var indirectionTable = [];\n        for (var i = 0; i < length; ++i) {\n          indirectionTable[i] = this.readInstance(this._stream.readSize(), null);\n        }\n        this._current.indirectionTables.push(indirectionTable);\n      } else {\n        this._current.indirectionTables.push(null);\n      }\n      this._current.slices.push(info);\n    }\n  }, {\n    key: \"readOptional\",\n    value: function readOptional(readTag, expectedFormat) {\n      if (this._current === null) {\n        return this._stream.readOptImpl(readTag, expectedFormat);\n      } else if ((this._current.sliceFlags & Protocol.FLAG_HAS_OPTIONAL_MEMBERS) !== 0) {\n        return this._stream.readOptImpl(readTag, expectedFormat);\n      }\n      return false;\n    }\n  }, {\n    key: \"readInstance\",\n    value: function readInstance(index, cb) {\n      Debug.assert(index > 0);\n      var v = null;\n      if (index > 1) {\n        if (cb !== null) {\n          this.addPatchEntry(index, cb);\n        }\n        return index;\n      }\n      this.push(SliceType.ValueSlice);\n\n      //\n      // Get the instance ID before we start reading slices. If some\n      // slices are skipped, the indirect instance table is still read and\n      // might read other instances.\n      //\n      index = ++this._valueIdIndex;\n\n      //\n      // Read the first slice header.\n      //\n      this.startSlice();\n      var mostDerivedId = this._current.typeId;\n      while (true) {\n        if (this._current.compactId >= 0) {\n          //\n          // Translate a compact (numeric) type ID into a string type ID.\n          //\n          this._current.typeId = \"\";\n          if (this._compactIdResolver !== null) {\n            try {\n              this._current.typeId = this._compactIdResolver.call(null, this._current.compactId);\n            } catch (ex) {\n              if (!(ex instanceof Ice.LocalException)) {\n                throw new Ice.MarshalException(\"exception in CompactIdResolver for ID \" + this._current.compactId, ex);\n              }\n              throw ex;\n            }\n          }\n          if (this._current.typeId.length === 0) {\n            this._current.typeId = this._stream.resolveCompactId(this._current.compactId);\n          }\n        }\n        if (this._current.typeId.length > 0) {\n          v = this.newInstance(this._current.typeId);\n        }\n        if (v !== null && v !== undefined) {\n          //\n          // We have an instance, we get out of this loop.\n          //\n          break;\n        }\n\n        //\n        // If slicing is disabled, stop unmarshaling.\n        //\n        if (!this._sliceValues) {\n          throw new Ice.NoValueFactoryException(\"no value factory found and slicing is disabled\", this._current.typeId);\n        }\n\n        //\n        // Slice off what we don't understand.\n        //\n        this.skipSlice();\n\n        //\n        // If this is the last slice, keep the instance as an opaque\n        // UnknownSlicedValue object.\n        //\n        if ((this._current.sliceFlags & Protocol.FLAG_IS_LAST_SLICE) !== 0) {\n          v = new Ice.UnknownSlicedValue(mostDerivedId);\n          break;\n        }\n        this.startSlice(); // Read next Slice header for next iteration.\n      }\n\n      //\n      // Unmarshal the instance.\n      //\n      this.unmarshal(index, v);\n      if (this._current === null && this._patchMap !== null && this._patchMap.size !== 0) {\n        //\n        // If any entries remain in the patch map, the sender has sent an index for an instance, but failed\n        // to supply the instance.\n        //\n        throw new Ice.MarshalException(\"index for class received, but no instance\");\n      }\n      if (cb !== null) {\n        cb(v);\n      }\n      return index;\n    }\n  }, {\n    key: \"readSlicedData\",\n    value: function readSlicedData() {\n      if (this._current.slices === null)\n        // No preserved slices.\n        {\n          return null;\n        }\n\n      //\n      // The _indirectionTables member holds the indirection table for each slice\n      // in _slices.\n      //\n      Debug.assert(this._current.slices.length === this._current.indirectionTables.length);\n      for (var i = 0; i < this._current.slices.length; ++i) {\n        //\n        // We use the \"instances\" list in SliceInfo to hold references\n        // to the target instances. Note that the instances might not have\n        // been read yet in the case of a circular reference to an\n        // enclosing instance.\n        //\n        var table = this._current.indirectionTables[i];\n        var info = this._current.slices[i];\n        info.instances = [];\n        if (table) {\n          for (var j = 0; j < table.length; ++j) {\n            this.addPatchEntry(table[j], sequencePatcher(info.instances, j, Ice.Value));\n          }\n        }\n      }\n      return new SlicedData(ArrayUtil.clone(this._current.slices));\n    }\n  }, {\n    key: \"push\",\n    value: function push(sliceType) {\n      if (this._current === null) {\n        this._current = new EncapsDecoder11.InstanceData(null);\n      } else {\n        this._current = !this._current.next ? new EncapsDecoder11.InstanceData(this._current) : this._current.next;\n      }\n      this._current.sliceType = sliceType;\n      this._current.skipFirstSlice = false;\n    }\n  }]);\n}(EncapsDecoder);\nEncapsDecoder11.InstanceData = /*#__PURE__*/_createClass(function _class(previous) {\n  \"use strict\";\n\n  _classCallCheck(this, _class);\n  if (previous !== null) {\n    previous.next = this;\n  }\n  this.previous = previous;\n  this.next = null;\n\n  // Instance attributes\n  this.sliceType = null;\n  this.skipFirstSlice = false;\n  this.slices = null; // Preserved slices. Ice.SliceInfo[]\n  this.indirectionTables = null; // int[][]\n\n  // Slice attributes\n  this.sliceFlags = 0;\n  this.sliceSize = 0;\n  this.typeId = null;\n  this.compactId = 0;\n  this.indirectPatchList = null; // Lazy initialized, IndirectPatchEntry[]\n});\nvar sequencePatcher = function sequencePatcher(seq, index, T) {\n  return function (v) {\n    if (v !== null && !(v instanceof T)) {\n      ExUtil.throwUOE(T.ice_staticId(), v);\n    }\n    seq[index] = v;\n  };\n};\nvar ReadEncaps = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function ReadEncaps() {\n    _classCallCheck(this, ReadEncaps);\n    this.start = 0;\n    this.sz = 0;\n    this.encoding = null;\n    this.encoding_1_0 = false;\n    this.decoder = null;\n    this.next = null;\n  }\n  return _createClass(ReadEncaps, [{\n    key: \"reset\",\n    value: function reset() {\n      this.decoder = null;\n    }\n  }, {\n    key: \"setEncoding\",\n    value: function setEncoding(encoding) {\n      this.encoding = encoding;\n      this.encoding_1_0 = encoding.equals(Ice.Encoding_1_0);\n    }\n  }]);\n}();\nvar InputStream = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function InputStream(arg1, arg2, arg3) {\n    _classCallCheck(this, InputStream);\n    var args = {\n      instance: null,\n      encoding: null,\n      bytes: null,\n      buffer: null\n    };\n    this._checkArgs([arg1, arg2, arg3], args);\n    this._initialize(args);\n  }\n  return _createClass(InputStream, [{\n    key: \"_checkArgs\",\n    value: function _checkArgs(arr, args) {\n      //\n      // The constructor can accept a variety of argument combinations:\n      //\n      // (<empty>)\n      // (communicator)\n      // (instance)\n      // (encoding)\n      // (array)\n      // (buffer)\n      // (communicator, encoding)\n      // (instance, encoding)\n      // (communicator, array)\n      // (instance, array)\n      // (communicator, buffer)\n      // (instance, buffer)\n      // (communicator, encoding, array)\n      // (instance, encoding, array)\n      // (communicator, encoding, buffer)\n      // (instance, encoding, buffer)\n      // (encoding, array)\n      // (encoding, array)\n      // (encoding, buffer)\n      // (encoding, buffer)\n      //\n      arr.forEach(function (arg) {\n        if (arg !== null && arg !== undefined) {\n          if (arg.constructor === Ice.Communicator) {\n            args.instance = arg.instance;\n          } else if (arg.constructor === Ice.Instance) {\n            args.instance = arg;\n          } else if (arg.constructor === Ice.EncodingVersion) {\n            args.encoding = arg;\n          } else if (arg.constructor === Ice.Buffer) {\n            args.buffer = arg;\n          } else if (arg.constructor === ArrayBuffer) {\n            args.bytes = arg;\n          } else if (arg.constructor === Uint8Array) {\n            args.bytes = arg.buffer;\n          } else {\n            throw new Ice.InitializationException(\"unknown argument to InputStream constructor\");\n          }\n        }\n      });\n      if (args.buffer !== null && args.bytes !== null) {\n        throw new Ice.InitializationException(\"invalid argument to InputStream constructor\");\n      }\n    }\n  }, {\n    key: \"_initialize\",\n    value: function _initialize(args) {\n      this._instance = args.instance;\n      this._encoding = args.encoding;\n      this._encapsStack = null;\n      this._encapsCache = null;\n      this._closure = null;\n      this._sliceValues = true;\n      this._startSeq = -1;\n      this._sizePos = -1;\n      this._compactIdResolver = null;\n      if (this._instance !== null) {\n        if (this._encoding === null) {\n          this._encoding = this._instance.defaultsAndOverrides().defaultEncoding;\n        }\n        this._traceSlicing = this._instance.traceLevels().slicing > 0;\n        this._valueFactoryManager = this._instance.initializationData().valueFactoryManager;\n        this._logger = this._instance.initializationData().logger;\n      } else {\n        if (this._encoding === null) {\n          this._encoding = Protocol.currentEncoding;\n        }\n        this._traceSlicing = false;\n        this._valueFactoryManager = null;\n        this._logger = null;\n      }\n      if (args.bytes !== null) {\n        this._buf = new Ice.Buffer(args.bytes);\n      } else if (args.buffer !== null) {\n        this._buf = args.buffer;\n      } else {\n        this._buf = new Ice.Buffer();\n      }\n    }\n\n    //\n    // This function allows this object to be reused, rather than reallocated.\n    //\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this._buf.reset();\n      this.clear();\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      if (this._encapsStack !== null) {\n        Debug.assert(this._encapsStack.next === null);\n        this._encapsStack.next = this._encapsCache;\n        this._encapsCache = this._encapsStack;\n        this._encapsCache.reset();\n        this._encapsStack = null;\n      }\n      this._startSeq = -1;\n      this._sliceValues = true;\n    }\n  }, {\n    key: \"swap\",\n    value: function swap(other) {\n      Debug.assert(this._instance === other._instance);\n      var _ref = [this._buf, other._buf];\n      other._buf = _ref[0];\n      this._buf = _ref[1];\n      var _ref2 = [this._encoding, other._encoding];\n      other._encoding = _ref2[0];\n      this._encoding = _ref2[1];\n      var _ref3 = [this._traceSlicing, other._traceSlicing];\n      other._traceSlicing = _ref3[0];\n      this._traceSlicing = _ref3[1];\n      var _ref4 = [this._closure, other.closure];\n      other._closure = _ref4[0];\n      this._closure = _ref4[1];\n      //\n      // Swap is never called for InputStreams that have encapsulations being read/write. However,\n      // encapsulations might still be set in case marshaling or unmarshaling failed. We just\n      // reset the encapsulations if there are still some set.\n      //\n      var _ref5 = [this._sliceValues, other._sliceValues];\n      other._sliceValues = _ref5[0];\n      this._sliceValues = _ref5[1];\n      this.resetEncapsulation();\n      other.resetEncapsulation();\n      var _ref6 = [this._startSeq, other._startSeq];\n      other._startSeq = _ref6[0];\n      this._startSeq = _ref6[1];\n      var _ref7 = [this._minSeqSize, other._minSeqSize];\n      other._minSeqSize = _ref7[0];\n      this._minSeqSize = _ref7[1];\n      var _ref8 = [this._sizePos, other._sizePos];\n      other._sizePos = _ref8[0];\n      this._sizePos = _ref8[1];\n      var _ref9 = [this._valueFactoryManager, other._valueFactoryManager];\n      other._valueFactoryManager = _ref9[0];\n      this._valueFactoryManager = _ref9[1];\n      var _ref0 = [this._logger, other._logger];\n      other._logger = _ref0[0];\n      this._logger = _ref0[1];\n      var _ref1 = [this._compactIdResolver, other._compactIdResolver];\n      other._compactIdResolver = _ref1[0];\n      this._compactIdResolver = _ref1[1];\n    }\n  }, {\n    key: \"resetEncapsulation\",\n    value: function resetEncapsulation() {\n      this._encapsStack = null;\n    }\n  }, {\n    key: \"resize\",\n    value: function resize(sz) {\n      this._buf.resize(sz);\n      this._buf.position = sz;\n    }\n  }, {\n    key: \"startValue\",\n    value: function startValue() {\n      Debug.assert(this._encapsStack !== null && this._encapsStack.decoder !== null);\n      this._encapsStack.decoder.startInstance(SliceType.ValueSlice);\n    }\n  }, {\n    key: \"endValue\",\n    value: function endValue(preserve) {\n      Debug.assert(this._encapsStack !== null && this._encapsStack.decoder !== null);\n      return this._encapsStack.decoder.endInstance(preserve);\n    }\n  }, {\n    key: \"startException\",\n    value: function startException() {\n      Debug.assert(this._encapsStack !== null && this._encapsStack.decoder !== null);\n      this._encapsStack.decoder.startInstance(SliceType.ExceptionSlice);\n    }\n  }, {\n    key: \"endException\",\n    value: function endException(preserve) {\n      Debug.assert(this._encapsStack !== null && this._encapsStack.decoder !== null);\n      return this._encapsStack.decoder.endInstance(preserve);\n    }\n  }, {\n    key: \"startEncapsulation\",\n    value: function startEncapsulation() {\n      var curr = this._encapsCache;\n      if (curr !== null) {\n        curr.reset();\n        this._encapsCache = this._encapsCache.next;\n      } else {\n        curr = new ReadEncaps();\n      }\n      curr.next = this._encapsStack;\n      this._encapsStack = curr;\n      this._encapsStack.start = this._buf.position;\n\n      //\n      // I don't use readSize() for encapsulations, because when creating an encapsulation,\n      // I must know in advance how many bytes the size information will require in the data\n      // stream. If I use an Int, it is always 4 bytes. For readSize(), it could be 1 or 5 bytes.\n      //\n      var sz = this.readInt();\n      if (sz < 6) {\n        throw new Ice.UnmarshalOutOfBoundsException();\n      }\n      if (sz - 4 > this._buf.remaining) {\n        throw new Ice.UnmarshalOutOfBoundsException();\n      }\n      this._encapsStack.sz = sz;\n      var encoding = new Ice.EncodingVersion();\n      encoding._read(this);\n      Protocol.checkSupportedEncoding(encoding); // Make sure the encoding is supported.\n      this._encapsStack.setEncoding(encoding);\n      return encoding;\n    }\n  }, {\n    key: \"endEncapsulation\",\n    value: function endEncapsulation() {\n      Debug.assert(this._encapsStack !== null);\n      if (!this._encapsStack.encoding_1_0) {\n        this.skipOptionals();\n        if (this._buf.position !== this._encapsStack.start + this._encapsStack.sz) {\n          throw new Ice.EncapsulationException();\n        }\n      } else if (this._buf.position !== this._encapsStack.start + this._encapsStack.sz) {\n        if (this._buf.position + 1 !== this._encapsStack.start + this._encapsStack.sz) {\n          throw new Ice.EncapsulationException();\n        }\n\n        //\n        // Ice version < 3.3 had a bug where user exceptions with\n        // class members could be encoded with a trailing byte\n        // when dispatched with AMD. So we tolerate an extra byte\n        // in the encapsulation.\n        //\n\n        try {\n          this._buf.get();\n        } catch (ex) {\n          throw new Ice.UnmarshalOutOfBoundsException();\n        }\n      }\n      var curr = this._encapsStack;\n      this._encapsStack = curr.next;\n      curr.next = this._encapsCache;\n      this._encapsCache = curr;\n      this._encapsCache.reset();\n    }\n  }, {\n    key: \"skipEmptyEncapsulation\",\n    value: function skipEmptyEncapsulation() {\n      var sz = this.readInt();\n      if (sz < 6) {\n        throw new Ice.EncapsulationException();\n      }\n      if (sz - 4 > this._buf.remaining) {\n        throw new Ice.UnmarshalOutOfBoundsException();\n      }\n      var encoding = new Ice.EncodingVersion();\n      encoding._read(this);\n      Protocol.checkSupportedEncoding(encoding); // Make sure the encoding is supported.\n\n      if (encoding.equals(Ice.Encoding_1_0)) {\n        if (sz != 6) {\n          throw new Ice.EncapsulationException();\n        }\n      } else {\n        // Skip the optional content of the encapsulation if we are expecting an\n        // empty encapsulation.\n        this._buf.position = this._buf.position + sz - 6;\n      }\n      return encoding;\n    }\n  }, {\n    key: \"readEncapsulation\",\n    value: function readEncapsulation(encoding) {\n      Debug.assert(encoding !== undefined);\n      var sz = this.readInt();\n      if (sz < 6) {\n        throw new Ice.UnmarshalOutOfBoundsException();\n      }\n      if (sz - 4 > this._buf.remaining) {\n        throw new Ice.UnmarshalOutOfBoundsException();\n      }\n      if (encoding !== null) {\n        encoding._read(this);\n        this._buf.position = this._buf.position - 6;\n      } else {\n        this._buf.position = this._buf.position - 4;\n      }\n      try {\n        return this._buf.getArray(sz);\n      } catch (ex) {\n        throw new Ice.UnmarshalOutOfBoundsException();\n      }\n    }\n  }, {\n    key: \"getEncoding\",\n    value: function getEncoding() {\n      return this._encapsStack !== null ? this._encapsStack.encoding : this._encoding;\n    }\n  }, {\n    key: \"getEncapsulationSize\",\n    value: function getEncapsulationSize() {\n      Debug.assert(this._encapsStack !== null);\n      return this._encapsStack.sz - 6;\n    }\n  }, {\n    key: \"skipEncapsulation\",\n    value: function skipEncapsulation() {\n      var sz = this.readInt();\n      if (sz < 6) {\n        throw new Ice.UnmarshalOutOfBoundsException();\n      }\n      var encoding = new Ice.EncodingVersion();\n      encoding._read(this);\n      try {\n        this._buf.position = this._buf.position + sz - 6;\n      } catch (ex) {\n        throw new Ice.UnmarshalOutOfBoundsException();\n      }\n      return encoding;\n    }\n  }, {\n    key: \"startSlice\",\n    value: function startSlice()\n    // Returns type ID of next slice\n    {\n      Debug.assert(this._encapsStack !== null && this._encapsStack.decoder !== null);\n      return this._encapsStack.decoder.startSlice();\n    }\n  }, {\n    key: \"endSlice\",\n    value: function endSlice() {\n      Debug.assert(this._encapsStack !== null && this._encapsStack.decoder !== null);\n      this._encapsStack.decoder.endSlice();\n    }\n  }, {\n    key: \"skipSlice\",\n    value: function skipSlice() {\n      Debug.assert(this._encapsStack !== null && this._encapsStack.decoder !== null);\n      this._encapsStack.decoder.skipSlice();\n    }\n  }, {\n    key: \"readPendingValues\",\n    value: function readPendingValues() {\n      if (this._encapsStack !== null && this._encapsStack.decoder !== null) {\n        this._encapsStack.decoder.readPendingValues();\n      } else if (this._encapsStack !== null && this._encapsStack.encoding_1_0 || this._encapsStack === null && this._encoding.equals(Ice.Encoding_1_0)) {\n        //\n        // If using the 1.0 encoding and no instances were read, we\n        // still read an empty sequence of pending instances if\n        // requested (i.e.: if this is called).\n        //\n        // This is required by the 1.0 encoding, even if no instances\n        // are written we do marshal an empty sequence if marshaled\n        // data types use classes.\n        //\n        this.skipSize();\n      }\n    }\n  }, {\n    key: \"readSize\",\n    value: function readSize() {\n      try {\n        var b = this._buf.get();\n        if (b === 255) {\n          var v = this._buf.getInt();\n          if (v < 0) {\n            throw new Ice.UnmarshalOutOfBoundsException();\n          }\n          return v;\n        }\n        return b;\n      } catch (ex) {\n        throw new Ice.UnmarshalOutOfBoundsException();\n      }\n    }\n  }, {\n    key: \"readAndCheckSeqSize\",\n    value: function readAndCheckSeqSize(minSize) {\n      var sz = this.readSize();\n      if (sz === 0) {\n        return sz;\n      }\n\n      //\n      // The _startSeq variable points to the start of the sequence for which\n      // we expect to read at least _minSeqSize bytes from the stream.\n      //\n      // If not initialized or if we already read more data than _minSeqSize,\n      // we reset _startSeq and _minSeqSize for this sequence (possibly a\n      // top-level sequence or enclosed sequence it doesn't really matter).\n      //\n      // Otherwise, we are reading an enclosed sequence and we have to bump\n      // _minSeqSize by the minimum size that this sequence will  require on\n      // the stream.\n      //\n      // The goal of this check is to ensure that when we start unmarshaling\n      // a new sequence, we check the minimal size of this new sequence against\n      // the estimated remaining buffer size. This estimatation is based on\n      // the minimum size of the enclosing sequences, it's _minSeqSize.\n      //\n      if (this._startSeq === -1 || this._buf.position > this._startSeq + this._minSeqSize) {\n        this._startSeq = this._buf.position;\n        this._minSeqSize = sz * minSize;\n      } else {\n        this._minSeqSize += sz * minSize;\n      }\n\n      //\n      // If there isn't enough data to read on the stream for the sequence (and\n      // possibly enclosed sequences), something is wrong with the marshaled\n      // data: it's claiming having more data that what is possible to read.\n      //\n      if (this._startSeq + this._minSeqSize > this._buf.limit) {\n        throw new Ice.UnmarshalOutOfBoundsException();\n      }\n      return sz;\n    }\n  }, {\n    key: \"readBlob\",\n    value: function readBlob(sz) {\n      if (this._buf.remaining < sz) {\n        throw new Ice.UnmarshalOutOfBoundsException();\n      }\n      try {\n        return this._buf.getArray(sz);\n      } catch (ex) {\n        throw new Ice.UnmarshalOutOfBoundsException();\n      }\n    }\n  }, {\n    key: \"readOptional\",\n    value: function readOptional(tag, expectedFormat) {\n      Debug.assert(this._encapsStack !== null);\n      if (this._encapsStack.decoder !== null) {\n        return this._encapsStack.decoder.readOptional(tag, expectedFormat);\n      }\n      return this.readOptImpl(tag, expectedFormat);\n    }\n  }, {\n    key: \"readOptionalHelper\",\n    value: function readOptionalHelper(tag, format, read) {\n      if (this.readOptional(tag, format)) {\n        return read.call(this);\n      } else {\n        return undefined;\n      }\n    }\n  }, {\n    key: \"readByte\",\n    value: function readByte() {\n      try {\n        return this._buf.get();\n      } catch (ex) {\n        throw new Ice.UnmarshalOutOfBoundsException();\n      }\n    }\n  }, {\n    key: \"readByteSeq\",\n    value: function readByteSeq() {\n      return this._buf.getArray(this.readAndCheckSeqSize(1));\n    }\n  }, {\n    key: \"readBool\",\n    value: function readBool() {\n      try {\n        return this._buf.get() === 1;\n      } catch (ex) {\n        throw new Ice.UnmarshalOutOfBoundsException();\n      }\n    }\n  }, {\n    key: \"readShort\",\n    value: function readShort() {\n      try {\n        return this._buf.getShort();\n      } catch (ex) {\n        throw new Ice.UnmarshalOutOfBoundsException();\n      }\n    }\n  }, {\n    key: \"readInt\",\n    value: function readInt() {\n      try {\n        return this._buf.getInt();\n      } catch (ex) {\n        throw new Ice.UnmarshalOutOfBoundsException();\n      }\n    }\n  }, {\n    key: \"readLong\",\n    value: function readLong() {\n      try {\n        return this._buf.getLong();\n      } catch (ex) {\n        throw new Ice.UnmarshalOutOfBoundsException();\n      }\n    }\n  }, {\n    key: \"readFloat\",\n    value: function readFloat() {\n      try {\n        return this._buf.getFloat();\n      } catch (ex) {\n        throw new Ice.UnmarshalOutOfBoundsException();\n      }\n    }\n  }, {\n    key: \"readDouble\",\n    value: function readDouble() {\n      try {\n        return this._buf.getDouble();\n      } catch (ex) {\n        throw new Ice.UnmarshalOutOfBoundsException();\n      }\n    }\n  }, {\n    key: \"readString\",\n    value: function readString() {\n      var len = this.readSize();\n      if (len === 0) {\n        return \"\";\n      }\n      //\n      // Check the buffer has enough bytes to read.\n      //\n      if (this._buf.remaining < len) {\n        throw new Ice.UnmarshalOutOfBoundsException();\n      }\n      try {\n        return this._buf.getString(len);\n      } catch (ex) {\n        throw new Ice.UnmarshalOutOfBoundsException();\n      }\n    }\n  }, {\n    key: \"readProxy\",\n    value: function readProxy(type) {\n      return this._instance.proxyFactory().streamToProxy(this, type);\n    }\n  }, {\n    key: \"readOptionalProxy\",\n    value: function readOptionalProxy(tag, type) {\n      if (this.readOptional(tag, OptionalFormat.FSize)) {\n        this.skip(4);\n        return this.readProxy(type);\n      } else {\n        return undefined;\n      }\n    }\n  }, {\n    key: \"readEnum\",\n    value: function readEnum(T) {\n      var v;\n      if (this.getEncoding().equals(Ice.Encoding_1_0)) {\n        if (T.maxValue < 127) {\n          v = this.readByte();\n        } else if (T.maxValue < 32767) {\n          v = this.readShort();\n        } else {\n          v = this.readInt();\n        }\n      } else {\n        v = this.readSize();\n      }\n      var e = T.valueOf(v);\n      if (e === undefined) {\n        throw new Ice.MarshalException(\"enumerator value \" + v + \" is out of range\");\n      }\n      return e;\n    }\n  }, {\n    key: \"readOptionalEnum\",\n    value: function readOptionalEnum(tag, T) {\n      if (this.readOptional(tag, OptionalFormat.Size)) {\n        return this.readEnum(T);\n      } else {\n        return undefined;\n      }\n    }\n  }, {\n    key: \"readValue\",\n    value: function readValue(cb, T) {\n      this.initEncaps();\n      this._encapsStack.decoder.readValue(cb === null ? null : function (obj) {\n        if (obj !== null && !(obj instanceof T)) {\n          ExUtil.throwUOE(T.ice_staticId(), obj);\n        }\n        cb(obj);\n      });\n    }\n  }, {\n    key: \"readOptionalValue\",\n    value: function readOptionalValue(tag, cb, T) {\n      if (this.readOptional(tag, OptionalFormat.Class)) {\n        this.readValue(cb, T);\n      } else {\n        cb(undefined);\n      }\n    }\n  }, {\n    key: \"throwException\",\n    value: function throwException() {\n      this.initEncaps();\n      this._encapsStack.decoder.throwException();\n    }\n  }, {\n    key: \"readOptImpl\",\n    value: function readOptImpl(readTag, expectedFormat) {\n      if (this.isEncoding_1_0()) {\n        return false; // Optional members aren't supported with the 1.0 encoding.\n      }\n      while (true) {\n        if (this._buf.position >= this._encapsStack.start + this._encapsStack.sz) {\n          return false; // End of encapsulation also indicates end of optionals.\n        }\n        var v = this.readByte();\n        if (v === Protocol.OPTIONAL_END_MARKER) {\n          this._buf.position -= 1; // Rewind.\n          return false;\n        }\n        var format = OptionalFormat.valueOf(v & 0x07); // First 3 bits.\n        var tag = v >> 3;\n        if (tag === 30) {\n          tag = this.readSize();\n        }\n        if (tag > readTag) {\n          var offset = tag < 30 ? 1 : tag < 255 ? 2 : 6; // Rewind\n          this._buf.position -= offset;\n          return false; // No optional data members with the requested tag.\n        } else if (tag < readTag) {\n          this.skipOptional(format); // Skip optional data members\n        } else {\n          if (format !== expectedFormat) {\n            throw new Ice.MarshalException(\"invalid optional data member `\" + tag + \"': unexpected format\");\n          }\n          return true;\n        }\n      }\n    }\n  }, {\n    key: \"skipOptional\",\n    value: function skipOptional(format) {\n      switch (format) {\n        case OptionalFormat.F1:\n          {\n            this.skip(1);\n            break;\n          }\n        case OptionalFormat.F2:\n          {\n            this.skip(2);\n            break;\n          }\n        case OptionalFormat.F4:\n          {\n            this.skip(4);\n            break;\n          }\n        case OptionalFormat.F8:\n          {\n            this.skip(8);\n            break;\n          }\n        case OptionalFormat.Size:\n          {\n            this.skipSize();\n            break;\n          }\n        case OptionalFormat.VSize:\n          {\n            this.skip(this.readSize());\n            break;\n          }\n        case OptionalFormat.FSize:\n          {\n            this.skip(this.readInt());\n            break;\n          }\n        case OptionalFormat.Class:\n          {\n            this.readValue(null, Ice.Value);\n            break;\n          }\n        default:\n          {\n            Debug.assert(false);\n            break;\n          }\n      }\n    }\n  }, {\n    key: \"skipOptionals\",\n    value: function skipOptionals() {\n      //\n      // Skip remaining un-read optional members.\n      //\n      while (true) {\n        if (this._buf.position >= this._encapsStack.start + this._encapsStack.sz) {\n          return; // End of encapsulation also indicates end of optionals.\n        }\n        var b = this.readByte();\n        var v = b < 0 ? b + 256 : b;\n        if (v === Protocol.OPTIONAL_END_MARKER) {\n          return;\n        }\n        var format = OptionalFormat.valueOf(v & 0x07); // Read first 3 bits.\n        if (v >> 3 === 30) {\n          this.skipSize();\n        }\n        this.skipOptional(format);\n      }\n    }\n  }, {\n    key: \"skip\",\n    value: function skip(size) {\n      if (size > this._buf.remaining) {\n        throw new Ice.UnmarshalOutOfBoundsException();\n      }\n      this._buf.position += size;\n    }\n  }, {\n    key: \"skipSize\",\n    value: function skipSize() {\n      var b = this.readByte();\n      if (b === 255) {\n        this.skip(4);\n      }\n    }\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return this._buf.empty();\n    }\n  }, {\n    key: \"expand\",\n    value: function expand(n) {\n      this._buf.expand(n);\n    }\n  }, {\n    key: \"createInstance\",\n    value: function createInstance(id) {\n      var obj = null;\n      try {\n        var typeId = id.length > 2 ? id.substr(2).replace(/::/g, \".\") : \"\";\n        var Class = _ModuleRegistry.type(typeId);\n        if (Class !== undefined) {\n          obj = new Class();\n        }\n      } catch (ex) {\n        throw new Ice.NoValueFactoryException(\"no value factory\", id, ex);\n      }\n      return obj;\n    }\n  }, {\n    key: \"createUserException\",\n    value: function createUserException(id) {\n      var userEx = null;\n      try {\n        var typeId = id.length > 2 ? id.substr(2).replace(/::/g, \".\") : \"\";\n        var Class = _ModuleRegistry.type(typeId);\n        if (Class !== undefined) {\n          userEx = new Class();\n        }\n      } catch (ex) {\n        throw new Ice.MarshalException(ex);\n      }\n      return userEx;\n    }\n  }, {\n    key: \"resolveCompactId\",\n    value: function resolveCompactId(compactId) {\n      var typeId = Ice.CompactIdRegistry.get(compactId);\n      return typeId === undefined ? \"\" : typeId;\n    }\n  }, {\n    key: \"isEncoding_1_0\",\n    value: function isEncoding_1_0() {\n      return this._encapsStack !== null ? this._encapsStack.encoding_1_0 : this._encoding.equals(Ice.Encoding_1_0);\n    }\n  }, {\n    key: \"initEncaps\",\n    value: function initEncaps() {\n      if (this._encapsStack === null)\n        // Lazy initialization\n        {\n          this._encapsStack = this._encapsCache;\n          if (this._encapsStack !== null) {\n            this._encapsCache = this._encapsCache.next;\n          } else {\n            this._encapsStack = new ReadEncaps();\n          }\n          this._encapsStack.setEncoding(this._encoding);\n          this._encapsStack.sz = this._buf.limit;\n        }\n      if (this._encapsStack.decoder === null)\n        // Lazy initialization.\n        {\n          if (this._encapsStack.encoding_1_0) {\n            this._encapsStack.decoder = new EncapsDecoder10(this, this._encapsStack, this._sliceValues, this._valueFactoryManager);\n          } else {\n            this._encapsStack.decoder = new EncapsDecoder11(this, this._encapsStack, this._sliceValues, this._valueFactoryManager, this._compactIdResolver);\n          }\n        }\n    }\n  }, {\n    key: \"traceSkipSlice\",\n    value: function traceSkipSlice(typeId, sliceType) {\n      if (this._traceSlicing && this._logger !== null) {\n        TraceUtil.traceSlicing(sliceType === SliceType.ExceptionSlice ? \"exception\" : \"object\", typeId, \"Slicing\", this._logger);\n      }\n    }\n\n    //\n    // Sets the value factory manager to use when marshaling value instances. If the stream\n    // was initialized with a communicator, the communicator's value factory manager will\n    // be used by default.\n    //\n  }, {\n    key: \"valueFactoryManager\",\n    get: function get() {\n      return this._valueFactoryManager;\n    },\n    set: function set(value) {\n      this._valueFactoryManager = value !== undefined ? value : null;\n    }\n\n    //\n    // Sets the logger to use when logging trace messages. If the stream\n    // was initialized with a communicator, the communicator's logger will\n    // be used by default.\n    //\n  }, {\n    key: \"logger\",\n    get: function get() {\n      return this._logger;\n    },\n    set: function set(value) {\n      this._logger = value !== undefined ? value : null;\n    }\n\n    //\n    // Sets the compact ID resolver to use when unmarshaling value and exception\n    // instances. If the stream was initialized with a communicator, the communicator's\n    // resolver will be used by default.\n    //\n  }, {\n    key: \"compactIdResolver\",\n    get: function get() {\n      return this._compactIdResolver;\n    },\n    set: function set(value) {\n      this._compactIdResolver = value !== undefined ? value : null;\n    }\n\n    //\n    // Determines the behavior of the stream when extracting instances of Slice classes.\n    // A instance is \"sliced\" when a factory cannot be found for a Slice type ID.\n    // The stream's default behavior is to slice instances.\n    //\n    // If slicing is disabled and the stream encounters a Slice type ID\n    // during decoding for which no value factory is installed, it raises\n    // NoValueFactoryException.\n    //\n  }, {\n    key: \"sliceValues\",\n    get: function get() {\n      return this._sliceValues;\n    },\n    set: function set(value) {\n      this._sliceValues = value;\n    }\n\n    //\n    // Determines whether the stream logs messages about slicing instances of Slice values.\n    //\n  }, {\n    key: \"traceSlicing\",\n    get: function get() {\n      return this._traceSlicing;\n    },\n    set: function set(value) {\n      this._traceSlicing = value;\n    }\n  }, {\n    key: \"pos\",\n    get: function get() {\n      return this._buf.position;\n    },\n    set: function set(value) {\n      this._buf.position = value;\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      return this._buf.limit;\n    }\n  }, {\n    key: \"instance\",\n    get: function get() {\n      return this._instance;\n    }\n  }, {\n    key: \"closure\",\n    get: function get() {\n      return this._type;\n    },\n    set: function set(value) {\n      this._type = value;\n    }\n  }, {\n    key: \"buffer\",\n    get: function get() {\n      return this._buf;\n    }\n  }]);\n}(); //\n// OutputStream\n//\nvar EncapsEncoder = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function EncapsEncoder(stream, encaps) {\n    _classCallCheck(this, EncapsEncoder);\n    this._stream = stream;\n    this._encaps = encaps;\n    this._marshaledMap = new Map(); // Map<Ice.Value, int>;\n    this._typeIdMap = null; // Lazy initialized. Map<String, int>\n    this._typeIdIndex = 0;\n  }\n  return _createClass(EncapsEncoder, [{\n    key: \"writeOptional\",\n    value: function writeOptional() {\n      return false;\n    }\n  }, {\n    key: \"writePendingValues\",\n    value: function writePendingValues() {\n      return undefined;\n    }\n  }, {\n    key: \"registerTypeId\",\n    value: function registerTypeId(typeId) {\n      if (this._typeIdMap === null)\n        // Lazy initialization\n        {\n          this._typeIdMap = new Map(); // Map<String, int>\n        }\n      var p = this._typeIdMap.get(typeId);\n      if (p !== undefined) {\n        return p;\n      } else {\n        this._typeIdMap.set(typeId, ++this._typeIdIndex);\n        return -1;\n      }\n    }\n  }]);\n}();\nvar EncapsEncoder10 = /*#__PURE__*/function (_EncapsEncoder) {\n  \"use strict\";\n\n  function EncapsEncoder10(stream, encaps) {\n    var _this4;\n    _classCallCheck(this, EncapsEncoder10);\n    _this4 = _callSuper(this, EncapsEncoder10, [stream, encaps]);\n    _this4._sliceType = SliceType.NoSlice;\n    _this4._writeSlice = 0; // Position of the slice data members\n    _this4._valueIdIndex = 0;\n    _this4._toBeMarshaledMap = new Map(); // Map<Ice.Value, Integer>();\n    return _this4;\n  }\n  _inherits(EncapsEncoder10, _EncapsEncoder);\n  return _createClass(EncapsEncoder10, [{\n    key: \"writeValue\",\n    value: function writeValue(v) {\n      Debug.assert(v !== undefined);\n      //\n      // Object references are encoded as a negative integer in 1.0.\n      //\n      if (v !== null && v !== undefined) {\n        this._stream.writeInt(-this.registerValue(v));\n      } else {\n        this._stream.writeInt(0);\n      }\n    }\n  }, {\n    key: \"writeException\",\n    value: function writeException(v) {\n      Debug.assert(v !== null && v !== undefined);\n      //\n      // User exception with the 1.0 encoding start with a boolean\n      // flag that indicates whether or not the exception uses\n      // classes.\n      //\n      // This allows reading the pending instances even if some part of\n      // the exception was sliced.\n      //\n      var usesClasses = v._usesClasses();\n      this._stream.writeBool(usesClasses);\n      v._write(this._stream);\n      if (usesClasses) {\n        this.writePendingValues();\n      }\n    }\n  }, {\n    key: \"startInstance\",\n    value: function startInstance(sliceType) {\n      this._sliceType = sliceType;\n    }\n  }, {\n    key: \"endInstance\",\n    value: function endInstance() {\n      if (this._sliceType === SliceType.ValueSlice) {\n        //\n        // Write the Object slice.\n        //\n        this.startSlice(Ice.Value.ice_staticId(), -1, true);\n        this._stream.writeSize(0); // For compatibility with the old AFM.\n        this.endSlice();\n      }\n      this._sliceType = SliceType.NoSlice;\n    }\n  }, {\n    key: \"startSlice\",\n    value: function startSlice(typeId) {\n      //\n      // For instance slices, encode a boolean to indicate how the type ID\n      // is encoded and the type ID either as a string or index. For\n      // exception slices, always encode the type ID as a string.\n      //\n      if (this._sliceType === SliceType.ValueSlice) {\n        var index = this.registerTypeId(typeId);\n        if (index < 0) {\n          this._stream.writeBool(false);\n          this._stream.writeString(typeId);\n        } else {\n          this._stream.writeBool(true);\n          this._stream.writeSize(index);\n        }\n      } else {\n        this._stream.writeString(typeId);\n      }\n      this._stream.writeInt(0); // Placeholder for the slice length.\n\n      this._writeSlice = this._stream.pos;\n    }\n  }, {\n    key: \"endSlice\",\n    value: function endSlice() {\n      //\n      // Write the slice length.\n      //\n      var sz = this._stream.pos - this._writeSlice + 4;\n      this._stream.rewriteInt(sz, this._writeSlice - 4);\n    }\n  }, {\n    key: \"writePendingValues\",\n    value: function writePendingValues() {\n      var _this5 = this;\n      var writeCB = function writeCB(value, key) {\n        //\n        // Ask the instance to marshal itself. Any new class\n        // instances that are triggered by the classes marshaled\n        // are added to toBeMarshaledMap.\n        //\n        _this5._stream.writeInt(value);\n        try {\n          key.ice_preMarshal();\n        } catch (ex) {\n          _this5._stream.instance.initializationData().logger.warning(\"exception raised by ice_preMarshal:\\n\" + ex.toString());\n        }\n        key._iceWrite(_this5._stream);\n      };\n      while (this._toBeMarshaledMap.size > 0) {\n        //\n        // Consider the to be marshalled instances as marshalled now,\n        // this is necessary to avoid adding again the \"to be\n        // marshalled instances\" into _toBeMarshaledMap while writing\n        // instances.\n        //\n        this._toBeMarshaledMap.forEach(function (value, key) {\n          return _this5._marshaledMap.set(key, value);\n        });\n        var savedMap = this._toBeMarshaledMap;\n        this._toBeMarshaledMap = new Map(); // Map<Ice.Value, int>();\n        this._stream.writeSize(savedMap.size);\n        savedMap.forEach(writeCB);\n      }\n      this._stream.writeSize(0); // Zero marker indicates end of sequence of sequences of instances.\n    }\n  }, {\n    key: \"registerValue\",\n    value: function registerValue(v) {\n      Debug.assert(v !== null);\n\n      //\n      // Look for this instance in the to-be-marshaled map.\n      //\n      var p = this._toBeMarshaledMap.get(v);\n      if (p !== undefined) {\n        return p;\n      }\n\n      //\n      // Didn't find it, try the marshaled map next.\n      //\n      p = this._marshaledMap.get(v);\n      if (p !== undefined) {\n        return p;\n      }\n\n      //\n      // We haven't seen this instance previously, create a new\n      // index, and insert it into the to-be-marshaled map.\n      //\n      this._toBeMarshaledMap.set(v, ++this._valueIdIndex);\n      return this._valueIdIndex;\n    }\n  }]);\n}(EncapsEncoder);\nvar EncapsEncoder11 = /*#__PURE__*/function (_EncapsEncoder2) {\n  \"use strict\";\n\n  function EncapsEncoder11(stream, encaps) {\n    var _this6;\n    _classCallCheck(this, EncapsEncoder11);\n    _this6 = _callSuper(this, EncapsEncoder11, [stream, encaps]);\n    _this6._current = null;\n    _this6._valueIdIndex = 1;\n    return _this6;\n  }\n  _inherits(EncapsEncoder11, _EncapsEncoder2);\n  return _createClass(EncapsEncoder11, [{\n    key: \"writeValue\",\n    value: function writeValue(v) {\n      Debug.assert(v !== undefined);\n      if (v === null || v === undefined) {\n        this._stream.writeSize(0);\n      } else if (this._current !== null && this._encaps.format === FormatType.SlicedFormat) {\n        if (this._current.indirectionTable === null)\n          // Lazy initialization\n          {\n            this._current.indirectionTable = []; // Ice.Value[]\n            this._current.indirectionMap = new Map(); // Map<Ice.Value, int>\n          }\n\n        //\n        // If writing an instance within a slice and using the sliced\n        // format, write an index from the instance indirection\n        // table. The indirect instance table is encoded at the end of\n        // each slice and is always read (even if the Slice is\n        // unknown).\n        //\n        var index = this._current.indirectionMap.get(v);\n        if (index === undefined) {\n          this._current.indirectionTable.push(v);\n          var idx = this._current.indirectionTable.length; // Position + 1 (0 is reserved for nil)\n          this._current.indirectionMap.set(v, idx);\n          this._stream.writeSize(idx);\n        } else {\n          this._stream.writeSize(index);\n        }\n      } else {\n        this.writeInstance(v); // Write the instance or a reference if already marshaled.\n      }\n    }\n  }, {\n    key: \"writePendingValues\",\n    value: function writePendingValues() {\n      return undefined;\n    }\n  }, {\n    key: \"writeException\",\n    value: function writeException(v) {\n      Debug.assert(v !== null && v !== undefined);\n      v._write(this._stream);\n    }\n  }, {\n    key: \"startInstance\",\n    value: function startInstance(sliceType, data) {\n      if (this._current === null) {\n        this._current = new EncapsEncoder11.InstanceData(null);\n      } else {\n        this._current = this._current.next === null ? new EncapsEncoder11.InstanceData(this._current) : this._current.next;\n      }\n      this._current.sliceType = sliceType;\n      this._current.firstSlice = true;\n      if (data !== null && data !== undefined) {\n        this.writeSlicedData(data);\n      }\n    }\n  }, {\n    key: \"endInstance\",\n    value: function endInstance() {\n      this._current = this._current.previous;\n    }\n  }, {\n    key: \"startSlice\",\n    value: function startSlice(typeId, compactId, last) {\n      Debug.assert((this._current.indirectionTable === null || this._current.indirectionTable.length === 0) && (this._current.indirectionMap === null || this._current.indirectionMap.size === 0));\n      this._current.sliceFlagsPos = this._stream.pos;\n      this._current.sliceFlags = 0;\n      if (this._encaps.format === FormatType.SlicedFormat) {\n        // Encode the slice size if using the sliced format.\n        this._current.sliceFlags |= Protocol.FLAG_HAS_SLICE_SIZE;\n      }\n      if (last) {\n        this._current.sliceFlags |= Protocol.FLAG_IS_LAST_SLICE; // This is the last slice.\n      }\n      this._stream.writeByte(0); // Placeholder for the slice flags\n\n      //\n      // For instance slices, encode the flag and the type ID either as a\n      // string or index. For exception slices, always encode the type\n      // ID a string.\n      //\n      if (this._current.sliceType === SliceType.ValueSlice) {\n        //\n        // Encode the type ID (only in the first slice for the compact\n        // encoding).\n        //\n        if (this._encaps.format === FormatType.SlicedFormat || this._current.firstSlice) {\n          if (compactId >= 0) {\n            this._current.sliceFlags |= Protocol.FLAG_HAS_TYPE_ID_COMPACT;\n            this._stream.writeSize(compactId);\n          } else {\n            var index = this.registerTypeId(typeId);\n            if (index < 0) {\n              this._current.sliceFlags |= Protocol.FLAG_HAS_TYPE_ID_STRING;\n              this._stream.writeString(typeId);\n            } else {\n              this._current.sliceFlags |= Protocol.FLAG_HAS_TYPE_ID_INDEX;\n              this._stream.writeSize(index);\n            }\n          }\n        }\n      } else {\n        this._stream.writeString(typeId);\n      }\n      if ((this._current.sliceFlags & Protocol.FLAG_HAS_SLICE_SIZE) !== 0) {\n        this._stream.writeInt(0); // Placeholder for the slice length.\n      }\n      this._current.writeSlice = this._stream.pos;\n      this._current.firstSlice = false;\n    }\n  }, {\n    key: \"endSlice\",\n    value: function endSlice() {\n      var _this7 = this;\n      //\n      // Write the optional member end marker if some optional members\n      // were encoded. Note that the optional members are encoded before\n      // the indirection table and are included in the slice size.\n      //\n      if ((this._current.sliceFlags & Protocol.FLAG_HAS_OPTIONAL_MEMBERS) !== 0) {\n        this._stream.writeByte(Protocol.OPTIONAL_END_MARKER);\n      }\n\n      //\n      // Write the slice length if necessary.\n      //\n      if ((this._current.sliceFlags & Protocol.FLAG_HAS_SLICE_SIZE) !== 0) {\n        var sz = this._stream.pos - this._current.writeSlice + 4;\n        this._stream.rewriteInt(sz, this._current.writeSlice - 4);\n      }\n\n      //\n      // Only write the indirection table if it contains entries.\n      //\n      if (this._current.indirectionTable !== null && this._current.indirectionTable.length !== 0) {\n        Debug.assert(this._encaps.format === FormatType.SlicedFormat);\n        this._current.sliceFlags |= Protocol.FLAG_HAS_INDIRECTION_TABLE;\n\n        //\n        // Write the indirection instance table.\n        //\n        this._stream.writeSize(this._current.indirectionTable.length);\n        this._current.indirectionTable.forEach(function (o) {\n          return _this7.writeInstance(o);\n        });\n        this._current.indirectionTable.length = 0; // Faster way to clean array in JavaScript\n        this._current.indirectionMap.clear();\n      }\n\n      //\n      // Finally, update the slice flags.\n      //\n      this._stream.rewriteByte(this._current.sliceFlags, this._current.sliceFlagsPos);\n    }\n  }, {\n    key: \"writeOptional\",\n    value: function writeOptional(tag, format) {\n      if (this._current === null) {\n        return this._stream.writeOptImpl(tag, format);\n      }\n      if (this._stream.writeOptImpl(tag, format)) {\n        this._current.sliceFlags |= Protocol.FLAG_HAS_OPTIONAL_MEMBERS;\n        return true;\n      }\n      return false;\n    }\n  }, {\n    key: \"writeSlicedData\",\n    value: function writeSlicedData(slicedData) {\n      var _this8 = this;\n      Debug.assert(slicedData !== null && slicedData !== undefined);\n\n      //\n      // We only remarshal preserved slices if we are using the sliced\n      // format. Otherwise, we ignore the preserved slices, which\n      // essentially \"slices\" the instance into the most-derived type\n      // known by the sender.\n      //\n      if (this._encaps.format !== FormatType.SlicedFormat) {\n        return;\n      }\n      slicedData.slices.forEach(function (info) {\n        _this8.startSlice(info.typeId, info.compactId, info.isLastSlice);\n\n        //\n        // Write the bytes associated with this slice.\n        //\n        _this8._stream.writeBlob(info.bytes);\n        if (info.hasOptionalMembers) {\n          _this8._current.sliceFlags |= Protocol.FLAG_HAS_OPTIONAL_MEMBERS;\n        }\n\n        //\n        // Make sure to also re-write the instance indirection table.\n        //\n        if (info.instances !== null && info.instances.length > 0) {\n          if (_this8._current.indirectionTable === null)\n            // Lazy initialization\n            {\n              _this8._current.indirectionTable = []; // Ice.Value[]\n              _this8._current.indirectionMap = new Map(); // Map<Ice.Value, int>\n            }\n          info.instances.forEach(function (instance) {\n            return _this8._current.indirectionTable.push(instance);\n          });\n        }\n        _this8.endSlice();\n      });\n    }\n  }, {\n    key: \"writeInstance\",\n    value: function writeInstance(v) {\n      Debug.assert(v !== null && v !== undefined);\n\n      //\n      // If the instance was already marshaled, just write it's ID.\n      //\n      var p = this._marshaledMap.get(v);\n      if (p !== undefined) {\n        this._stream.writeSize(p);\n        return;\n      }\n\n      //\n      // We haven't seen this instance previously, create a new ID,\n      // insert it into the marshaled map, and write the instance.\n      //\n      this._marshaledMap.set(v, ++this._valueIdIndex);\n      try {\n        v.ice_preMarshal();\n      } catch (ex) {\n        this._stream.instance.initializationData().logger.warning(\"exception raised by ice_preMarshal:\\n\" + ex.toString());\n      }\n      this._stream.writeSize(1); // Object instance marker.\n      v._iceWrite(this._stream);\n    }\n  }]);\n}(EncapsEncoder);\nEncapsEncoder11.InstanceData = /*#__PURE__*/_createClass(function _class2(previous) {\n  \"use strict\";\n\n  _classCallCheck(this, _class2);\n  Debug.assert(previous !== undefined);\n  if (previous !== null) {\n    previous.next = this;\n  }\n  this.previous = previous;\n  this.next = null;\n\n  // Instance attributes\n  this.sliceType = null;\n  this.firstSlice = false;\n\n  // Slice attributes\n  this.sliceFlags = 0;\n  this.writeSlice = 0; // Position of the slice data members\n  this.sliceFlagsPos = 0; // Position of the slice flags\n  this.indirectionTable = null; // Ice.Value[]\n  this.indirectionMap = null; // Map<Ice.Value, int>\n});\nvar WriteEncaps = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function WriteEncaps() {\n    _classCallCheck(this, WriteEncaps);\n    this.start = 0;\n    this.format = FormatType.DefaultFormat;\n    this.encoding = null;\n    this.encoding_1_0 = false;\n    this.encoder = null;\n    this.next = null;\n  }\n  return _createClass(WriteEncaps, [{\n    key: \"reset\",\n    value: function reset() {\n      this.encoder = null;\n    }\n  }, {\n    key: \"setEncoding\",\n    value: function setEncoding(encoding) {\n      this.encoding = encoding;\n      this.encoding_1_0 = encoding.equals(Ice.Encoding_1_0);\n    }\n  }]);\n}();\nvar OutputStream = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function OutputStream(arg1, arg2) {\n    _classCallCheck(this, OutputStream);\n    this._instance = null;\n    this._encoding = null;\n    if (arg1 !== undefined && arg1 !== null) {\n      if (arg1.constructor == Ice.Communicator) {\n        this._instance = arg1.instance;\n      } else if (arg1.constructor == Ice.Instance) {\n        this._instance = arg1;\n      } else if (arg1.constructor == Ice.EncodingVersion) {\n        this._encoding = arg1;\n      } else {\n        throw new Ice.InitializationException(\"unknown argument to OutputStream constructor\");\n      }\n    }\n    if (arg2 !== undefined && arg2 !== null) {\n      if (arg2.constructor == Ice.EncodingVersion) {\n        this._encoding = arg2;\n      } else {\n        throw new Ice.InitializationException(\"unknown argument to OutputStream constructor\");\n      }\n    }\n    this._buf = new Ice.Buffer();\n    this._closure = null;\n    this._encapsStack = null;\n    this._encapsCache = null;\n    if (this._instance !== null) {\n      if (this._encoding === null) {\n        this._encoding = this._instance.defaultsAndOverrides().defaultEncoding;\n      }\n      this._format = this._instance.defaultsAndOverrides().defaultFormat;\n    } else {\n      if (this._encoding === null) {\n        this._encoding = Protocol.currentEncoding;\n      }\n      this._format = FormatType.CompactFormat;\n    }\n  }\n\n  //\n  // This function allows this object to be reused, rather than reallocated.\n  //\n  return _createClass(OutputStream, [{\n    key: \"reset\",\n    value: function reset() {\n      this._buf.reset();\n      this.clear();\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      if (this._encapsStack !== null) {\n        Debug.assert(this._encapsStack.next);\n        this._encapsStack.next = this._encapsCache;\n        this._encapsCache = this._encapsStack;\n        this._encapsCache.reset();\n        this._encapsStack = null;\n      }\n    }\n  }, {\n    key: \"finished\",\n    value: function finished() {\n      return this.prepareWrite().getArray(this.size);\n    }\n  }, {\n    key: \"swap\",\n    value: function swap(other) {\n      Debug.assert(this._instance === other._instance);\n      var _ref10 = [this._buf, other._buf];\n      other._buf = _ref10[0];\n      this._buf = _ref10[1];\n      var _ref11 = [this._encoding, other._encoding];\n      other._encoding = _ref11[0];\n      this._encoding = _ref11[1];\n      //\n      // Swap is never called for streams that have encapsulations being written. However,\n      // encapsulations might still be set in case marshaling failed. We just\n      // reset the encapsulations if there are still some set.\n      //\n      var _ref12 = [this._closure, other._closure];\n      other._closure = _ref12[0];\n      this._closure = _ref12[1];\n      this.resetEncapsulation();\n      other.resetEncapsulation();\n    }\n  }, {\n    key: \"resetEncapsulation\",\n    value: function resetEncapsulation() {\n      this._encapsStack = null;\n    }\n  }, {\n    key: \"resize\",\n    value: function resize(sz) {\n      this._buf.resize(sz);\n      this._buf.position = sz;\n    }\n  }, {\n    key: \"prepareWrite\",\n    value: function prepareWrite() {\n      this._buf.position = 0;\n      return this._buf;\n    }\n  }, {\n    key: \"startValue\",\n    value: function startValue(data) {\n      Debug.assert(this._encapsStack !== null && this._encapsStack.encoder !== null);\n      this._encapsStack.encoder.startInstance(SliceType.ValueSlice, data);\n    }\n  }, {\n    key: \"endValue\",\n    value: function endValue() {\n      Debug.assert(this._encapsStack !== null && this._encapsStack.encoder !== null);\n      this._encapsStack.encoder.endInstance();\n    }\n  }, {\n    key: \"startException\",\n    value: function startException(data) {\n      Debug.assert(this._encapsStack !== null && this._encapsStack.encoder !== null);\n      this._encapsStack.encoder.startInstance(SliceType.ExceptionSlice, data);\n    }\n  }, {\n    key: \"endException\",\n    value: function endException() {\n      Debug.assert(this._encapsStack !== null && this._encapsStack.encoder !== null);\n      this._encapsStack.encoder.endInstance();\n    }\n  }, {\n    key: \"startEncapsulation\",\n    value: function startEncapsulation(encoding, format) {\n      //\n      // If no encoding version is specified, use the current write\n      // encapsulation encoding version if there's a current write\n      // encapsulation, otherwise, use the stream encoding version.\n      //\n\n      if (encoding === undefined) {\n        if (this._encapsStack !== null) {\n          encoding = this._encapsStack.encoding;\n          format = this._encapsStack.format;\n        } else {\n          encoding = this._encoding;\n          format = FormatType.DefaultFormat;\n        }\n      }\n      Protocol.checkSupportedEncoding(encoding);\n      var curr = this._encapsCache;\n      if (curr !== null) {\n        curr.reset();\n        this._encapsCache = this._encapsCache.next;\n      } else {\n        curr = new WriteEncaps();\n      }\n      curr.next = this._encapsStack;\n      this._encapsStack = curr;\n      this._encapsStack.format = format;\n      this._encapsStack.setEncoding(encoding);\n      this._encapsStack.start = this._buf.limit;\n      this.writeInt(0); // Placeholder for the encapsulation length.\n      this._encapsStack.encoding._write(this);\n    }\n  }, {\n    key: \"endEncapsulation\",\n    value: function endEncapsulation() {\n      Debug.assert(this._encapsStack);\n\n      // Size includes size and version.\n      var start = this._encapsStack.start;\n      var sz = this._buf.limit - start;\n      this._buf.putIntAt(start, sz);\n      var curr = this._encapsStack;\n      this._encapsStack = curr.next;\n      curr.next = this._encapsCache;\n      this._encapsCache = curr;\n      this._encapsCache.reset();\n    }\n  }, {\n    key: \"writeEmptyEncapsulation\",\n    value: function writeEmptyEncapsulation(encoding) {\n      Protocol.checkSupportedEncoding(encoding);\n      this.writeInt(6); // Size\n      encoding._write(this);\n    }\n  }, {\n    key: \"writeEncapsulation\",\n    value: function writeEncapsulation(v) {\n      if (v.length < 6) {\n        throw new Ice.EncapsulationException();\n      }\n      this.expand(v.length);\n      this._buf.putArray(v);\n    }\n  }, {\n    key: \"getEncoding\",\n    value: function getEncoding() {\n      return this._encapsStack !== null ? this._encapsStack.encoding : this._encoding;\n    }\n  }, {\n    key: \"startSlice\",\n    value: function startSlice(typeId, compactId, last) {\n      Debug.assert(this._encapsStack !== null && this._encapsStack.encoder !== null);\n      this._encapsStack.encoder.startSlice(typeId, compactId, last);\n    }\n  }, {\n    key: \"endSlice\",\n    value: function endSlice() {\n      Debug.assert(this._encapsStack !== null && this._encapsStack.encoder !== null);\n      this._encapsStack.encoder.endSlice();\n    }\n  }, {\n    key: \"writePendingValues\",\n    value: function writePendingValues() {\n      if (this._encapsStack !== null && this._encapsStack.encoder !== null) {\n        this._encapsStack.encoder.writePendingValues();\n      } else if (this._encapsStack !== null && this._encapsStack.encoding_1_0 || this._encapsStack === null && this._encoding.equals(Ice.Encoding_1_0)) {\n        //\n        // If using the 1.0 encoding and no instances were written, we\n        // still write an empty sequence for pending instances if\n        // requested (i.e.: if this is called).\n        //\n        // This is required by the 1.0 encoding, even if no instances\n        // are written we do marshal an empty sequence if marshaled\n        // data types use classes.\n        //\n        this.writeSize(0);\n      }\n    }\n  }, {\n    key: \"writeSize\",\n    value: function writeSize(v) {\n      if (v > 254) {\n        this.expand(5);\n        this._buf.put(255);\n        this._buf.putInt(v);\n      } else {\n        this.expand(1);\n        this._buf.put(v);\n      }\n    }\n  }, {\n    key: \"startSize\",\n    value: function startSize() {\n      var pos = this._buf.position;\n      this.writeInt(0); // Placeholder for 32-bit size\n      return pos;\n    }\n  }, {\n    key: \"endSize\",\n    value: function endSize(pos) {\n      Debug.assert(pos >= 0);\n      this.rewriteInt(this._buf.position - pos - 4, pos);\n    }\n  }, {\n    key: \"writeBlob\",\n    value: function writeBlob(v) {\n      if (v === null || v === undefined) {\n        return;\n      }\n      this.expand(v.length);\n      this._buf.putArray(v);\n    }\n\n    // Read/write format and tag for optionals\n  }, {\n    key: \"writeOptional\",\n    value: function writeOptional(tag, format) {\n      Debug.assert(this._encapsStack !== null);\n      if (this._encapsStack.encoder !== null) {\n        return this._encapsStack.encoder.writeOptional(tag, format);\n      }\n      return this.writeOptImpl(tag, format);\n    }\n  }, {\n    key: \"writeOptionalHelper\",\n    value: function writeOptionalHelper(tag, format, write, v) {\n      if (v !== undefined) {\n        if (this.writeOptional(tag, format)) {\n          write.call(this, v);\n        }\n      }\n    }\n  }, {\n    key: \"writeByte\",\n    value: function writeByte(v) {\n      this.expand(1);\n      this._buf.put(v);\n    }\n  }, {\n    key: \"rewriteByte\",\n    value: function rewriteByte(v, dest) {\n      this._buf.putAt(dest, v);\n    }\n  }, {\n    key: \"writeByteSeq\",\n    value: function writeByteSeq(v) {\n      if (v === null || v === undefined || v.length === 0) {\n        this.writeSize(0);\n      } else {\n        this.writeSize(v.length);\n        this.expand(v.length);\n        this._buf.putArray(v);\n      }\n    }\n  }, {\n    key: \"writeBool\",\n    value: function writeBool(v) {\n      this.expand(1);\n      this._buf.put(v ? 1 : 0);\n    }\n  }, {\n    key: \"rewriteBool\",\n    value: function rewriteBool(v, dest) {\n      this._buf.putAt(dest, v ? 1 : 0);\n    }\n  }, {\n    key: \"writeShort\",\n    value: function writeShort(v) {\n      this.expand(2);\n      this._buf.putShort(v);\n    }\n  }, {\n    key: \"writeInt\",\n    value: function writeInt(v) {\n      this.expand(4);\n      this._buf.putInt(v);\n    }\n  }, {\n    key: \"rewriteInt\",\n    value: function rewriteInt(v, dest) {\n      this._buf.putIntAt(dest, v);\n    }\n  }, {\n    key: \"writeLong\",\n    value: function writeLong(v) {\n      this.expand(8);\n      this._buf.putLong(v);\n    }\n  }, {\n    key: \"writeFloat\",\n    value: function writeFloat(v) {\n      this.expand(4);\n      this._buf.putFloat(v);\n    }\n  }, {\n    key: \"writeDouble\",\n    value: function writeDouble(v) {\n      this.expand(8);\n      this._buf.putDouble(v);\n    }\n  }, {\n    key: \"writeString\",\n    value: function writeString(v) {\n      if (v === null || v === undefined || v.length === 0) {\n        this.writeSize(0);\n      } else {\n        this._buf.writeString(this, v);\n      }\n    }\n  }, {\n    key: \"writeProxy\",\n    value: function writeProxy(v) {\n      if (v === null || v === undefined) {\n        var ident = new Ice.Identity();\n        ident._write(this);\n      } else {\n        v._write(this);\n      }\n    }\n  }, {\n    key: \"writeOptionalProxy\",\n    value: function writeOptionalProxy(tag, v) {\n      if (v !== undefined) {\n        if (this.writeOptional(tag, OptionalFormat.FSize)) {\n          var pos = this.startSize();\n          this.writeProxy(v);\n          this.endSize(pos);\n        }\n      }\n    }\n  }, {\n    key: \"writeEnum\",\n    value: function writeEnum(v) {\n      if (this.isEncoding_1_0()) {\n        if (v.maxValue < 127) {\n          this.writeByte(v.value);\n        } else if (v.maxValue < 32767) {\n          this.writeShort(v.value);\n        } else {\n          this.writeInt(v.value);\n        }\n      } else {\n        this.writeSize(v.value);\n      }\n    }\n  }, {\n    key: \"writeValue\",\n    value: function writeValue(v) {\n      this.initEncaps();\n      this._encapsStack.encoder.writeValue(v);\n    }\n  }, {\n    key: \"writeOptionalValue\",\n    value: function writeOptionalValue(tag, v) {\n      if (v !== undefined) {\n        if (this.writeOptional(tag, OptionalFormat.Class)) {\n          this.writeValue(v);\n        }\n      }\n    }\n  }, {\n    key: \"writeException\",\n    value: function writeException(e) {\n      this.initEncaps();\n      this._encapsStack.encoder.writeException(e);\n    }\n\n    //\n    // Keep for compatibility with 3.7.0 remove with next major version\n    //\n  }, {\n    key: \"writeUserException\",\n    value: function writeUserException(e) {\n      this.WriteException(e);\n    }\n  }, {\n    key: \"writeOptImpl\",\n    value: function writeOptImpl(tag, format) {\n      if (this.isEncoding_1_0()) {\n        return false; // Optional members aren't supported with the 1.0 encoding.\n      }\n      var v = format.value;\n      if (tag < 30) {\n        v |= tag << 3;\n        this.writeByte(v);\n      } else {\n        v |= 0x0F0; // tag = 30\n        this.writeByte(v);\n        this.writeSize(tag);\n      }\n      return true;\n    }\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return this._buf.empty();\n    }\n  }, {\n    key: \"expand\",\n    value: function expand(n) {\n      this._buf.expand(n);\n    }\n  }, {\n    key: \"isEncoding_1_0\",\n    value: function isEncoding_1_0() {\n      return this._encapsStack ? this._encapsStack.encoding_1_0 : this._encoding.equals(Ice.Encoding_1_0);\n    }\n  }, {\n    key: \"initEncaps\",\n    value: function initEncaps() {\n      if (!this._encapsStack)\n        // Lazy initialization\n        {\n          this._encapsStack = this._encapsCache;\n          if (this._encapsStack) {\n            this._encapsCache = this._encapsCache.next;\n          } else {\n            this._encapsStack = new WriteEncaps();\n          }\n          this._encapsStack.setEncoding(this._encoding);\n        }\n      if (this._encapsStack.format === FormatType.DefaultFormat) {\n        this._encapsStack.format = this._instance.defaultsAndOverrides().defaultFormat;\n      }\n      if (!this._encapsStack.encoder)\n        // Lazy initialization.\n        {\n          if (this._encapsStack.encoding_1_0) {\n            this._encapsStack.encoder = new EncapsEncoder10(this, this._encapsStack);\n          } else {\n            this._encapsStack.encoder = new EncapsEncoder11(this, this._encapsStack);\n          }\n        }\n    }\n\n    //\n    // Sets the encoding format for class and exception instances.\n    //\n  }, {\n    key: \"format\",\n    get: function get() {\n      return this._format;\n    },\n    set: function set(value) {\n      this._format = value;\n    }\n  }, {\n    key: \"pos\",\n    get: function get() {\n      return this._buf.position;\n    },\n    set: function set(value) {\n      this._buf.position = value;\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      return this._buf.limit;\n    }\n  }, {\n    key: \"instance\",\n    get: function get() {\n      return this._instance;\n    }\n  }, {\n    key: \"closure\",\n    get: function get() {\n      return this._closure;\n    },\n    set: function set(value) {\n      this._closure = value;\n    }\n  }, {\n    key: \"buffer\",\n    get: function get() {\n      return this._buf;\n    }\n  }]);\n}();\nvar defineBuiltinHelper = function defineBuiltinHelper(_write, _read, sz, format, min, max) {\n  var helper = /*#__PURE__*/function () {\n    \"use strict\";\n\n    function helper() {\n      _classCallCheck(this, helper);\n    }\n    return _createClass(helper, null, [{\n      key: \"write\",\n      value: function write(os, v) {\n        return _write.call(os, v);\n      }\n    }, {\n      key: \"read\",\n      value: function read(is) {\n        return _read.call(is);\n      }\n    }, {\n      key: \"writeOptional\",\n      value: function writeOptional(os, tag, v) {\n        os.writeOptionalHelper(tag, format, _write, v);\n      }\n    }, {\n      key: \"readOptional\",\n      value: function readOptional(is, tag) {\n        return is.readOptionalHelper(tag, format, _read);\n      }\n    }, {\n      key: \"minWireSize\",\n      get: function get() {\n        return sz;\n      }\n    }]);\n  }();\n  if (min !== undefined && max !== undefined) {\n    helper.validate = function (v) {\n      return v >= min && v <= max;\n    };\n  }\n  return helper;\n};\nvar istr = InputStream.prototype;\nvar ostr = OutputStream.prototype;\n\n//\n// Constants to use in number type range checks.\n//\nvar MIN_UINT8_VALUE = 0x0;\nvar MAX_UINT8_VALUE = 0xFF;\nvar MIN_INT16_VALUE = -0x8000;\nvar MAX_INT16_VALUE = 0x7FFF;\nvar MIN_UINT32_VALUE = 0x0;\nvar MAX_UINT32_VALUE = 0xFFFFFFFF;\nvar MIN_INT32_VALUE = -0x80000000;\nvar MAX_INT32_VALUE = 0x7FFFFFFF;\nvar MIN_FLOAT32_VALUE = -3.4028234664e+38;\nvar MAX_FLOAT32_VALUE = 3.4028234664e+38;\nIce.ByteHelper = defineBuiltinHelper(ostr.writeByte, istr.readByte, 1, Ice.OptionalFormat.F1, MIN_UINT8_VALUE, MAX_UINT8_VALUE);\nIce.ShortHelper = defineBuiltinHelper(ostr.writeShort, istr.readShort, 2, Ice.OptionalFormat.F2, MIN_INT16_VALUE, MAX_INT16_VALUE);\nIce.IntHelper = defineBuiltinHelper(ostr.writeInt, istr.readInt, 4, Ice.OptionalFormat.F4, MIN_INT32_VALUE, MAX_INT32_VALUE);\nIce.FloatHelper = defineBuiltinHelper(ostr.writeFloat, istr.readFloat, 4, Ice.OptionalFormat.F4, MIN_FLOAT32_VALUE, MAX_FLOAT32_VALUE);\nIce.FloatHelper.validate = function (v) {\n  return Number.isNaN(v) || v == Number.POSITIVE_INFINITY || v == Number.NEGATIVE_INFINITY || v >= MIN_FLOAT32_VALUE && v <= MAX_FLOAT32_VALUE;\n};\nIce.DoubleHelper = defineBuiltinHelper(ostr.writeDouble, istr.readDouble, 8, Ice.OptionalFormat.F8, -Number.MAX_VALUE, Number.MAX_VALUE);\nIce.DoubleHelper.validate = function (v) {\n  return Number.isNaN(v) || v == Number.POSITIVE_INFINITY || v == Number.NEGATIVE_INFINITY || v >= -Number.MAX_VALUE && v <= Number.MAX_VALUE;\n};\nIce.BoolHelper = defineBuiltinHelper(ostr.writeBool, istr.readBool, 1, Ice.OptionalFormat.F1);\nIce.LongHelper = defineBuiltinHelper(ostr.writeLong, istr.readLong, 8, Ice.OptionalFormat.F8);\nIce.LongHelper.validate = function (v) {\n  //\n  // For a long to be valid both words must be within the range of UINT32\n  //\n  return v.low >= MIN_UINT32_VALUE && v.low <= MAX_UINT32_VALUE && v.high >= MIN_UINT32_VALUE && v.high <= MAX_UINT32_VALUE;\n};\nIce.StringHelper = defineBuiltinHelper(ostr.writeString, istr.readString, 1, Ice.OptionalFormat.VSize);\nIce.ObjectHelper = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function _class3() {\n    _classCallCheck(this, _class3);\n  }\n  return _createClass(_class3, null, [{\n    key: \"write\",\n    value: function write(os, v) {\n      os.writeValue(v);\n    }\n  }, {\n    key: \"read\",\n    value: function read(is) {\n      var o;\n      is.readValue(function (v) {\n        o = v;\n      }, Ice.Value);\n      return o;\n    }\n  }, {\n    key: \"writeOptional\",\n    value: function writeOptional(os, tag, v) {\n      os.writeOptionalValue(tag, Ice.OptionalFormat.Class, ostr.writeValue, v);\n    }\n  }, {\n    key: \"readOptional\",\n    value: function readOptional(is, tag) {\n      var o;\n      is.readOptionalValue(tag, function (v) {\n        o = v;\n      }, Ice.Value);\n      return o;\n    }\n  }, {\n    key: \"minWireSize\",\n    get: function get() {\n      return 1;\n    }\n  }]);\n}();\nIce.InputStream = InputStream;\nIce.OutputStream = OutputStream;\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/Stream.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/StreamHelpers.js":
/*!***************************************************!*\
  !*** ./node_modules/ice/src/Ice/StreamHelpers.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/OptionalFormat */ \"./node_modules/ice/src/Ice/OptionalFormat.js\").Ice);\nvar defineProperty = Object.defineProperty;\nvar OptionalFormat = Ice.OptionalFormat;\nvar StreamHelpers = {};\nStreamHelpers.FSizeOptHelper = function () {\n  this.writeOptional = function (os, tag, v) {\n    if (v !== undefined && os.writeOptional(tag, OptionalFormat.FSize)) {\n      var pos = os.startSize();\n      this.write(os, v);\n      os.endSize(pos);\n    }\n  };\n  this.readOptional = function (is, tag) {\n    var v;\n    if (is.readOptional(tag, OptionalFormat.FSize)) {\n      is.skip(4);\n      v = this.read(is);\n    }\n    return v;\n  };\n};\nStreamHelpers.VSizeOptHelper = function () {\n  this.writeOptional = function (os, tag, v) {\n    if (v !== undefined && os.writeOptional(tag, OptionalFormat.VSize)) {\n      os.writeSize(this.minWireSize);\n      this.write(os, v);\n    }\n  };\n  this.readOptional = function (is, tag) {\n    var v;\n    if (is.readOptional(tag, OptionalFormat.VSize)) {\n      is.skipSize();\n      v = this.read(is);\n    }\n    return v;\n  };\n};\nStreamHelpers.VSizeContainerOptHelper = function (elementSize) {\n  this.writeOptional = function (os, tag, v) {\n    if (v !== undefined && os.writeOptional(tag, OptionalFormat.VSize)) {\n      var sz = this.size(v);\n      os.writeSize(sz > 254 ? sz * elementSize + 5 : sz * elementSize + 1);\n      this.write(os, v);\n    }\n  };\n  this.readOptional = function (is, tag) {\n    var v;\n    if (is.readOptional(tag, OptionalFormat.VSize)) {\n      is.skipSize();\n      v = this.read(is);\n    }\n    return v;\n  };\n};\nStreamHelpers.VSizeContainer1OptHelper = function () {\n  this.writeOptional = function (os, tag, v) {\n    if (v !== undefined && os.writeOptional(tag, OptionalFormat.VSize)) {\n      this.write(os, v);\n    }\n  };\n  this.readOptional = function (is, tag) {\n    var v;\n    if (is.readOptional(tag, OptionalFormat.VSize)) {\n      v = this.read(is);\n    }\n    return v;\n  };\n};\n\n//\n// Sequence helper to write sequences\n//\nvar SequenceHelper = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function SequenceHelper() {\n    _classCallCheck(this, SequenceHelper);\n  }\n  return _createClass(SequenceHelper, [{\n    key: \"write\",\n    value: function write(os, v) {\n      if (v === null || v === undefined || v.length === 0) {\n        os.writeSize(0);\n      } else {\n        var helper = this.elementHelper;\n        os.writeSize(v.length);\n        for (var i = 0; i < v.length; ++i) {\n          helper.write(os, v[i]);\n        }\n      }\n    }\n  }, {\n    key: \"read\",\n    value: function read(is) {\n      var helper = this.elementHelper; // Cache the element helper.\n      var sz = is.readAndCheckSeqSize(helper.minWireSize);\n      var v = [];\n      v.length = sz;\n      for (var i = 0; i < sz; ++i) {\n        v[i] = helper.read(is);\n      }\n      return v;\n    }\n  }, {\n    key: \"size\",\n    value: function size(v) {\n      return v === null || v === undefined ? 0 : v.length;\n    }\n  }, {\n    key: \"minWireSize\",\n    get: function get() {\n      return 1;\n    }\n  }]);\n}(); // Speacialization optimized for ByteSeq\nvar byteSeqHelper = new SequenceHelper();\nbyteSeqHelper.write = function (os, v) {\n  return os.writeByteSeq(v);\n};\nbyteSeqHelper.read = function (is) {\n  return is.readByteSeq();\n};\ndefineProperty(byteSeqHelper, \"elementHelper\", {\n  get: function get() {\n    return Ice.ByteHelper;\n  }\n});\nStreamHelpers.VSizeContainer1OptHelper.call(byteSeqHelper);\n\n// Read method for value sequences\nvar valueSequenceHelperRead = function valueSequenceHelperRead(is) {\n  var sz = is.readAndCheckSeqSize(1);\n  var v = [];\n  v.length = sz;\n  var elementType = this.elementType;\n  var readValueAtIndex = function readValueAtIndex(idx) {\n    is.readValue(function (obj) {\n      v[idx] = obj;\n    }, elementType);\n  };\n  for (var i = 0; i < sz; ++i) {\n    readValueAtIndex(i);\n  }\n  return v;\n};\nStreamHelpers.generateSeqHelper = function (elementHelper, fixed, elementType) {\n  if (elementHelper === Ice.ByteHelper) {\n    return byteSeqHelper;\n  }\n  var helper = new SequenceHelper();\n  if (fixed) {\n    if (elementHelper.minWireSize === 1) {\n      StreamHelpers.VSizeContainer1OptHelper.call(helper);\n    } else {\n      StreamHelpers.VSizeContainerOptHelper.call(helper, elementHelper.minWireSize);\n    }\n  } else {\n    StreamHelpers.FSizeOptHelper.call(helper);\n  }\n  defineProperty(helper, \"elementHelper\", {\n    get: function get() {\n      return elementHelper;\n    }\n  });\n  if (elementHelper == Ice.ObjectHelper) {\n    defineProperty(helper, \"elementType\", {\n      get: function get() {\n        return elementType;\n      }\n    });\n    helper.read = valueSequenceHelperRead;\n  }\n  return helper;\n};\n\n//\n// Dictionary helper to write dictionaries\n//\nvar DictionaryHelper = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function DictionaryHelper() {\n    _classCallCheck(this, DictionaryHelper);\n  }\n  return _createClass(DictionaryHelper, [{\n    key: \"write\",\n    value: function write(os, v) {\n      if (v === null || v == undefined || v.size === 0) {\n        os.writeSize(0);\n      } else {\n        var keyHelper = this.keyHelper;\n        var valueHelper = this.valueHelper;\n        os.writeSize(v.size);\n        var _iterator = _createForOfIteratorHelper(v),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _step$value = _slicedToArray(_step.value, 2),\n              key = _step$value[0],\n              value = _step$value[1];\n            keyHelper.write(os, key);\n            valueHelper.write(os, value);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n    }\n  }, {\n    key: \"read\",\n    value: function read(is) {\n      var mapType = this.mapType;\n      var v = new mapType();\n      var sz = is.readSize();\n      var keyHelper = this.keyHelper;\n      var valueHelper = this.valueHelper;\n      for (var i = 0; i < sz; ++i) {\n        v.set(keyHelper.read(is), valueHelper.read(is));\n      }\n      return v;\n    }\n  }, {\n    key: \"size\",\n    value: function size(v) {\n      return v === null || v === undefined ? 0 : v.size;\n    }\n  }, {\n    key: \"minWireSize\",\n    get: function get() {\n      return 1;\n    }\n  }]);\n}(); // Read method for dictionaries of values\nvar valueDictionaryHelperRead = function valueDictionaryHelperRead(is) {\n  var sz = is.readSize();\n  var mapType = this.mapType;\n  var v = new mapType();\n  var valueType = this.valueType;\n  var readValueForKey = function readValueForKey(key) {\n    is.readValue(function (obj) {\n      return v.set(key, obj);\n    }, valueType);\n  };\n  var keyHelper = this.keyHelper;\n  for (var i = 0; i < sz; ++i) {\n    readValueForKey(keyHelper.read(is));\n  }\n  return v;\n};\nStreamHelpers.generateDictHelper = function (keyHelper, valueHelper, fixed, valueType, mapType) {\n  var helper = new DictionaryHelper();\n  if (fixed) {\n    StreamHelpers.VSizeContainerOptHelper.call(helper, keyHelper.minWireSize + valueHelper.minWireSize);\n  } else {\n    StreamHelpers.FSizeOptHelper.call(helper);\n  }\n  defineProperty(helper, \"mapType\", {\n    get: function get() {\n      return mapType;\n    }\n  });\n  defineProperty(helper, \"keyHelper\", {\n    get: function get() {\n      return keyHelper;\n    }\n  });\n  defineProperty(helper, \"valueHelper\", {\n    get: function get() {\n      return valueHelper;\n    }\n  });\n  if (valueHelper == Ice.ObjectHelper) {\n    defineProperty(helper, \"valueType\", {\n      get: function get() {\n        return valueType;\n      }\n    });\n    helper.read = valueDictionaryHelperRead;\n  }\n  return helper;\n};\nIce.StreamHelpers = StreamHelpers;\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/StreamHelpers.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/StringUtil.js":
/*!************************************************!*\
  !*** ./node_modules/ice/src/Ice/StringUtil.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/Debug */ \"./node_modules/ice/src/Ice/Debug.js\").Ice);\nvar Debug = Ice.Debug;\nIce.StringUtil = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function _class() {\n    _classCallCheck(this, _class);\n  }\n  return _createClass(_class, null, [{\n    key: \"findFirstOf\",\n    value:\n    //\n    // Return the index of the first character in str to\n    // appear in match, starting from start. Returns -1 if none is\n    // found.\n    //\n    function findFirstOf(str, match, start) {\n      start = start === undefined ? 0 : start;\n      for (var i = start; i < str.length; i++) {\n        var ch = str.charAt(i);\n        if (match.indexOf(ch) != -1) {\n          return i;\n        }\n      }\n      return -1;\n    }\n\n    //\n    // Return the index of the first character in str which does\n    // not appear in match, starting from start. Returns -1 if none is\n    // found.\n    //\n  }, {\n    key: \"findFirstNotOf\",\n    value: function findFirstNotOf(str, match, start) {\n      start = start === undefined ? 0 : start;\n      for (var i = start; i < str.length; i++) {\n        var ch = str.charAt(i);\n        if (match.indexOf(ch) == -1) {\n          return i;\n        }\n      }\n      return -1;\n    }\n\n    //\n    // Add escape sequences (such as \"\\n\", or \"\\123\") to s\n    //\n  }, {\n    key: \"escapeString\",\n    value: function escapeString(s, special, toStringMode) {\n      special = special === undefined ? null : special;\n      if (special !== null) {\n        for (var i = 0; i < special.length; ++i) {\n          if (special.charCodeAt(i) < 32 || special.charCodeAt(i) > 126) {\n            throw new RangeError(\"special characters must be in ASCII range 32-126\");\n          }\n        }\n      }\n      var result = [];\n      if (toStringMode === Ice.ToStringMode.Compat) {\n        // Encode UTF-8 bytes\n        var bytes = unescape(encodeURIComponent(s));\n        for (var _i = 0; _i < bytes.length; ++_i) {\n          var c = bytes.charCodeAt(_i);\n          encodeChar(c, result, special, toStringMode);\n        }\n      } else {\n        for (var _i2 = 0; _i2 < s.length; ++_i2) {\n          var _c = s.charCodeAt(_i2);\n          if (toStringMode === Ice.ToStringMode.Unicode || _c < 0xD800 || _c > 0xDFFF) {\n            encodeChar(_c, result, special, toStringMode);\n          } else {\n            Debug.assert(toStringMode === Ice.ToStringMode.ASCII && _c >= 0xD800 && _c <= 0xDFFF);\n            if (_i2 + 1 === s.length) {\n              throw new RangeError(\"High surrogate without low surrogate\");\n            } else {\n              var codePoint = s.codePointAt(_i2);\n              Debug.assert(codePoint > 0xFFFF);\n              _i2++;\n\n              // append \\Unnnnnnnn\n              result.push(\"\\\\U\");\n              var hex = codePoint.toString(16);\n              for (var j = hex.length; j < 8; j++) {\n                result.push('0');\n              }\n              result.push(hex);\n            }\n          }\n        }\n      }\n      return result.join(\"\");\n    }\n\n    //\n    // Remove escape sequences added by escapeString. Throws Error\n    // for an invalid input string.\n    //\n  }, {\n    key: \"unescapeString\",\n    value: function unescapeString(s, start, end, special) {\n      start = start === undefined ? 0 : start;\n      end = end === undefined ? s.length : end;\n      special = special === undefined ? null : special;\n      Debug.assert(start >= 0 && start <= end && end <= s.length);\n      if (special !== null) {\n        for (var i = 0; i < special.length; ++i) {\n          if (special.charCodeAt(i) < 32 || special.charCodeAt(i) > 126) {\n            throw new RangeError(\"special characters must be in ASCII range 32-126\");\n          }\n        }\n      }\n\n      // Optimization for strings without escapes\n      var p = s.indexOf('\\\\', start);\n      if (p == -1 || p >= end) {\n        p = start;\n        while (p < end) {\n          checkChar(s, p++);\n        }\n        return s.substring(start, end);\n      } else {\n        var arr = [];\n        while (start < end) {\n          start = decodeChar(s, start, end, special, arr);\n        }\n        return arr.join(\"\");\n      }\n    }\n\n    //\n    // Split string helper; returns null for unmatched quotes\n    //\n  }, {\n    key: \"splitString\",\n    value: function splitString(str, delim) {\n      var v = [];\n      var s = \"\";\n      var pos = 0;\n      var quoteChar = null;\n      while (pos < str.length) {\n        if (quoteChar === null && (str.charAt(pos) === '\"' || str.charAt(pos) === '\\'')) {\n          quoteChar = str.charAt(pos++);\n          continue; // Skip the quote.\n        } else if (quoteChar === null && str.charAt(pos) === '\\\\' && pos + 1 < str.length && (str.charAt(pos + 1) === '\"' || str.charAt(pos + 1) === '\\'')) {\n          ++pos; // Skip the backslash\n        } else if (quoteChar !== null && str.charAt(pos) === '\\\\' && pos + 1 < str.length && str.charAt(pos + 1) === quoteChar) {\n          ++pos; // Skip the backslash\n        } else if (quoteChar !== null && str.charAt(pos) === quoteChar) {\n          ++pos;\n          quoteChar = null;\n          continue; // Skip the quote.\n        } else if (delim.indexOf(str.charAt(pos)) !== -1) {\n          if (quoteChar === null) {\n            ++pos;\n            if (s.length > 0) {\n              v.push(s);\n              s = \"\";\n            }\n            continue;\n          }\n        }\n        if (pos < str.length) {\n          s += str.charAt(pos++);\n        }\n      }\n      if (s.length > 0) {\n        v.push(s);\n      }\n      if (quoteChar !== null) {\n        return null; // Unmatched quote.\n      }\n      return v;\n    }\n\n    //\n    // If a single or double quotation mark is found at the start position,\n    // then the position of the matching closing quote is returned. If no\n    // quotation mark is found at the start position, then 0 is returned.\n    // If no matching closing quote is found, then -1 is returned.\n    //\n  }, {\n    key: \"checkQuote\",\n    value: function checkQuote(s, start) {\n      start = start === undefined ? 0 : start;\n      var quoteChar = s.charAt(start);\n      if (quoteChar == '\"' || quoteChar == '\\'') {\n        start++;\n        var pos;\n        while (start < s.length && (pos = s.indexOf(quoteChar, start)) != -1) {\n          if (s.charAt(pos - 1) != '\\\\') {\n            return pos;\n          }\n          start = pos + 1;\n        }\n        return -1; // Unmatched quote\n      }\n      return 0; // Not quoted\n    }\n  }, {\n    key: \"hashCode\",\n    value: function hashCode(s) {\n      var hash = 0;\n      for (var i = 0; i < s.length; i++) {\n        hash = 31 * hash + s.charCodeAt(i);\n      }\n      return hash;\n    }\n  }, {\n    key: \"toInt\",\n    value: function toInt(s) {\n      var n = parseInt(s, 10);\n      if (isNaN(n)) {\n        throw new RangeError(\"conversion of `\" + s + \"' to int failed\");\n      }\n      return n;\n    }\n  }]);\n}();\nmodule.exports.Ice = Ice;\nfunction encodeChar(c, sb, special, toStringMode) {\n  switch (c) {\n    case 92:\n      // '\\\\'\n      {\n        sb.push(\"\\\\\\\\\");\n        break;\n      }\n    case 39:\n      // '\\''\n      {\n        sb.push(\"\\\\'\");\n        break;\n      }\n    case 34:\n      // '\"'\n      {\n        sb.push(\"\\\\\\\"\");\n        break;\n      }\n    case 7:\n      // '\\a'\n      {\n        if (toStringMode == Ice.ToStringMode.Compat) {\n          // Octal escape for compatibility with 3.6 and earlier\n          sb.push(\"\\\\007\");\n        } else {\n          sb.push(\"\\\\a\");\n        }\n        break;\n      }\n    case 8:\n      // '\\b'\n      {\n        sb.push(\"\\\\b\");\n        break;\n      }\n    case 12:\n      // '\\f'\n      {\n        sb.push(\"\\\\f\");\n        break;\n      }\n    case 10:\n      // '\\n'\n      {\n        sb.push(\"\\\\n\");\n        break;\n      }\n    case 13:\n      // '\\r'\n      {\n        sb.push(\"\\\\r\");\n        break;\n      }\n    case 9:\n      // '\\t'\n      {\n        sb.push(\"\\\\t\");\n        break;\n      }\n    case 11:\n      // '\\v'\n      {\n        if (toStringMode == Ice.ToStringMode.Compat) {\n          // Octal escape for compatibility with 3.6 and earlier\n          sb.push(\"\\\\013\");\n        } else {\n          sb.push(\"\\\\v\");\n        }\n        break;\n      }\n    default:\n      {\n        var s = String.fromCharCode(c);\n        if (special !== null && special.indexOf(s) !== -1) {\n          sb.push('\\\\');\n          sb.push(s);\n        } else if (c < 32 || c > 126) {\n          if (toStringMode === Ice.ToStringMode.Compat) {\n            //\n            // When ToStringMode=Compat, c is a UTF-8 byte\n            //\n            Debug.assert(c < 256);\n            sb.push('\\\\');\n            var octal = c.toString(8);\n            //\n            // Add leading zeroes so that we avoid problems during\n            // decoding. For example, consider the encoded string\n            // \\0013 (i.e., a character with value 1 followed by\n            // the character '3'). If the leading zeroes were omitted,\n            // the result would be incorrectly interpreted by the\n            // decoder as a single character with value 11.\n            //\n            for (var j = octal.length; j < 3; j++) {\n              sb.push('0');\n            }\n            sb.push(octal);\n          } else if (c < 32 || c == 127 || toStringMode === Ice.ToStringMode.ASCII) {\n            // append \\\\unnnn\n            sb.push(\"\\\\u\");\n            var hex = c.toString(16);\n            for (var _j = hex.length; _j < 4; _j++) {\n              sb.push('0');\n            }\n            sb.push(hex);\n          } else {\n            // keep as is\n            sb.push(s);\n          }\n        } else {\n          // printable ASCII character\n          sb.push(s);\n        }\n        break;\n      }\n  }\n}\nfunction checkChar(s, pos) {\n  var c = s.charCodeAt(pos);\n  if (c < 32 || c === 127) {\n    var msg;\n    if (pos > 0) {\n      msg = \"character after `\" + s.substring(0, pos) + \"'\";\n    } else {\n      msg = \"first character\";\n    }\n    msg += \" has invalid ordinal value\" + c;\n    throw new RangeError(msg);\n  }\n  return s.charAt(pos);\n}\n//\n// Decode the character or escape sequence starting at start and appends it to result;\n// returns the index of the first character following the decoded character\n// or escape sequence.\n//\nfunction decodeChar(s, start, end, special, result) {\n  Debug.assert(start >= 0);\n  Debug.assert(start < end);\n  Debug.assert(end <= s.length);\n  if (s.charAt(start) != '\\\\') {\n    result.push(checkChar(s, start++));\n  } else if (start + 1 === end) {\n    ++start;\n    result.push(\"\\\\\"); // trailing backslash\n  } else {\n    var c = s.charAt(++start);\n    switch (c) {\n      case '\\\\':\n      case '\\'':\n      case '\"':\n      case '?':\n        {\n          ++start;\n          result.push(c);\n          break;\n        }\n      case 'a':\n        {\n          ++start;\n          result.append(\"\\x07\");\n          break;\n        }\n      case 'b':\n        {\n          ++start;\n          result.push(\"\\b\");\n          break;\n        }\n      case 'f':\n        {\n          ++start;\n          result.push(\"\\f\");\n          break;\n        }\n      case 'n':\n        {\n          ++start;\n          result.push(\"\\n\");\n          break;\n        }\n      case 'r':\n        {\n          ++start;\n          result.push(\"\\r\");\n          break;\n        }\n      case 't':\n        {\n          ++start;\n          result.push(\"\\t\");\n          break;\n        }\n      case 'v':\n        {\n          ++start;\n          result.push(\"\\v\");\n          break;\n        }\n      case 'u':\n      case 'U':\n        {\n          var codePoint = 0;\n          var inBMP = c === 'u';\n          var size = inBMP ? 4 : 8;\n          ++start;\n          while (size > 0 && start < end) {\n            var charVal = s.charCodeAt(start++);\n            if (charVal >= 0x30 && charVal <= 0x39) {\n              charVal -= 0x30;\n            } else if (charVal >= 0x61 && charVal <= 0x66) {\n              charVal += 10 - 0x61;\n            } else if (charVal >= 0x41 && charVal <= 0x46) {\n              charVal += 10 - 0x41;\n            } else {\n              break; // while\n            }\n            codePoint = codePoint * 16 + charVal;\n            --size;\n          }\n          if (size > 0) {\n            throw new RangeError(\"Invalid universal character name: too few hex digits\");\n          }\n          if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {\n            throw new RangeError(\"A universal character name cannot designate a surrogate\");\n          }\n          if (inBMP || codePoint <= 0xFFFF) {\n            result.push(String.fromCharCode(codePoint));\n          } else {\n            result.push(String.fromCodePoint(codePoint));\n          }\n          break;\n        }\n      case '0':\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case 'x':\n        {\n          // UTF-8 byte sequence encoded with octal or hex escapes\n\n          var arr = [];\n          var more = true;\n          while (more) {\n            var val = 0;\n            if (c === 'x') {\n              var _size = 2;\n              ++start;\n              while (_size > 0 && start < end) {\n                var _charVal = s.charCodeAt(start++);\n                if (_charVal >= 0x30 && _charVal <= 0x39) {\n                  _charVal -= 0x30;\n                } else if (_charVal >= 0x61 && _charVal <= 0x66) {\n                  _charVal += 10 - 0x61;\n                } else if (_charVal >= 0x41 && _charVal <= 0x46) {\n                  _charVal += 10 - 0x41;\n                } else {\n                  break; // while\n                }\n                val = val * 16 + _charVal;\n                --_size;\n              }\n              if (_size === 2) {\n                throw new RangeError(\"Invalid \\\\x escape sequence: no hex digit\");\n              }\n            } else {\n              for (var j = 0; j < 3 && start < end; ++j) {\n                var _charVal2 = s.charCodeAt(start++) - '0'.charCodeAt(0);\n                if (_charVal2 < 0 || _charVal2 > 7) {\n                  --start; // move back\n                  Debug.assert(j !== 0); // must be at least one digit\n                  break; // for\n                }\n                val = val * 8 + _charVal2;\n              }\n              if (val > 255) {\n                throw new RangeError(\"octal value \\\\\" + val.toString(8) + \" (\" + val + \") is out of range\");\n              }\n            }\n            arr.push(String.fromCharCode(val));\n            more = false;\n            if (start + 1 < end && s.charAt(start) === '\\\\') {\n              c = s.charAt(start + 1);\n              var _charVal3 = s.charCodeAt(start + 1);\n              if (c === 'x' || _charVal3 >= 0x30 && _charVal3 <= 0x39) {\n                start++;\n                more = true;\n              }\n            }\n          }\n\n          // Decode UTF-8 arr into string\n          result.push(decodeURIComponent(escape(arr.join(\"\"))));\n          break;\n        }\n      default:\n        {\n          if (special === null || special.length === 0 || special.indexOf(c) === -1) {\n            result.push(\"\\\\\"); // not in special, so we keep the backslash\n          }\n          result.push(checkChar(s, start++));\n          break;\n        }\n    }\n  }\n  return start;\n}\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/StringUtil.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Struct.js":
/*!********************************************!*\
  !*** ./node_modules/ice/src/Ice/Struct.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\nvar ArrayUtil = Ice.ArrayUtil;\n\n//\n// Use generic equality test from ArrayUtil.\n//\nvar eq = ArrayUtil.eq;\nfunction equals(other) {\n  if (this === other) {\n    return true;\n  }\n  if (other === null || other === undefined) {\n    return false;\n  }\n  if (this.prototype !== other.prototype) {\n    return false;\n  }\n  for (var key in this) {\n    var e1 = this[key];\n    var e2 = other[key];\n    if (typeof e1 == \"function\") {\n      continue; // Don't need to compare functions\n    } else if (!eq(e1, e2)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction clone() {\n  var other = new this.constructor();\n  for (var key in this) {\n    var e = this[key];\n    if (e === undefined || e === null) {\n      other[key] = e;\n    } else if (typeof e == \"function\") {\n      continue;\n    } else if (typeof e.clone == \"function\") {\n      other[key] = e.clone();\n    } else if (e instanceof Array) {\n      other[key] = ArrayUtil.clone(e);\n    } else {\n      other[key] = e;\n    }\n  }\n  return other;\n}\nfunction memberHashCode(h, e) {\n  if (typeof e.hashCode == \"function\") {\n    return Ice.HashUtil.addHashable(h, e);\n  } else if (e instanceof Array) {\n    return Ice.HashUtil.addArray(h, e, memberHashCode);\n  } else {\n    var t = _typeof(e);\n    if (e instanceof String || t == \"string\") {\n      return Ice.HashUtil.addString(h, e);\n    } else if (e instanceof Number || t == \"number\") {\n      return Ice.HashUtil.addNumber(h, e);\n    } else if (e instanceof Boolean || t == \"boolean\") {\n      return Ice.HashUtil.addBoolean(h, e);\n    }\n  }\n}\nfunction hashCode() {\n  var h = 5381;\n  for (var key in this) {\n    var e = this[key];\n    if (e === undefined || e === null || typeof e == \"function\") {\n      continue;\n    }\n    h = memberHashCode(h, e);\n  }\n  return h;\n}\nIce.Slice.defineStruct = function (obj, legalKeyType, variableLength) {\n  obj.prototype.clone = clone;\n  obj.prototype.equals = equals;\n\n  //\n  // Only generate hashCode if this structure type is a legal dictionary key type.\n  //\n  if (legalKeyType) {\n    obj.prototype.hashCode = hashCode;\n  }\n  if (obj.prototype._write && obj.prototype._read) {\n    obj.write = function (os, v) {\n      if (!v) {\n        if (!obj.prototype._nullMarshalValue) {\n          obj.prototype._nullMarshalValue = new this();\n        }\n        v = obj.prototype._nullMarshalValue;\n      }\n      v._write(os);\n    };\n    obj.read = function (is, v) {\n      if (!v || !(v instanceof this)) {\n        v = new this();\n      }\n      v._read(is);\n      return v;\n    };\n    if (variableLength) {\n      Ice.StreamHelpers.FSizeOptHelper.call(obj);\n    } else {\n      Ice.StreamHelpers.VSizeOptHelper.call(obj);\n    }\n  }\n  return obj;\n};\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/Struct.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/TcpEndpointFactory.js":
/*!********************************************************!*\
  !*** ./node_modules/ice/src/Ice/TcpEndpointFactory.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/TcpEndpointI */ \"./node_modules/ice/src/Ice/TcpEndpointI.js\").Ice);\nvar TcpEndpointI = Ice.TcpEndpointI;\nvar TcpEndpointFactory = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function TcpEndpointFactory(instance) {\n    _classCallCheck(this, TcpEndpointFactory);\n    this._instance = instance;\n  }\n  return _createClass(TcpEndpointFactory, [{\n    key: \"type\",\n    value: function type() {\n      return this._instance.type();\n    }\n  }, {\n    key: \"protocol\",\n    value: function protocol() {\n      return this._instance.protocol();\n    }\n  }, {\n    key: \"create\",\n    value: function create(args, oaEndpoint) {\n      var e = new TcpEndpointI(this._instance);\n      e.initWithOptions(args, oaEndpoint);\n      return e;\n    }\n  }, {\n    key: \"read\",\n    value: function read(s) {\n      var e = new TcpEndpointI(this._instance);\n      e.initWithStream(s);\n      return e;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this._instance = null;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone(instance) {\n      return new TcpEndpointFactory(instance);\n    }\n  }]);\n}();\nIce.TcpEndpointFactory = TcpEndpointFactory;\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/TcpEndpointFactory.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/TcpEndpointI.js":
/*!**************************************************!*\
  !*** ./node_modules/ice/src/Ice/TcpEndpointI.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && \"function\" == typeof p ? function (t) { return p.apply(e, t); } : p; }\nfunction _get() { return _get = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }\nfunction _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n__webpack_require__(/*! ../Ice/Debug */ \"./node_modules/ice/src/Ice/Debug.js\");\n__webpack_require__(/*! ../Ice/EndpointInfo */ \"./node_modules/ice/src/Ice/EndpointInfo.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/IPEndpointI */ \"./node_modules/ice/src/Ice/IPEndpointI.js\");\n__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\");\n__webpack_require__(/*! ../Ice/StringUtil */ \"./node_modules/ice/src/Ice/StringUtil.js\");\n__webpack_require__(/*! ../Ice/TcpTransceiver */ \"./node_modules/ice/src/Ice/TcpTransceiver.js\");\nvar IceSSL = (__webpack_require__(/*! ../Ice/EndpointInfo */ \"./node_modules/ice/src/Ice/EndpointInfo.js\").IceSSL);\nvar Debug = Ice.Debug;\nvar HashUtil = Ice.HashUtil;\nvar StringUtil = Ice.StringUtil;\nvar TcpTransceiver = typeof Ice.TcpTransceiver !== \"undefined\" ? Ice.TcpTransceiver : null;\nvar TcpEndpointI = /*#__PURE__*/function (_Ice$IPEndpointI) {\n  \"use strict\";\n\n  function TcpEndpointI(instance, ho, po, sif, ti, conId, co) {\n    var _this;\n    _classCallCheck(this, TcpEndpointI);\n    _this = _callSuper(this, TcpEndpointI, [instance, ho, po, sif, conId]);\n    _this._timeout = ti === undefined ? instance ? instance.defaultTimeout() : undefined : ti;\n    _this._compress = co === undefined ? false : co;\n    return _this;\n  }\n\n  //\n  // Return the endpoint information.\n  //\n  _inherits(TcpEndpointI, _Ice$IPEndpointI);\n  return _createClass(TcpEndpointI, [{\n    key: \"getInfo\",\n    value: function getInfo() {\n      var info = new Ice.TCPEndpointInfo();\n      this.fillEndpointInfo(info);\n      return this.secure() ? new IceSSL.EndpointInfo(info, info.timeout, info.compress) : info;\n    }\n\n    //\n    // Return the timeout for the endpoint in milliseconds. 0 means\n    // non-blocking, -1 means no timeout.\n    //\n  }, {\n    key: \"timeout\",\n    value: function timeout() {\n      return this._timeout;\n    }\n\n    //\n    // Return a new endpoint with a different timeout value, provided\n    // that timeouts are supported by the endpoint. Otherwise the same\n    // endpoint is returned.\n    //\n  }, {\n    key: \"changeTimeout\",\n    value: function changeTimeout(timeout) {\n      if (timeout === this._timeout) {\n        return this;\n      } else {\n        return new TcpEndpointI(this._instance, this._host, this._port, this._sourceAddr, timeout, this._connectionId, this._compress);\n      }\n    }\n\n    //\n    // Return a new endpoint with a different connection id.\n    //\n  }, {\n    key: \"changeConnectionId\",\n    value: function changeConnectionId(connectionId) {\n      if (connectionId === this._connectionId) {\n        return this;\n      } else {\n        return new TcpEndpointI(this._instance, this._host, this._port, this._sourceAddr, this._timeout, connectionId, this._compress);\n      }\n    }\n\n    //\n    // Return true if the endpoints support bzip2 compress, or false\n    // otherwise.\n    //\n  }, {\n    key: \"compress\",\n    value: function compress() {\n      return this._compress;\n    }\n\n    //\n    // Return a new endpoint with a different compression value,\n    // provided that compression is supported by the\n    // endpoint. Otherwise the same endpoint is returned.\n    //\n  }, {\n    key: \"changeCompress\",\n    value: function changeCompress(compress) {\n      if (compress === this._compress) {\n        return this;\n      } else {\n        return new TcpEndpointI(this._instance, this._host, this._port, this._sourceAddr, this._timeout, this._connectionId, compress);\n      }\n    }\n\n    //\n    // Return true if the endpoint is datagram-based.\n    //\n  }, {\n    key: \"datagram\",\n    value: function datagram() {\n      return false;\n    }\n  }, {\n    key: \"connectable\",\n    value: function connectable() {\n      //\n      // TCP endpoints are not connectable when running in a browser, SSL\n      // isn't currently supported.\n      //\n      return typeof process !== 'undefined' && !this.secure();\n    }\n  }, {\n    key: \"connect\",\n    value: function connect() {\n      Debug.assert(!this.secure());\n      return TcpTransceiver.createOutgoing(this._instance, this.getAddress(), this._sourceAddr);\n    }\n\n    //\n    // Convert the endpoint to its string form\n    //\n  }, {\n    key: \"options\",\n    value: function options() {\n      //\n      // WARNING: Certain features, such as proxy validation in Glacier2,\n      // depend on the format of proxy strings. Changes to toString() and\n      // methods called to generate parts of the reference string could break\n      // these features. Please review for all features that depend on the\n      // format of proxyToString() before changing this and related code.\n      //\n      var s = _superPropGet(TcpEndpointI, \"options\", this, 3)([]);\n      if (this._timeout == -1) {\n        s += \" -t infinite\";\n      } else {\n        s += \" -t \" + this._timeout;\n      }\n      if (this._compress) {\n        s += \" -z\";\n      }\n      return s;\n    }\n  }, {\n    key: \"compareTo\",\n    value: function compareTo(p) {\n      if (this === p) {\n        return 0;\n      }\n      if (p === null) {\n        return 1;\n      }\n      if (!(p instanceof TcpEndpointI)) {\n        return this.type() < p.type() ? -1 : 1;\n      }\n      if (this._timeout < p._timeout) {\n        return -1;\n      } else if (p._timeout < this._timeout) {\n        return 1;\n      }\n      if (!this._compress && p._compress) {\n        return -1;\n      } else if (!p._compress && this._compress) {\n        return 1;\n      }\n      return _superPropGet(TcpEndpointI, \"compareTo\", this, 3)([p]);\n    }\n  }, {\n    key: \"streamWriteImpl\",\n    value: function streamWriteImpl(s) {\n      _superPropGet(TcpEndpointI, \"streamWriteImpl\", this, 3)([s]);\n      s.writeInt(this._timeout);\n      s.writeBool(this._compress);\n    }\n  }, {\n    key: \"hashInit\",\n    value: function hashInit(h) {\n      h = _superPropGet(TcpEndpointI, \"hashInit\", this, 3)([h]);\n      h = HashUtil.addNumber(h, this._timeout);\n      h = HashUtil.addBoolean(h, this._compress);\n      return h;\n    }\n  }, {\n    key: \"fillEndpointInfo\",\n    value: function fillEndpointInfo(info) {\n      _superPropGet(TcpEndpointI, \"fillEndpointInfo\", this, 3)([info]);\n      info.timeout = this._timeout;\n      info.compress = this._compress;\n    }\n  }, {\n    key: \"initWithStream\",\n    value: function initWithStream(s) {\n      _superPropGet(TcpEndpointI, \"initWithStream\", this, 3)([s]);\n      this._timeout = s.readInt();\n      this._compress = s.readBool();\n    }\n  }, {\n    key: \"checkOption\",\n    value: function checkOption(option, argument, endpoint) {\n      if (_superPropGet(TcpEndpointI, \"checkOption\", this, 3)([option, argument, endpoint])) {\n        return true;\n      }\n      if (option === \"-t\") {\n        if (argument === null) {\n          throw new Ice.EndpointParseException(\"no argument provided for -t option in endpoint \" + endpoint);\n        }\n        if (argument == \"infinite\") {\n          this._timeout = -1;\n        } else {\n          var invalid = false;\n          try {\n            this._timeout = StringUtil.toInt(argument);\n          } catch (ex) {\n            invalid = true;\n          }\n          if (invalid || this._timeout < 1) {\n            throw new Ice.EndpointParseException(\"invalid timeout value `\" + argument + \"' in endpoint \" + endpoint);\n          }\n        }\n      } else if (option === \"-z\") {\n        if (argument !== null) {\n          throw new Ice.EndpointParseException(\"unexpected argument `\" + argument + \"' provided for -z option in \" + endpoint);\n        }\n        this._compress = true;\n      } else {\n        return false;\n      }\n      return true;\n    }\n  }, {\n    key: \"createEndpoint\",\n    value: function createEndpoint(host, port, conId) {\n      return new TcpEndpointI(this._instance, host, port, this._sourceAddr, this._timeout, conId, this._compress);\n    }\n  }]);\n}(Ice.IPEndpointI);\nIce.TcpEndpointI = TcpEndpointI;\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/TcpEndpointI.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/TcpTransceiver.js":
/*!****************************************************!*\
  !*** ./node_modules/ice/src/Ice/TcpTransceiver.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n__webpack_require__(/*! ../Ice/Connection */ \"./node_modules/ice/src/Ice/Connection.js\");\n__webpack_require__(/*! ../Ice/Debug */ \"./node_modules/ice/src/Ice/Debug.js\");\n__webpack_require__(/*! ../Ice/Exception */ \"./node_modules/ice/src/Ice/Exception.js\");\n__webpack_require__(/*! ../Ice/SocketOperation */ \"./node_modules/ice/src/Ice/SocketOperation.js\");\n__webpack_require__(/*! ../Ice/Timer */ \"./node_modules/ice/src/Ice/Timer.js\");\nvar _TcpTransceiver = {};\nif (typeof process !== 'undefined') {\n  var fdToString = function fdToString(fd, targetAddr) {\n    if (fd === null) {\n      return \"<closed>\";\n    }\n    return addressesToString(fd.localAddress, fd.localPort, fd.remoteAddress, fd.remotePort, targetAddr);\n  };\n  var translateError = function translateError(state, err) {\n    if (!err) {\n      return new Ice.ConnectionLostException();\n    } else if (state < StateConnected) {\n      if (connectionRefused(err.code)) {\n        return new Ice.ConnectionRefusedException(err.code, err);\n      } else if (connectionFailed(err.code)) {\n        return new Ice.ConnectFailedException(err.code, err);\n      }\n    } else if (connectionLost(err.code)) {\n      return new Ice.ConnectionLostException(err.code, err);\n    }\n    return new Ice.SocketException(err.code, err);\n  };\n  var addressesToString = function addressesToString(localHost, localPort, remoteHost, remotePort, targetAddr) {\n    remoteHost = remoteHost === undefined ? null : remoteHost;\n    targetAddr = targetAddr === undefined ? null : targetAddr;\n    var s = [];\n    s.push(\"local address = \");\n    s.push(localHost + \":\" + localPort);\n    if (remoteHost === null && targetAddr !== null) {\n      remoteHost = targetAddr.host;\n      remotePort = targetAddr.port;\n    }\n    if (remoteHost === null) {\n      s.push(\"\\nremote address = <not connected>\");\n    } else {\n      s.push(\"\\nremote address = \");\n      s.push(remoteHost + \":\" + remotePort);\n    }\n    return s.join(\"\");\n  };\n  var connectionRefused = function connectionRefused(err) {\n    return err == ECONNREFUSED;\n  };\n  var connectionFailed = function connectionFailed(err) {\n    return err == ECONNREFUSED || err == ETIMEDOUT || err == ENETUNREACH || err == EHOSTUNREACH || err == ECONNRESET || err == ESHUTDOWN || err == ECONNABORTED;\n  };\n  var connectionLost = function connectionLost(err) {\n    return err == ECONNRESET || err == ENOTCONN || err == ESHUTDOWN || err == ECONNABORTED || err == EPIPE;\n  };\n  var net = __webpack_require__(/*! net */ \"?c885\");\n  var Debug = Ice.Debug;\n  var SocketOperation = Ice.SocketOperation;\n  var Timer = Ice.Timer;\n  var StateNeedConnect = 0;\n  var StateConnectPending = 1;\n  var StateProxyConnectRequest = 2;\n  var StateProxyConnectRequestPending = 3;\n  var StateConnected = 4;\n\n  //\n  // TODO: WORKAROUND: We can directly use Buffer.from once we drop\n  // support for Node 4.x\n  //\n  var createBuffer = null;\n  if (Buffer.from) {\n    createBuffer = Buffer.from;\n  } else {\n    /* eslint-disable no-buffer-constructor */\n    createBuffer = function createBuffer(data) {\n      return new Buffer(data);\n    };\n    /* eslint-enable no-buffer-constructor */\n  }\n  _TcpTransceiver = /*#__PURE__*/function () {\n    \"use strict\";\n\n    function TcpTransceiver(instance) {\n      _classCallCheck(this, TcpTransceiver);\n      this._logger = instance.logger();\n      this._readBuffers = [];\n      this._readPosition = 0;\n      this._maxSendPacketSize = instance.properties().getPropertyAsIntWithDefault(\"Ice.TCP.SndSize\", 512 * 1024);\n    }\n    return _createClass(TcpTransceiver, [{\n      key: \"setCallbacks\",\n      value: function setCallbacks(connectedCallback, bytesAvailableCallback, bytesWrittenCallback) {\n        this._connectedCallback = connectedCallback;\n        this._bytesAvailableCallback = bytesAvailableCallback;\n        this._bytesWrittenCallback = bytesWrittenCallback;\n      }\n\n      //\n      // Returns SocketOperation.None when initialization is complete.\n      //\n    }, {\n      key: \"initialize\",\n      value: function initialize(readBuffer, writeBuffer) {\n        var _this = this;\n        try {\n          if (this._exception) {\n            throw this._exception;\n          }\n          if (this._state === StateNeedConnect) {\n            this._state = StateConnectPending;\n            this._fd = net.createConnection({\n              port: this._addr.port,\n              host: this._addr.host,\n              localAddress: this._sourceAddr\n            });\n            this._fd.on(\"connect\", function () {\n              return _this.socketConnected();\n            });\n            this._fd.on(\"data\", function (buf) {\n              return _this.socketBytesAvailable(buf);\n            });\n\n            //\n            // The error callback can be triggered from the socket\n            // write(). We don't want it to dispached right away\n            // from within the write() so we delay the call with\n            // setImmediate. We do the same for close as a\n            // precaution. See also issue #6226.\n            //\n            this._fd.on(\"close\", function (err) {\n              return Timer.setImmediate(function () {\n                return _this.socketClosed(err);\n              });\n            });\n            this._fd.on(\"error\", function (err) {\n              return Timer.setImmediate(function () {\n                return _this.socketError(err);\n              });\n            });\n            return SocketOperation.Connect; // Waiting for connect to complete.\n          } else if (this._state === StateConnectPending) {\n            //\n            // Socket is connected.\n            //\n            this._desc = fdToString(this._fd, this._proxy, this._addr);\n            this._state = StateConnected;\n          } else if (this._state === StateProxyConnectRequest) {\n            //\n            // Write completed.\n            //\n            this._proxy.endWriteConnectRequest(writeBuffer);\n            this._state = StateProxyConnectRequestPending; // Wait for proxy response\n            return SocketOperation.Read;\n          } else if (this._state === StateProxyConnectRequestPending) {\n            //\n            // Read completed.\n            //\n            this._proxy.endReadConnectRequestResponse(readBuffer);\n            this._state = StateConnected;\n          }\n        } catch (err) {\n          if (!this._exception) {\n            this._exception = translateError(this._state, err);\n          }\n          throw this._exception;\n        }\n        Debug.assert(this._state === StateConnected);\n        return SocketOperation.None;\n      }\n    }, {\n      key: \"register\",\n      value: function register() {\n        this._registered = true;\n        this._fd.resume();\n        if (this._exception) {\n          this._bytesAvailableCallback();\n        }\n      }\n    }, {\n      key: \"unregister\",\n      value: function unregister() {\n        if (this._fd === null) {\n          Debug.assert(this._exception); // Socket creation failed.\n          return;\n        }\n        this._registered = false;\n        this._fd.pause();\n      }\n    }, {\n      key: \"close\",\n      value: function close() {\n        if (this._fd === null) {\n          Debug.assert(this._exception); // Socket creation failed.\n          return;\n        }\n        try {\n          this._fd.destroy();\n        } catch (ex) {\n          throw translateError(this._state, ex);\n        } finally {\n          this._fd = null;\n        }\n      }\n\n      //\n      // Returns true if all of the data was flushed to the kernel buffer.\n      //\n    }, {\n      key: \"write\",\n      value: function write(byteBuffer) {\n        var _this2 = this;\n        if (this._exception) {\n          throw this._exception;\n        }\n        var packetSize = byteBuffer.remaining;\n        Debug.assert(packetSize > 0);\n        if (this._maxSendPacketSize > 0 && packetSize > this._maxSendPacketSize) {\n          packetSize = this._maxSendPacketSize;\n        }\n        var _loop = function _loop() {\n            var slice = byteBuffer.b.slice(byteBuffer.position, byteBuffer.position + packetSize);\n            var sync = true;\n            sync = _this2._fd.write(createBuffer(slice), null, function () {\n              if (!sync) {\n                _this2._bytesWrittenCallback();\n              }\n            });\n            byteBuffer.position += packetSize;\n            if (!sync) {\n              return {\n                v: false\n              }; // Wait for callback to be called before sending more data.\n            }\n            if (_this2._maxSendPacketSize > 0 && byteBuffer.remaining > _this2._maxSendPacketSize) {\n              packetSize = _this2._maxSendPacketSize;\n            } else {\n              packetSize = byteBuffer.remaining;\n            }\n          },\n          _ret;\n        while (packetSize > 0) {\n          _ret = _loop();\n          if (_ret) return _ret.v;\n        }\n        return true;\n      }\n    }, {\n      key: \"read\",\n      value: function read(byteBuffer, moreData) {\n        if (this._exception) {\n          throw this._exception;\n        }\n        moreData.value = false;\n        if (this._readBuffers.length === 0) {\n          return false; // No data available.\n        }\n        var avail = this._readBuffers[0].length - this._readPosition;\n        Debug.assert(avail > 0);\n        while (byteBuffer.remaining > 0) {\n          if (avail > byteBuffer.remaining) {\n            avail = byteBuffer.remaining;\n          }\n          this._readBuffers[0].copy(createBuffer(byteBuffer.b), byteBuffer.position, this._readPosition, this._readPosition + avail);\n          byteBuffer.position += avail;\n          this._readPosition += avail;\n          if (this._readPosition === this._readBuffers[0].length) {\n            //\n            // We've exhausted the current read buffer.\n            //\n            this._readPosition = 0;\n            this._readBuffers.shift();\n            if (this._readBuffers.length === 0) {\n              break; // No more data - we're done.\n            } else {\n              avail = this._readBuffers[0].length;\n            }\n          }\n        }\n        moreData.value = this._readBuffers.length > 0;\n        return byteBuffer.remaining === 0;\n      }\n    }, {\n      key: \"type\",\n      value: function type() {\n        return \"tcp\";\n      }\n    }, {\n      key: \"getInfo\",\n      value: function getInfo() {\n        Debug.assert(this._fd !== null);\n        var info = new Ice.TCPConnectionInfo();\n        info.localAddress = this._fd.localAddress;\n        info.localPort = this._fd.localPort;\n        info.remoteAddress = this._fd.remoteAddress;\n        info.remotePort = this._fd.remotePort;\n        info.rcvSize = -1;\n        info.sndSize = this._maxSendPacketSize;\n        return info;\n      }\n    }, {\n      key: \"checkSendSize\",\n      value: function checkSendSize(stream) {}\n    }, {\n      key: \"setBufferSize\",\n      value: function setBufferSize(rcvSize, sndSize) {\n        this._maxSendPacketSize = sndSize;\n      }\n    }, {\n      key: \"toString\",\n      value: function toString() {\n        return this._desc;\n      }\n    }, {\n      key: \"socketConnected\",\n      value: function socketConnected() {\n        Debug.assert(this._connectedCallback !== null);\n        this._connectedCallback();\n      }\n    }, {\n      key: \"socketBytesAvailable\",\n      value: function socketBytesAvailable(buf) {\n        Debug.assert(this._bytesAvailableCallback !== null);\n\n        //\n        // TODO: Should we set a limit on how much data we can read?\n        // We can call _fd.pause() to temporarily stop reading.\n        //\n        if (buf.length > 0) {\n          this._readBuffers.push(buf);\n          this._bytesAvailableCallback();\n        }\n      }\n    }, {\n      key: \"socketClosed\",\n      value: function socketClosed(err) {\n        //\n        // Don't call the closed callback if an error occurred; the error callback\n        // will be called.\n        //\n        if (!err) {\n          this.socketError(null);\n        }\n      }\n    }, {\n      key: \"socketError\",\n      value: function socketError(err) {\n        this._exception = translateError(this._state, err);\n        if (this._state < StateConnected) {\n          this._connectedCallback();\n        } else if (this._registered) {\n          this._bytesAvailableCallback();\n        }\n      }\n    }], [{\n      key: \"createOutgoing\",\n      value: function createOutgoing(instance, addr, sourceAddr) {\n        var transceiver = new _TcpTransceiver(instance);\n        transceiver._fd = null;\n        transceiver._addr = addr;\n        transceiver._sourceAddr = sourceAddr;\n        transceiver._desc = \"local address = <not connected>\\nremote address = \" + addr.host + \":\" + addr.port;\n        transceiver._state = StateNeedConnect;\n        transceiver._registered = false;\n        transceiver._exception = null;\n        return transceiver;\n      }\n    }, {\n      key: \"createIncoming\",\n      value: function createIncoming(instance, fd) {\n        var transceiver = new _TcpTransceiver(instance);\n        transceiver._fd = fd;\n        transceiver._addr = null;\n        transceiver._sourceAddr = null;\n        transceiver._desc = fdToString(fd);\n        transceiver._state = StateConnected;\n        transceiver._registered = false;\n        transceiver._exception = null;\n        return transceiver;\n      }\n    }]);\n  }();\n  var ECONNABORTED = \"ECONNABORTED\";\n  var ECONNREFUSED = \"ECONNREFUSED\";\n  var ECONNRESET = \"ECONNRESET\";\n  var EHOSTUNREACH = \"EHOSTUNREACH\";\n  var ENETUNREACH = \"ENETUNREACH\";\n  var ENOTCONN = \"ENOTCONN\";\n  var EPIPE = \"EPIPE\";\n  var ESHUTDOWN = \"ESHUTDOWN\";\n  var ETIMEDOUT = \"ETIMEDOUT\";\n} else {\n  _TcpTransceiver = /*#__PURE__*/_createClass(function _TcpTransceiver() {\n    \"use strict\";\n\n    _classCallCheck(this, _TcpTransceiver);\n  });\n}\nIce.TcpTransceiver = _TcpTransceiver;\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/TcpTransceiver.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Timer.js":
/*!*******************************************!*\
  !*** ./node_modules/ice/src/Ice/Timer.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\");\n__webpack_require__(/*! ../Ice/TimerUtil */ \"./node_modules/ice/src/Ice/TimerUtil.js\");\nvar CommunicatorDestroyedException = Ice.CommunicatorDestroyedException;\nvar Timer = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function Timer(logger) {\n    _classCallCheck(this, Timer);\n    this._logger = logger;\n    this._destroyed = false;\n    this._tokenId = 0;\n    this._tokens = new Map();\n  }\n  return _createClass(Timer, [{\n    key: \"destroy\",\n    value: function destroy() {\n      var _this = this;\n      this._tokens.forEach(function (value, key) {\n        return _this.cancel(key);\n      });\n      this._destroyed = true;\n      this._tokens.clear();\n    }\n  }, {\n    key: \"schedule\",\n    value: function schedule(callback, delay) {\n      var _this2 = this;\n      if (this._destroyed) {\n        throw new CommunicatorDestroyedException();\n      }\n      var token = this._tokenId++;\n      var id = Timer.setTimeout(function () {\n        return _this2.handleTimeout(token);\n      }, delay);\n      this._tokens.set(token, {\n        callback: callback,\n        id: id,\n        isInterval: false\n      });\n      return token;\n    }\n  }, {\n    key: \"scheduleRepeated\",\n    value: function scheduleRepeated(callback, period) {\n      var _this3 = this;\n      if (this._destroyed) {\n        throw new CommunicatorDestroyedException();\n      }\n      var token = this._tokenId++;\n      var id = Timer.setInterval(function () {\n        return _this3.handleInterval(token);\n      }, period);\n      this._tokens.set(token, {\n        callback: callback,\n        id: id,\n        isInterval: true\n      });\n      return token;\n    }\n  }, {\n    key: \"cancel\",\n    value: function cancel(id) {\n      if (this._destroyed) {\n        return false;\n      }\n      var token = this._tokens.get(id);\n      if (token === undefined) {\n        return false;\n      }\n      this._tokens[\"delete\"](id);\n      if (token.isInterval) {\n        Timer.clearInterval(token.id);\n      } else {\n        Timer.clearTimeout(token.id);\n      }\n      return true;\n    }\n  }, {\n    key: \"handleTimeout\",\n    value: function handleTimeout(id) {\n      if (this._destroyed) {\n        return;\n      }\n      var token = this._tokens.get(id);\n      if (token !== undefined) {\n        this._tokens[\"delete\"](id);\n        try {\n          token.callback();\n        } catch (ex) {\n          this._logger.warning(\"uncaught exception while executing timer:\\n\" + ex);\n        }\n      }\n    }\n  }, {\n    key: \"handleInterval\",\n    value: function handleInterval(id) {\n      if (this._destroyed) {\n        return;\n      }\n      var token = this._tokens.get(id);\n      if (token !== undefined) {\n        try {\n          token.callback();\n        } catch (ex) {\n          this._logger.warning(\"uncaught exception while executing timer:\\n\" + ex);\n        }\n      }\n    }\n  }]);\n}();\nTimer.setTimeout = Ice.Timer.setTimeout;\nTimer.clearTimeout = Ice.Timer.clearTimeout;\nTimer.setInterval = Ice.Timer.setInterval;\nTimer.clearInterval = Ice.Timer.clearInterval;\nTimer.setImmediate = Ice.Timer.setImmediate;\nIce.Timer = Timer;\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/Timer.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/TimerUtil.js":
/*!***********************************************!*\
  !*** ./node_modules/ice/src/Ice/TimerUtil.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\nvar Timer = {};\nif (typeof process != 'undefined') {\n  Timer = /*#__PURE__*/_createClass(function Timer() {\n    \"use strict\";\n\n    _classCallCheck(this, Timer);\n  });\n  Timer.setTimeout = setTimeout;\n  Timer.clearTimeout = clearTimeout;\n  Timer.setInterval = setInterval;\n  Timer.clearInterval = clearInterval;\n  Timer.setImmediate = setImmediate;\n  Ice.Timer = Timer;\n} else {\n  var isIE = function isIE() {\n    return navigator.userAgent.indexOf(\"MSIE\") !== -1 || navigator.userAgent.match(/Trident.*rv:11\\./);\n  };\n  var isEdge = function isEdge() {\n    return /Edge/.test(navigator.userAgent);\n  };\n  var isWorker = function isWorker() {\n    return typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope;\n  };\n  //\n  // Create a timer object that uses the default browser methods.\n  //\n  var createTimerObject = function createTimerObject() {\n    var Timer = /*#__PURE__*/function () {\n      \"use strict\";\n\n      function Timer() {\n        _classCallCheck(this, Timer);\n      }\n      return _createClass(Timer, null, [{\n        key: \"setTimeout\",\n        value: function (_setTimeout) {\n          function setTimeout(_x, _x2) {\n            return _setTimeout.apply(this, arguments);\n          }\n          setTimeout.toString = function () {\n            return _setTimeout.toString();\n          };\n          return setTimeout;\n        }(function (cb, ms) {\n          return setTimeout(cb, ms);\n        })\n      }, {\n        key: \"clearTimeout\",\n        value: function (_clearTimeout) {\n          function clearTimeout(_x3) {\n            return _clearTimeout.apply(this, arguments);\n          }\n          clearTimeout.toString = function () {\n            return _clearTimeout.toString();\n          };\n          return clearTimeout;\n        }(function (id) {\n          return clearTimeout(id);\n        })\n      }, {\n        key: \"setInterval\",\n        value: function (_setInterval) {\n          function setInterval(_x4, _x5) {\n            return _setInterval.apply(this, arguments);\n          }\n          setInterval.toString = function () {\n            return _setInterval.toString();\n          };\n          return setInterval;\n        }(function (cb, ms) {\n          return setInterval(cb, ms);\n        })\n      }, {\n        key: \"clearInterval\",\n        value: function (_clearInterval) {\n          function clearInterval(_x6) {\n            return _clearInterval.apply(this, arguments);\n          }\n          clearInterval.toString = function () {\n            return _clearInterval.toString();\n          };\n          return clearInterval;\n        }(function (id) {\n          return clearInterval(id);\n        })\n      }]);\n    }();\n\n    //\n    // For Browsers that support setImmediate prefer that,\n    // otherwise implement it using MessageChannel\n    //\n    if (isEdge() || isIE()) {\n      Timer.setImmediate = function (cb) {\n        setImmediate(cb);\n      };\n    } else {\n      //\n      // Should be only call for workers\n      //\n      var channel = new MessageChannel();\n      channel.port1.onmessage = function (event) {\n        var id = event.data;\n        var cb = _timers.get(id);\n        if (cb !== undefined) {\n          cb.call();\n          _timers[\"delete\"](id);\n        }\n      };\n      Timer.setImmediate = function (cb) {\n        var id = nextId();\n        _timers.set(id, cb);\n        channel.port2.postMessage(id);\n      };\n    }\n    return Timer;\n  };\n  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;\n  var _nextId = 0;\n  var nextId = function nextId() {\n    if (_nextId == MAX_SAFE_INTEGER) {\n      _nextId = 0;\n    }\n    return _nextId++;\n  };\n  var _timers = new Map();\n  var _SetTimeoutType = 0;\n  var _SetIntervalType = 1;\n  var _SetImmediateType = 2;\n  var _ClearTimeoutType = 3;\n  var _ClearIntervalType = 4;\n  var worker;\n  var _Timer = /*#__PURE__*/function () {\n    \"use strict\";\n\n    function _Timer() {\n      _classCallCheck(this, _Timer);\n    }\n    return _createClass(_Timer, null, [{\n      key: \"setTimeout\",\n      value: function setTimeout(cb, ms) {\n        var id = nextId();\n        _timers.set(id, cb);\n        worker.postMessage({\n          type: _SetTimeoutType,\n          id: id,\n          ms: ms\n        });\n        return id;\n      }\n    }, {\n      key: \"clearTimeout\",\n      value: function clearTimeout(id) {\n        _timers[\"delete\"](id);\n        worker.postMessage({\n          type: _ClearTimeoutType,\n          id: id\n        });\n      }\n    }, {\n      key: \"setInterval\",\n      value: function setInterval(cb, ms) {\n        var id = nextId();\n        _timers.set(id, cb);\n        worker.postMessage({\n          type: _SetIntervalType,\n          id: id,\n          ms: ms\n        });\n        return id;\n      }\n    }, {\n      key: \"clearInterval\",\n      value: function clearInterval(id) {\n        _timers[\"delete\"](id);\n        worker.postMessage({\n          type: _ClearIntervalType,\n          id: id\n        });\n      }\n    }, {\n      key: \"setImmediate\",\n      value: function setImmediate(cb) {\n        var id = nextId();\n        _timers.set(id, cb);\n        worker.postMessage({\n          type: _SetImmediateType,\n          id: id\n        });\n        return id;\n      }\n    }, {\n      key: \"onmessage\",\n      value: function onmessage(e) {\n        var cb = _timers.get(e.data.id);\n        if (cb !== undefined) {\n          cb.call();\n          if (e.data.type !== _SetIntervalType) {\n            _timers[\"delete\"](e.data.id);\n          }\n        }\n      }\n    }]);\n  }();\n  var workerCode = function workerCode() {\n    return \"(\" + function () {\n      //\n      // jshint worker: true\n      //\n      var _wSetTimeoutType = 0;\n      var _wSetIntervalType = 1;\n      var _wSetImmediateType = 2;\n      var _wClearTimeoutType = 3;\n      var _wClearIntervalType = 4;\n      var timers = {};\n      self.onmessage = function (e) {\n        if (e.data.type == _wSetTimeoutType) {\n          timers[e.data.id] = setTimeout(function () {\n            return self.postMessage(e.data);\n          }, e.data.ms);\n        } else if (e.data.type == _wSetIntervalType) {\n          timers[e.data.id] = setInterval(function () {\n            return self.postMessage(e.data);\n          }, e.data.ms);\n        } else if (e.data.type == _wSetImmediateType) {\n          self.postMessage(e.data);\n        } else if (e.data.type == _wClearTimeoutType) {\n          clearTimeout(timers[e.data.id]);\n          delete timers[e.data.id];\n        } else if (e.data.type == _wClearIntervalType) {\n          clearInterval(timers[e.data.id]);\n          delete timers[e.data.id];\n        }\n      };\n\n      //\n      // jshint worker: false\n      //\n    }.toString() + \"());\";\n  };\n  if (isIE()) {\n    //\n    // With IE always use the setInterval/setTimeout browser functions directly\n    //\n    Ice.Timer = createTimerObject();\n  } else if (isWorker()) {\n    //\n    // If we are running in a worker don't spawn a separate worker for the timer\n    //\n    Ice.Timer = createTimerObject();\n  } else if (worker === undefined) {\n    var url = URL.createObjectURL(new Blob([workerCode()], {\n      type: 'text/javascript'\n    }));\n    worker = new Worker(url);\n    worker.onmessage = _Timer.onmessage;\n    Ice.Timer = _Timer;\n  }\n}\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/TimerUtil.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/ToStringMode.js":
/*!**************************************************!*\
  !*** ./node_modules/ice/src/Ice/ToStringMode.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/EnumBase */ \"./node_modules/ice/src/Ice/EnumBase.js\").Ice);\nIce.ToStringMode = Ice.Slice.defineEnum([['Unicode', 0], ['ASCII', 1], ['Compat', 2]]);\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/ToStringMode.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/TraceLevels.js":
/*!*************************************************!*\
  !*** ./node_modules/ice/src/Ice/TraceLevels.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\nIce.TraceLevels = function (properties) {\n  var networkCat = \"Network\";\n  var protocolCat = \"Protocol\";\n  var retryCat = \"Retry\";\n  var locationCat = \"Locator\";\n  var slicingCat = \"Slicing\";\n  var keyBase = \"Ice.Trace.\";\n  var network = properties.getPropertyAsInt(keyBase + networkCat);\n  var protocol = properties.getPropertyAsInt(keyBase + protocolCat);\n  var retry = properties.getPropertyAsInt(keyBase + retryCat);\n  var location = properties.getPropertyAsInt(keyBase + locationCat);\n  var slicing = properties.getPropertyAsInt(keyBase + slicingCat);\n  properties.getPropertyAsInt(keyBase + \"ThreadPool\"); // Avoid an \"unused property\" warning.\n\n  return /*#__PURE__*/function () {\n    \"use strict\";\n\n    function _class() {\n      _classCallCheck(this, _class);\n    }\n    return _createClass(_class, null, [{\n      key: \"network\",\n      get: function get() {\n        return network;\n      }\n    }, {\n      key: \"networkCat\",\n      get: function get() {\n        return networkCat;\n      }\n    }, {\n      key: \"protocol\",\n      get: function get() {\n        return protocol;\n      }\n    }, {\n      key: \"protocolCat\",\n      get: function get() {\n        return protocolCat;\n      }\n    }, {\n      key: \"retry\",\n      get: function get() {\n        return retry;\n      }\n    }, {\n      key: \"retryCat\",\n      get: function get() {\n        return retryCat;\n      }\n    }, {\n      key: \"location\",\n      get: function get() {\n        return location;\n      }\n    }, {\n      key: \"locationCat\",\n      get: function get() {\n        return locationCat;\n      }\n    }, {\n      key: \"slicing\",\n      get: function get() {\n        return slicing;\n      }\n    }, {\n      key: \"slicingCat\",\n      get: function get() {\n        return slicingCat;\n      }\n    }]);\n  }();\n};\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/TraceLevels.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/TraceUtil.js":
/*!***********************************************!*\
  !*** ./node_modules/ice/src/Ice/TraceUtil.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n__webpack_require__(/*! ../Ice/Current */ \"./node_modules/ice/src/Ice/Current.js\");\n__webpack_require__(/*! ../Ice/Debug */ \"./node_modules/ice/src/Ice/Debug.js\");\n__webpack_require__(/*! ../Ice/Identity */ \"./node_modules/ice/src/Ice/Identity.js\");\n__webpack_require__(/*! ../Ice/Protocol */ \"./node_modules/ice/src/Ice/Protocol.js\");\n__webpack_require__(/*! ../Ice/StringUtil */ \"./node_modules/ice/src/Ice/StringUtil.js\");\n\n//\n// Local aliases.\n//\nvar Debug = Ice.Debug;\nvar Identity = Ice.Identity;\nvar OperationMode = Ice.OperationMode;\nvar Protocol = Ice.Protocol;\nvar StringUtil = Ice.StringUtil;\nvar slicingIds = new Map();\nfunction printIdentityFacetOperation(s, stream) {\n  var toStringMode = Ice.ToStringMode.Unicode;\n  if (stream.instance !== null) {\n    toStringMode = stream.instance.toStringMode();\n  }\n  var identity = new Identity();\n  identity._read(stream);\n  s.push(\"\\nidentity = \" + Ice.identityToString(identity, toStringMode));\n  var facet = Ice.StringSeqHelper.read(stream);\n  s.push(\"\\nfacet = \");\n  if (facet.length > 0) {\n    s.push(StringUtil.escapeString(facet[0], \"\", toStringMode));\n  }\n  var operation = stream.readString();\n  s.push(\"\\noperation = \" + operation);\n}\nfunction printRequest(s, stream) {\n  var requestId = stream.readInt();\n  s.push(\"\\nrequest id = \" + requestId);\n  if (requestId === 0) {\n    s.push(\" (oneway)\");\n  }\n  printRequestHeader(s, stream);\n}\nfunction printBatchRequest(s, stream) {\n  var batchRequestNum = stream.readInt();\n  s.push(\"\\nnumber of requests = \" + batchRequestNum);\n  for (var i = 0; i < batchRequestNum; ++i) {\n    s.push(\"\\nrequest #\" + i + ':');\n    printRequestHeader(s, stream);\n  }\n}\nfunction printReply(s, stream) {\n  var requestId = stream.readInt();\n  s.push(\"\\nrequest id = \" + requestId);\n  var replyStatus = stream.readByte();\n  s.push(\"\\nreply status = \" + replyStatus + ' ');\n  switch (replyStatus) {\n    case Protocol.replyOK:\n      {\n        s.push(\"(ok)\");\n        break;\n      }\n    case Protocol.replyUserException:\n      {\n        s.push(\"(user exception)\");\n        break;\n      }\n    case Protocol.replyObjectNotExist:\n    case Protocol.replyFacetNotExist:\n    case Protocol.replyOperationNotExist:\n      {\n        switch (replyStatus) {\n          case Protocol.replyObjectNotExist:\n            {\n              s.push(\"(object not exist)\");\n              break;\n            }\n          case Protocol.replyFacetNotExist:\n            {\n              s.push(\"(facet not exist)\");\n              break;\n            }\n          case Protocol.replyOperationNotExist:\n            {\n              s.push(\"(operation not exist)\");\n              break;\n            }\n          default:\n            {\n              Debug.assert(false);\n              break;\n            }\n        }\n        printIdentityFacetOperation(s, stream);\n        break;\n      }\n    case Protocol.replyUnknownException:\n    case Protocol.replyUnknownLocalException:\n    case Protocol.replyUnknownUserException:\n      {\n        switch (replyStatus) {\n          case Protocol.replyUnknownException:\n            {\n              s.push(\"(unknown exception)\");\n              break;\n            }\n          case Protocol.replyUnknownLocalException:\n            {\n              s.push(\"(unknown local exception)\");\n              break;\n            }\n          case Protocol.replyUnknownUserException:\n            {\n              s.push(\"(unknown user exception)\");\n              break;\n            }\n          default:\n            {\n              Debug.assert(false);\n              break;\n            }\n        }\n        var unknown = stream.readString();\n        s.push(\"\\nunknown = \" + unknown);\n        break;\n      }\n    default:\n      {\n        s.push(\"(unknown)\");\n        break;\n      }\n  }\n  if (replyStatus === Protocol.replyOK || replyStatus === Protocol.replyUserException) {\n    var ver = stream.skipEncapsulation();\n    if (!ver.equals(Ice.Encoding_1_0)) {\n      s.push(\"\\nencoding = \");\n      s.push(Ice.encodingVersionToString(ver));\n    }\n  }\n}\nfunction printRequestHeader(s, stream) {\n  printIdentityFacetOperation(s, stream);\n  var mode = stream.readByte();\n  s.push(\"\\nmode = \" + mode + ' ');\n  switch (OperationMode.valueOf(mode)) {\n    case OperationMode.Normal:\n      {\n        s.push(\"(normal)\");\n        break;\n      }\n    case OperationMode.Nonmutating:\n      {\n        s.push(\"(nonmutating)\");\n        break;\n      }\n    case OperationMode.Idempotent:\n      {\n        s.push(\"(idempotent)\");\n        break;\n      }\n    default:\n      {\n        s.push(\"(unknown)\");\n        break;\n      }\n  }\n  var sz = stream.readSize();\n  s.push(\"\\ncontext = \");\n  while (sz-- > 0) {\n    var key = stream.readString();\n    var value = stream.readString();\n    s.push(key + '/' + value);\n    if (sz > 0) {\n      s.push(\", \");\n    }\n  }\n  var ver = stream.skipEncapsulation();\n  if (!ver.equals(Ice.Encoding_1_0)) {\n    s.push(\"\\nencoding = \");\n    s.push(Ice.encodingVersionToString(ver));\n  }\n}\nfunction printHeader(s, stream) {\n  stream.readByte(); // Don't bother printing the magic number\n  stream.readByte();\n  stream.readByte();\n  stream.readByte();\n\n  //        const pMajor = stream.readByte();\n  //        const pMinor = stream.readByte();\n  //        s.push(\"\\nprotocol version = \" + pMajor + \".\" + pMinor);\n  stream.readByte(); // major\n  stream.readByte(); // minor\n\n  //        const eMajor = stream.readByte();\n  //        const eMinor = stream.readByte();\n  //        s.push(\"\\nencoding version = \" + eMajor + \".\" + eMinor);\n  stream.readByte(); // major\n  stream.readByte(); // minor\n\n  var type = stream.readByte();\n  s.push(\"\\nmessage type = \" + type + \" (\" + getMessageTypeAsString(type) + ')');\n  var compress = stream.readByte();\n  s.push(\"\\ncompression status = \" + compress + ' ');\n  switch (compress) {\n    case 0:\n      {\n        s.push(\"(not compressed; do not compress response, if any)\");\n        break;\n      }\n    case 1:\n      {\n        s.push(\"(not compressed; compress response, if any)\");\n        break;\n      }\n    case 2:\n      {\n        s.push(\"(compressed; compress response, if any)\");\n        break;\n      }\n    default:\n      {\n        s.push(\"(unknown)\");\n        break;\n      }\n  }\n  var size = stream.readInt();\n  s.push(\"\\nmessage size = \" + size);\n  return type;\n}\nfunction printMessage(s, stream) {\n  var type = printHeader(s, stream);\n  switch (type) {\n    case Protocol.closeConnectionMsg:\n    case Protocol.validateConnectionMsg:\n      {\n        // We're done.\n        break;\n      }\n    case Protocol.requestMsg:\n      {\n        printRequest(s, stream);\n        break;\n      }\n    case Protocol.requestBatchMsg:\n      {\n        printBatchRequest(s, stream);\n        break;\n      }\n    case Protocol.replyMsg:\n      {\n        printReply(s, stream);\n        break;\n      }\n    default:\n      {\n        break;\n      }\n  }\n  return type;\n}\nfunction getMessageTypeAsString(type) {\n  switch (type) {\n    case Protocol.requestMsg:\n      return \"request\";\n    case Protocol.requestBatchMsg:\n      return \"batch request\";\n    case Protocol.replyMsg:\n      return \"reply\";\n    case Protocol.closeConnectionMsg:\n      return \"close connection\";\n    case Protocol.validateConnectionMsg:\n      return \"validate connection\";\n    default:\n      return \"unknown\";\n  }\n}\nvar TraceUtil = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function TraceUtil() {\n    _classCallCheck(this, TraceUtil);\n  }\n  return _createClass(TraceUtil, null, [{\n    key: \"traceSlicing\",\n    value: function traceSlicing(kind, typeId, slicingCat, logger) {\n      if (!slicingIds.has(typeId)) {\n        logger.trace(slicingCat, \"unknown \".concat(kind, \" type `\").concat(typeId, \"'\"));\n        slicingIds.set(typeId, 1);\n      }\n    }\n  }, {\n    key: \"traceSend\",\n    value: function traceSend(stream, logger, traceLevels) {\n      if (traceLevels.protocol >= 1) {\n        var p = stream.pos;\n        var is = new Ice.InputStream(stream.instance, stream.getEncoding(), stream.buffer);\n        is.pos = 0;\n        var s = [];\n        var type = printMessage(s, is);\n        logger.trace(traceLevels.protocolCat, \"sending \" + getMessageTypeAsString(type) + \" \" + s.join(\"\"));\n        stream.pos = p;\n      }\n    }\n  }, {\n    key: \"traceRecv\",\n    value: function traceRecv(stream, logger, traceLevels) {\n      if (traceLevels.protocol >= 1) {\n        var p = stream.pos;\n        stream.pos = 0;\n        var s = [];\n        var type = printMessage(s, stream);\n        logger.trace(traceLevels.protocolCat, \"received \" + getMessageTypeAsString(type) + \" \" + s.join(\"\"));\n        stream.pos = p;\n      }\n    }\n  }, {\n    key: \"traceOut\",\n    value: function traceOut(heading, stream, logger, traceLevels) {\n      if (traceLevels.protocol >= 1) {\n        var p = stream.pos;\n        var is = new Ice.InputStream(stream.instance, stream.getEncoding(), stream.buffer);\n        is.pos = 0;\n        var s = [];\n        s.push(heading);\n        printMessage(s, is);\n        logger.trace(traceLevels.protocolCat, s.join(\"\"));\n        stream.pos = p;\n      }\n    }\n  }, {\n    key: \"traceIn\",\n    value: function traceIn(heading, stream, logger, traceLevels) {\n      if (traceLevels.protocol >= 1) {\n        var p = stream.pos;\n        stream.pos = 0;\n        var s = [];\n        s.push(heading);\n        printMessage(s, stream);\n        logger.trace(traceLevels.protocolCat, s.join(\"\"));\n        stream.pos = p;\n      }\n    }\n  }, {\n    key: \"dumpStream\",\n    value: function dumpStream(stream) {\n      var pos = stream.pos;\n      stream.pos = 0;\n      var data = stream.readBlob(stream.size());\n      TraceUtil.dumpOctets(data);\n      stream.pos = pos;\n    }\n  }, {\n    key: \"dumpOctets\",\n    value: function dumpOctets(data) {\n      var inc = 8;\n      var buf = [];\n      for (var i = 0; i < data.length; i += inc) {\n        for (var j = i; j - i < inc; j++) {\n          if (j < data.length) {\n            var n = data[j];\n            if (n < 0) {\n              n += 256;\n            }\n            var s = void 0;\n            if (n < 10) {\n              s = \"  \" + n;\n            } else if (n < 100) {\n              s = \" \" + n;\n            } else {\n              s = String(n);\n            }\n            buf.push(s + \" \");\n          } else {\n            buf.push(\"    \");\n          }\n        }\n        buf.push('\"');\n        for (var _j = i; _j < data.length && _j - i < inc; _j++) {\n          if (data[_j] >= 32 && data[_j] < 127) {\n            buf.push(String.fromCharCode(data[_j]));\n          } else {\n            buf.push('.');\n          }\n        }\n        buf.push(\"\\\"\\n\");\n      }\n      console.log(buf.join(\"\"));\n    }\n  }]);\n}();\nIce.TraceUtil = TraceUtil;\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/TraceUtil.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/UUID.js":
/*!******************************************!*\
  !*** ./node_modules/ice/src/Ice/UUID.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nfunction generateUUID() {\n  var d = new Date().getTime();\n  var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    var r = (d + Math.random() * 16) % 16 | 0;\n    d = Math.floor(d / 16);\n    return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);\n  });\n  return uuid;\n}\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\nIce.generateUUID = generateUUID;\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/UUID.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/UnknownSlicedValue.js":
/*!********************************************************!*\
  !*** ./node_modules/ice/src/Ice/UnknownSlicedValue.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\").Ice);\nvar SliceInfo = /*#__PURE__*/_createClass(function SliceInfo() {\n  \"use strict\";\n\n  _classCallCheck(this, SliceInfo);\n  //\n  // The Slice type ID for this slice.\n  //\n  this.typeId = \"\";\n\n  //\n  // The Slice compact type ID for this slice.\n  //\n  this.compactId = -1;\n\n  //\n  // The encoded bytes for this slice, including the leading size integer.\n  //\n  this.bytes = [];\n\n  //\n  // The class instances referenced by this slice.\n  //\n  this.instances = [];\n\n  //\n  // Whether or not the slice contains optional members.\n  //\n  this.hasOptionalMembers = false;\n\n  //\n  // Whether or not this is the last slice.\n  //\n  this.isLastSlice = false;\n});\nIce.SliceInfo = SliceInfo;\nvar SlicedData = /*#__PURE__*/_createClass(function SlicedData(slices) {\n  \"use strict\";\n\n  _classCallCheck(this, SlicedData);\n  this.slices = slices;\n});\nIce.SlicedData = SlicedData;\nvar UnknownSlicedValue = /*#__PURE__*/function (_Ice$Value) {\n  \"use strict\";\n\n  function UnknownSlicedValue(unknownTypeId) {\n    var _this;\n    _classCallCheck(this, UnknownSlicedValue);\n    _this = _callSuper(this, UnknownSlicedValue);\n    _this._unknownTypeId = unknownTypeId;\n    return _this;\n  }\n  _inherits(UnknownSlicedValue, _Ice$Value);\n  return _createClass(UnknownSlicedValue, [{\n    key: \"ice_getSlicedData\",\n    value: function ice_getSlicedData() {\n      return this._slicedData;\n    }\n  }, {\n    key: \"ice_id\",\n    value: function ice_id() {\n      return this._unknownTypeId;\n    }\n  }, {\n    key: \"_iceWrite\",\n    value: function _iceWrite(os) {\n      os.startValue(this._slicedData);\n      os.endValue();\n    }\n  }, {\n    key: \"_iceRead\",\n    value: function _iceRead(is) {\n      is.startValue();\n      this._slicedData = is.endValue(true);\n    }\n  }]);\n}(Ice.Value);\nIce.UnknownSlicedValue = UnknownSlicedValue;\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/UnknownSlicedValue.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Value.js":
/*!*******************************************!*\
  !*** ./node_modules/ice/src/Ice/Value.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\n//\n// Ice.Value\n//\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n__webpack_require__(/*! ../Ice/Exception */ \"./node_modules/ice/src/Ice/Exception.js\");\n__webpack_require__(/*! ../Ice/FormatType */ \"./node_modules/ice/src/Ice/FormatType.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\n__webpack_require__(/*! ../Ice/OptionalFormat */ \"./node_modules/ice/src/Ice/OptionalFormat.js\");\nIce.Value = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function _class() {\n    _classCallCheck(this, _class);\n  }\n  return _createClass(_class, [{\n    key: \"ice_preMarshal\",\n    value: function ice_preMarshal() {}\n  }, {\n    key: \"ice_postUnmarshal\",\n    value: function ice_postUnmarshal() {}\n  }, {\n    key: \"ice_getSlicedData\",\n    value: function ice_getSlicedData() {\n      return null;\n    }\n  }, {\n    key: \"_iceWrite\",\n    value: function _iceWrite(os) {\n      os.startValue(null);\n      _writeImpl(this, os, this._iceMostDerivedType());\n      os.endValue();\n    }\n  }, {\n    key: \"_iceRead\",\n    value: function _iceRead(is) {\n      is.startValue();\n      _readImpl(this, is, this._iceMostDerivedType());\n      is.endValue(false);\n    }\n\n    //\n    // These methods are used for object parameters.\n    //\n  }], [{\n    key: \"write\",\n    value: function write(os, v) {\n      os.writeValue(v);\n    }\n  }, {\n    key: \"writeOptional\",\n    value: function writeOptional(os, tag, v) {\n      os.writeOptionalValue(tag, v);\n    }\n  }, {\n    key: \"read\",\n    value: function read(is) {\n      var v = {\n        value: null\n      };\n      is.readValue(function (o) {\n        v.value = o;\n      }, this);\n      return v;\n    }\n  }, {\n    key: \"readOptional\",\n    value: function readOptional(is, tag) {\n      var v = {\n        value: undefined\n      };\n      is.readOptionalValue(tag, function (o) {\n        v.value = o;\n      }, this);\n      return v;\n    }\n  }]);\n}();\nIce.InterfaceByValue = /*#__PURE__*/function (_Ice$Value) {\n  \"use strict\";\n\n  function _class2(id) {\n    var _this;\n    _classCallCheck(this, _class2);\n    _this = _callSuper(this, _class2);\n    _this._id = id;\n    return _this;\n  }\n  _inherits(_class2, _Ice$Value);\n  return _createClass(_class2, [{\n    key: \"ice_id\",\n    value: function ice_id() {\n      return this._id;\n    }\n  }, {\n    key: \"_iceWrite\",\n    value: function _iceWrite(os) {\n      os.startValue(null);\n      os.startSlice(this.ice_id(), -1, true);\n      os.endSlice();\n      os.endValue();\n    }\n  }, {\n    key: \"_iceRead\",\n    value: function _iceRead(is) {\n      is.startValue();\n      is.startSlice();\n      is.endSlice();\n      is.endValue(false);\n    }\n  }]);\n}(Ice.Value);\n\n//\n// Private methods\n//\nvar _writeImpl = function writeImpl(obj, os, type) {\n  //\n  // The writeImpl method is a recursive method that goes down the\n  // class hierarchy to marshal each slice of the class using the\n  // generated _iceWriteMemberImpl method.\n  //\n\n  if (type === undefined || type === Ice.Value) {\n    return; // Don't marshal anything for Ice.Value\n  }\n  os.startSlice(type.ice_staticId(), Object.prototype.hasOwnProperty.call(type, '_iceCompactId') ? type._iceCompactId : -1, Object.getPrototypeOf(type) === Ice.Value);\n  if (type.prototype.hasOwnProperty('_iceWriteMemberImpl')) {\n    type.prototype._iceWriteMemberImpl.call(obj, os);\n  }\n  os.endSlice();\n  _writeImpl(obj, os, Object.getPrototypeOf(type));\n};\nvar _readImpl = function readImpl(obj, is, type) {\n  //\n  // The readImpl method is a recursive method that goes down the\n  // class hierarchy to unmarshal each slice of the class using the\n  // generated _iceReadMemberImpl method.\n  //\n\n  if (type === undefined || type === Ice.Value) {\n    return; // Don't unmarshal anything for Ice.Value\n  }\n  is.startSlice();\n  if (type.prototype.hasOwnProperty('_iceReadMemberImpl')) {\n    type.prototype._iceReadMemberImpl.call(obj, is);\n  }\n  is.endSlice();\n  _readImpl(obj, is, Object.getPrototypeOf(type));\n};\nfunction writePreserved(os) {\n  //\n  // For Slice classes which are marked \"preserved\", the implementation of this method\n  // replaces the Ice.Value.prototype._iceWrite method.\n  //\n  os.startValue(this._iceSlicedData);\n  _writeImpl(this, os, this._iceMostDerivedType());\n  os.endValue();\n}\nfunction readPreserved(is) {\n  //\n  // For Slice classes which are marked \"preserved\", the implementation of this method\n  // replaces the Ice.Value.prototype._iceRead method.\n  //\n  is.startValue();\n  _readImpl(this, is, this._iceMostDerivedType());\n  this._iceSlicedData = is.endValue(true);\n}\nfunction ice_getSlicedData() {\n  return this._iceSlicedData;\n}\nvar Slice = Ice.Slice;\nSlice.defineValue = function (valueType, id, preserved) {\n  var compactId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  valueType.prototype.ice_id = function () {\n    return id;\n  };\n  valueType.prototype._iceMostDerivedType = function () {\n    return valueType;\n  };\n  valueType.ice_staticId = function () {\n    return id;\n  };\n  if (preserved) {\n    valueType.prototype.ice_getSlicedData = ice_getSlicedData;\n    valueType.prototype._iceWrite = writePreserved;\n    valueType.prototype._iceRead = readPreserved;\n  }\n  if (compactId > 0) {\n    Ice.CompactIdRegistry.set(compactId, id);\n  }\n};\nSlice.defineValue(Ice.Value, \"::Ice::Object\");\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/Value.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/ValueFactory.js":
/*!**************************************************!*\
  !*** ./node_modules/ice/src/Ice/ValueFactory.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `ValueFactory.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nvar _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\");\n__webpack_require__(/*! ../Ice/ObjectPrx */ \"./node_modules/ice/src/Ice/ObjectPrx.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\nvar Ice = _ModuleRegistry.module(\"Ice\");\nvar Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n/* slice2js browser-bundle-skip */\nexports.Ice = Ice;\n/* slice2js browser-bundle-skip-end */\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/ValueFactory.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/ValueFactoryManagerI.js":
/*!**********************************************************!*\
  !*** ./node_modules/ice/src/Ice/ValueFactoryManagerI.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\").Ice);\nvar AlreadyRegisteredException = Ice.AlreadyRegisteredException;\n\n//\n// Only for use by Instance\n//\nvar ValueFactoryManagerI = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function ValueFactoryManagerI() {\n    _classCallCheck(this, ValueFactoryManagerI);\n    this._factoryMap = new Map(); // Map<String, ValueFactory>\n  }\n  return _createClass(ValueFactoryManagerI, [{\n    key: \"add\",\n    value: function add(factory, id) {\n      if (this._factoryMap.has(id)) {\n        throw new AlreadyRegisteredException(\"value factory\", id);\n      }\n      this._factoryMap.set(id, factory);\n    }\n  }, {\n    key: \"find\",\n    value: function find(id) {\n      return this._factoryMap.get(id);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this._factoryMap = new Map(); // Map<String, ValueFactory>\n    }\n  }]);\n}();\nIce.ValueFactoryManagerI = ValueFactoryManagerI;\nmodule.exports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/ValueFactoryManagerI.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Version.js":
/*!*********************************************!*\
  !*** ./node_modules/ice/src/Ice/Version.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `Version.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nvar _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Struct */ \"./node_modules/ice/src/Ice/Struct.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\nvar Ice = _ModuleRegistry.module(\"Ice\");\nvar Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n\n/**\n * A version structure for the protocol version.\n *\n **/\nIce.ProtocolVersion = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function _class() {\n    var major = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var minor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    _classCallCheck(this, _class);\n    this.major = major;\n    this.minor = minor;\n  }\n  return _createClass(_class, [{\n    key: \"_write\",\n    value: function _write(ostr) {\n      ostr.writeByte(this.major);\n      ostr.writeByte(this.minor);\n    }\n  }, {\n    key: \"_read\",\n    value: function _read(istr) {\n      this.major = istr.readByte();\n      this.minor = istr.readByte();\n    }\n  }], [{\n    key: \"minWireSize\",\n    get: function get() {\n      return 2;\n    }\n  }]);\n}();\nSlice.defineStruct(Ice.ProtocolVersion, true, false);\n\n/**\n * A version structure for the encoding version.\n *\n **/\nIce.EncodingVersion = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function _class2() {\n    var major = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var minor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    _classCallCheck(this, _class2);\n    this.major = major;\n    this.minor = minor;\n  }\n  return _createClass(_class2, [{\n    key: \"_write\",\n    value: function _write(ostr) {\n      ostr.writeByte(this.major);\n      ostr.writeByte(this.minor);\n    }\n  }, {\n    key: \"_read\",\n    value: function _read(istr) {\n      this.major = istr.readByte();\n      this.minor = istr.readByte();\n    }\n  }], [{\n    key: \"minWireSize\",\n    get: function get() {\n      return 2;\n    }\n  }]);\n}();\nSlice.defineStruct(Ice.EncodingVersion, true, false);\n/* slice2js browser-bundle-skip */\nexports.Ice = Ice;\n/* slice2js browser-bundle-skip-end */\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/Version.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/WSEndpoint.js":
/*!************************************************!*\
  !*** ./node_modules/ice/src/Ice/WSEndpoint.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n__webpack_require__(/*! ../Ice/EndpointI */ \"./node_modules/ice/src/Ice/EndpointI.js\");\n__webpack_require__(/*! ../Ice/EndpointInfo */ \"./node_modules/ice/src/Ice/EndpointInfo.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\");\n__webpack_require__(/*! ../Ice/WSTransceiver */ \"./node_modules/ice/src/Ice/WSTransceiver.js\");\nvar EndpointI = Ice.EndpointI;\nvar HashUtil = Ice.HashUtil;\nvar WSEndpoint = /*#__PURE__*/function (_EndpointI) {\n  \"use strict\";\n\n  function WSEndpoint(instance, del, re) {\n    var _this;\n    _classCallCheck(this, WSEndpoint);\n    _this = _callSuper(this, WSEndpoint);\n    _this._instance = instance;\n    _this._delegate = del;\n    _this._resource = re || \"/\";\n    return _this;\n  }\n  _inherits(WSEndpoint, _EndpointI);\n  return _createClass(WSEndpoint, [{\n    key: \"getInfo\",\n    value: function getInfo() {\n      var _this2 = this;\n      var info = new Ice.WSEndpointInfo();\n      info.type = function () {\n        return _this2.type();\n      };\n      info.datagram = function () {\n        return _this2.datagram();\n      };\n      info.secure = function () {\n        return _this2.secure();\n      };\n      info.resource = this._resource;\n      info.underlying = this._delegate.getInfo();\n      info.timeout = info.underlying.timeout;\n      info.compress = info.underlying.compress;\n      return info;\n    }\n  }, {\n    key: \"type\",\n    value: function type() {\n      return this._delegate.type();\n    }\n  }, {\n    key: \"protocol\",\n    value: function protocol() {\n      return this._delegate.protocol();\n    }\n  }, {\n    key: \"streamWrite\",\n    value: function streamWrite(s) {\n      s.startEncapsulation();\n      this._delegate.streamWriteImpl(s);\n      s.writeString(this._resource);\n      s.endEncapsulation();\n    }\n  }, {\n    key: \"timeout\",\n    value: function timeout() {\n      return this._delegate.timeout();\n    }\n  }, {\n    key: \"changeTimeout\",\n    value: function changeTimeout(timeout) {\n      if (timeout === this._delegate.timeout()) {\n        return this;\n      } else {\n        return new WSEndpoint(this._instance, this._delegate.changeTimeout(timeout), this._resource);\n      }\n    }\n  }, {\n    key: \"changeConnectionId\",\n    value: function changeConnectionId(connectionId) {\n      if (connectionId === this._delegate.connectionId()) {\n        return this;\n      } else {\n        return new WSEndpoint(this._instance, this._delegate.changeConnectionId(connectionId), this._resource);\n      }\n    }\n  }, {\n    key: \"compress\",\n    value: function compress() {\n      return this._delegate.compress();\n    }\n  }, {\n    key: \"changeCompress\",\n    value: function changeCompress(compress) {\n      if (compress === this._delegate.compress()) {\n        return this;\n      } else {\n        return new WSEndpoint(this._instance, this._delegate.changeCompress(compress), this._resource);\n      }\n    }\n  }, {\n    key: \"datagram\",\n    value: function datagram() {\n      return this._delegate.datagram();\n    }\n  }, {\n    key: \"secure\",\n    value: function secure() {\n      return this._delegate.secure();\n    }\n  }, {\n    key: \"connect\",\n    value: function connect() {\n      return Ice.WSTransceiver.createOutgoing(this._instance, this._delegate.secure(), this._delegate.getAddress(), this._resource);\n    }\n  }, {\n    key: \"hashCode\",\n    value: function hashCode() {\n      if (this._hashCode === undefined) {\n        this._hashCode = this._delegate.hashCode();\n        this._hashCode = HashUtil.addString(this._hashCode, this._resource);\n      }\n      return this._hashCode;\n    }\n  }, {\n    key: \"compareTo\",\n    value: function compareTo(p) {\n      if (this === p) {\n        return 0;\n      }\n      if (p === null) {\n        return 1;\n      }\n      if (!(p instanceof WSEndpoint)) {\n        return this.type() < p.type() ? -1 : 1;\n      }\n      var r = this._delegate.compareTo(p._delegate);\n      if (r !== 0) {\n        return r;\n      }\n      if (this._resource !== p._resource) {\n        return this._resource < p._resource ? -1 : 1;\n      }\n      return 0;\n    }\n  }, {\n    key: \"options\",\n    value: function options() {\n      //\n      // WARNING: Certain features, such as proxy validation in Glacier2,\n      // depend on the format of proxy strings. Changes to toString() and\n      // methods called to generate parts of the reference string could break\n      // these features. Please review for all features that depend on the\n      // format of proxyToString() before changing this and related code.\n      //\n      var s = this._delegate.options();\n      if (this._resource !== null && this._resource.length > 0) {\n        s += \" -r \";\n        s += this._resource.indexOf(':') !== -1 ? \"\\\"\" + this._resource + \"\\\"\" : this._resource;\n      }\n      return s;\n    }\n  }, {\n    key: \"toConnectorString\",\n    value: function toConnectorString() {\n      return this._delegate.toConnectorString();\n    }\n  }, {\n    key: \"initWithStream\",\n    value: function initWithStream(s) {\n      this._resource = s.readString();\n    }\n  }, {\n    key: \"checkOption\",\n    value: function checkOption(option, argument, endpoint) {\n      if (option === \"-r\") {\n        if (argument === null) {\n          throw new Ice.EndpointParseException(\"no argument provided for -r option in endpoint \" + endpoint);\n        }\n        this._resource = argument;\n      } else {\n        return false;\n      }\n      return true;\n    }\n  }, {\n    key: \"connectable\",\n    value: function connectable() {\n      return typeof WebSocket !== \"undefined\";\n    }\n  }]);\n}(EndpointI);\nIce.WSEndpoint = WSEndpoint;\nexports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/WSEndpoint.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/WSEndpointFactory.js":
/*!*******************************************************!*\
  !*** ./node_modules/ice/src/Ice/WSEndpointFactory.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/WSEndpoint */ \"./node_modules/ice/src/Ice/WSEndpoint.js\").Ice);\nvar WSEndpoint = Ice.WSEndpoint;\nvar WSEndpointFactory = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function WSEndpointFactory(instance, delegate) {\n    _classCallCheck(this, WSEndpointFactory);\n    this._instance = instance;\n    this._delegate = delegate;\n  }\n  return _createClass(WSEndpointFactory, [{\n    key: \"type\",\n    value: function type() {\n      return this._instance.type();\n    }\n  }, {\n    key: \"protocol\",\n    value: function protocol() {\n      return this._instance.protocol();\n    }\n  }, {\n    key: \"create\",\n    value: function create(args, oaEndpoint) {\n      var e = new WSEndpoint(this._instance, this._delegate.create(args, oaEndpoint));\n      e.initWithOptions(args);\n      return e;\n    }\n  }, {\n    key: \"read\",\n    value: function read(s) {\n      var e = new WSEndpoint(this._instance, this._delegate.read(s));\n      e.initWithStream(s);\n      return e;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this._delegate.destroy();\n      this._instance = null;\n    }\n  }]);\n}();\nIce.WSEndpointFactory = WSEndpointFactory;\nexports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/WSEndpointFactory.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/WSTransceiver.js":
/*!***************************************************!*\
  !*** ./node_modules/ice/src/Ice/WSTransceiver.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n__webpack_require__(/*! ../Ice/ConnectionInfo */ \"./node_modules/ice/src/Ice/ConnectionInfo.js\");\n__webpack_require__(/*! ../Ice/Debug */ \"./node_modules/ice/src/Ice/Debug.js\");\n__webpack_require__(/*! ../Ice/Exception */ \"./node_modules/ice/src/Ice/Exception.js\");\n__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\");\n__webpack_require__(/*! ../Ice/SocketOperation */ \"./node_modules/ice/src/Ice/SocketOperation.js\");\n__webpack_require__(/*! ../Ice/Timer */ \"./node_modules/ice/src/Ice/Timer.js\");\nvar IceSSL = Ice._ModuleRegistry.module(\"IceSSL\");\nvar _WSTransceiver = {};\nif (typeof WebSocket !== 'undefined') {\n  var fdToString = function fdToString(address) {\n    return \"local address = <not available>\\nremote address = \" + address.host + \":\" + address.port;\n  };\n  var translateError = function translateError(state, err) {\n    if (state < StateConnected) {\n      return new Ice.ConnectFailedException(err.code, err);\n    } else {\n      if (err.code === 1000 || err.code === 1006)\n        // CLOSE_NORMAL | CLOSE_ABNORMAL\n        {\n          return new Ice.ConnectionLostException();\n        }\n      return new Ice.SocketException(err.code, err);\n    }\n  };\n  //\n  // With Chrome we don't want to close the socket while connection is in progress,\n  // see comments on close implementation below.\n  //\n  // We need to check for Edge browser as it might include Chrome in its user agent.\n  //\n  var IsChrome = navigator.userAgent.indexOf(\"Edge/\") === -1 && navigator.userAgent.indexOf(\"Chrome/\") !== -1;\n  var IsSafari = /^((?!chrome).)*safari/i.test(navigator.userAgent);\n  var Debug = Ice.Debug;\n  var SocketOperation = Ice.SocketOperation;\n  var Timer = Ice.Timer;\n  var StateNeedConnect = 0;\n  var StateConnectPending = 1;\n  var StateConnected = 2;\n  var StateClosePending = 3;\n  var StateClosed = 4;\n  _WSTransceiver = /*#__PURE__*/function () {\n    \"use strict\";\n\n    function WSTransceiver(instance) {\n      _classCallCheck(this, WSTransceiver);\n      this._readBuffers = [];\n      this._readPosition = 0;\n      this._maxSendPacketSize = instance.properties().getPropertyAsIntWithDefault(\"Ice.TCP.SndSize\", 512 * 1024);\n      this._writeReadyTimeout = 0;\n    }\n    return _createClass(WSTransceiver, [{\n      key: \"writeReadyTimeout\",\n      value: function writeReadyTimeout() {\n        var t = Math.round(this._writeReadyTimeout);\n        this._writeReadyTimeout += this._writeReadyTimeout >= 5 ? 5 : 0.2;\n        return Math.min(t, 25);\n      }\n    }, {\n      key: \"setCallbacks\",\n      value: function setCallbacks(connectedCallback, bytesAvailableCallback, bytesWrittenCallback) {\n        this._connectedCallback = connectedCallback;\n        this._bytesAvailableCallback = bytesAvailableCallback;\n        this._bytesWrittenCallback = bytesWrittenCallback;\n      }\n\n      //\n      // Returns SocketOperation.None when initialization is complete.\n      //\n    }, {\n      key: \"initialize\",\n      value: function initialize(readBuffer, writeBuffer) {\n        var _this = this;\n        try {\n          if (this._exception) {\n            throw this._exception;\n          }\n          if (this._state === StateNeedConnect) {\n            this._state = StateConnectPending;\n            this._fd = new WebSocket(this._url, \"ice.zeroc.com\");\n            this._fd.binaryType = \"arraybuffer\";\n            this._fd.onopen = function (e) {\n              return _this.socketConnected(e);\n            };\n            this._fd.onmessage = function (e) {\n              return _this.socketBytesAvailable(e.data);\n            };\n            this._fd.onclose = function (e) {\n              return _this.socketClosed(e);\n            };\n            return SocketOperation.Connect; // Waiting for connect to complete.\n          } else if (this._state === StateConnectPending) {\n            //\n            // Socket is connected.\n            //\n            this._desc = fdToString(this._addr);\n            this._state = StateConnected;\n          }\n        } catch (err) {\n          if (!this._exception) {\n            this._exception = translateError(this._state, err);\n          }\n          throw this._exception;\n        }\n        Debug.assert(this._state === StateConnected);\n        return SocketOperation.None;\n      }\n    }, {\n      key: \"register\",\n      value: function register() {\n        var _this2 = this;\n        //\n        // Register the socket data listener.\n        //\n        this._registered = true;\n        if (this._hasBytesAvailable || this._exception) {\n          this._hasBytesAvailable = false;\n          Timer.setTimeout(function () {\n            return _this2._bytesAvailableCallback();\n          }, 0);\n        }\n      }\n    }, {\n      key: \"unregister\",\n      value: function unregister() {\n        //\n        // Unregister the socket data listener.\n        //\n        this._registered = false;\n      }\n    }, {\n      key: \"close\",\n      value: function close() {\n        if (this._fd === null) {\n          Debug.assert(this._exception); // Websocket creation failed.\n          return;\n        }\n\n        //\n        // With Chrome (in particular on macOS) calling close() while the websocket isn't\n        // connected yet doesn't abort the connection attempt, and might result in the\n        // connection being reused by a different web socket.\n        //\n        // To workaround this problem, we always wait for the socket to be connected or\n        // closed before closing the socket.\n        //\n        // NOTE: when this workaround is no longer necessary, don't forget removing the\n        // StateClosePending state.\n        //\n        if ((IsChrome || IsSafari) && this._fd.readyState === WebSocket.CONNECTING) {\n          this._state = StateClosePending;\n          return;\n        }\n        Debug.assert(this._fd !== null);\n        try {\n          this._state = StateClosed;\n          this._fd.close();\n        } catch (ex) {\n          throw translateError(this._state, ex);\n        } finally {\n          this._fd = null;\n        }\n      }\n\n      //\n      // Returns true if all of the data was flushed to the kernel buffer.\n      //\n    }, {\n      key: \"write\",\n      value: function write(byteBuffer) {\n        var _this3 = this;\n        if (this._exception) {\n          throw this._exception;\n        } else if (byteBuffer.remaining === 0) {\n          return true;\n        }\n        Debug.assert(this._fd);\n        var _cb = function cb() {\n          if (_this3._fd) {\n            var packetSize = _this3._maxSendPacketSize > 0 && byteBuffer.remaining > _this3._maxSendPacketSize ? _this3._maxSendPacketSize : byteBuffer.remaining;\n            if (_this3._fd.bufferedAmount + packetSize <= _this3._maxSendPacketSize) {\n              _this3._bytesWrittenCallback(0, 0);\n            } else {\n              Timer.setTimeout(_cb, _this3.writeReadyTimeout());\n            }\n          }\n        };\n        while (true) {\n          var packetSize = this._maxSendPacketSize > 0 && byteBuffer.remaining > this._maxSendPacketSize ? this._maxSendPacketSize : byteBuffer.remaining;\n          if (byteBuffer.remaining === 0) {\n            break;\n          }\n          Debug.assert(packetSize > 0);\n          if (this._fd.bufferedAmount + packetSize > this._maxSendPacketSize) {\n            Timer.setTimeout(_cb, this.writeReadyTimeout());\n            return false;\n          }\n          this._writeReadyTimeout = 0;\n          var slice = byteBuffer.b.slice(byteBuffer.position, byteBuffer.position + packetSize);\n          this._fd.send(slice);\n          byteBuffer.position += packetSize;\n\n          //\n          // TODO: WORKAROUND for Safari issue. The websocket accepts all the\n          // data (bufferedAmount is always 0). We relinquish the control here\n          // to ensure timeouts work properly.\n          //\n          if (IsSafari && byteBuffer.remaining > 0) {\n            Timer.setTimeout(_cb, this.writeReadyTimeout());\n            return false;\n          }\n        }\n        return true;\n      }\n    }, {\n      key: \"read\",\n      value: function read(byteBuffer, moreData) {\n        if (this._exception) {\n          throw this._exception;\n        }\n        moreData.value = false;\n        if (this._readBuffers.length === 0) {\n          return false; // No data available.\n        }\n        var avail = this._readBuffers[0].byteLength - this._readPosition;\n        Debug.assert(avail > 0);\n        while (byteBuffer.remaining > 0) {\n          if (avail > byteBuffer.remaining) {\n            avail = byteBuffer.remaining;\n          }\n          new Uint8Array(byteBuffer.b).set(new Uint8Array(this._readBuffers[0], this._readPosition, avail), byteBuffer.position);\n          byteBuffer.position += avail;\n          this._readPosition += avail;\n          if (this._readPosition === this._readBuffers[0].byteLength) {\n            //\n            // We've exhausted the current read buffer.\n            //\n            this._readPosition = 0;\n            this._readBuffers.shift();\n            if (this._readBuffers.length === 0) {\n              break; // No more data - we're done.\n            } else {\n              avail = this._readBuffers[0].byteLength;\n            }\n          }\n        }\n        moreData.value = this._readBuffers.length > 0;\n        return byteBuffer.remaining === 0;\n      }\n    }, {\n      key: \"type\",\n      value: function type() {\n        return this._secure ? \"wss\" : \"ws\";\n      }\n    }, {\n      key: \"getInfo\",\n      value: function getInfo() {\n        Debug.assert(this._fd !== null);\n        var info = new Ice.WSConnectionInfo();\n        var tcpinfo = new Ice.TCPConnectionInfo();\n        tcpinfo.localAddress = \"\";\n        tcpinfo.localPort = -1;\n        tcpinfo.remoteAddress = this._addr.host;\n        tcpinfo.remotePort = this._addr.port;\n        info.underlying = this._secure ? new IceSSL.ConnectionInfo(tcpinfo, tcpinfo.timeout, tcpinfo.compress) : tcpinfo;\n        info.rcvSize = -1;\n        info.sndSize = this._maxSendPacketSize;\n        info.headers = {};\n        return info;\n      }\n    }, {\n      key: \"checkSendSize\",\n      value: function checkSendSize(stream) {}\n    }, {\n      key: \"setBufferSize\",\n      value: function setBufferSize(rcvSize, sndSize) {\n        this._maxSendPacketSize = sndSize;\n      }\n    }, {\n      key: \"toString\",\n      value: function toString() {\n        return this._desc;\n      }\n    }, {\n      key: \"socketConnected\",\n      value: function socketConnected(e) {\n        if (this._state == StateClosePending) {\n          this.close();\n          return;\n        }\n        Debug.assert(this._connectedCallback !== null);\n        this._connectedCallback();\n      }\n    }, {\n      key: \"socketBytesAvailable\",\n      value: function socketBytesAvailable(buf) {\n        Debug.assert(this._bytesAvailableCallback !== null);\n        if (buf.byteLength > 0) {\n          this._readBuffers.push(buf);\n          if (this._registered) {\n            this._bytesAvailableCallback();\n          } else if (!this._hasBytesAvailable) {\n            this._hasBytesAvailable = true;\n          }\n        }\n      }\n    }, {\n      key: \"socketClosed\",\n      value: function socketClosed(err) {\n        if (this._state == StateClosePending) {\n          this.close();\n          return;\n        }\n        this._exception = translateError(this._state, err);\n        if (this._state < StateConnected) {\n          this._connectedCallback();\n        } else if (this._registered) {\n          this._bytesAvailableCallback();\n        }\n      }\n    }], [{\n      key: \"createOutgoing\",\n      value: function createOutgoing(instance, secure, addr, resource) {\n        var transceiver = new _WSTransceiver(instance);\n        var url = secure ? \"wss\" : \"ws\";\n        url += \"://\" + addr.host;\n        if (addr.port !== 80) {\n          url += \":\" + addr.port;\n        }\n        url += resource ? resource : \"/\";\n        transceiver._url = url;\n        transceiver._fd = null;\n        transceiver._addr = addr;\n        transceiver._desc = \"local address = <not available>\\nremote address = \" + addr.host + \":\" + addr.port;\n        transceiver._state = StateNeedConnect;\n        transceiver._secure = secure;\n        transceiver._exception = null;\n        return transceiver;\n      }\n    }]);\n  }();\n} else {\n  _WSTransceiver = /*#__PURE__*/_createClass(function _WSTransceiver() {\n    \"use strict\";\n\n    _classCallCheck(this, _WSTransceiver);\n  });\n}\nIce.WSTransceiver = _WSTransceiver;\nexports.Ice = Ice;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/Ice/WSTransceiver.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/IceGrid/Admin.js":
/*!***********************************************!*\
  !*** ./node_modules/ice/src/IceGrid/Admin.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `Admin.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nvar _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\nvar Glacier2 = (__webpack_require__(/*! ../Glacier2/Session */ \"./node_modules/ice/src/Glacier2/Session.js\").Glacier2);\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\");\n__webpack_require__(/*! ../Ice/ObjectPrx */ \"./node_modules/ice/src/Ice/ObjectPrx.js\");\n__webpack_require__(/*! ../Ice/Operation */ \"./node_modules/ice/src/Ice/Operation.js\");\n__webpack_require__(/*! ../Ice/Struct */ \"./node_modules/ice/src/Ice/Struct.js\");\n__webpack_require__(/*! ../Ice/EnumBase */ \"./node_modules/ice/src/Ice/EnumBase.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\n__webpack_require__(/*! ../Ice/Identity */ \"./node_modules/ice/src/Ice/Identity.js\");\n__webpack_require__(/*! ../Ice/BuiltinSequences */ \"./node_modules/ice/src/Ice/BuiltinSequences.js\");\n__webpack_require__(/*! ../Ice/Properties */ \"./node_modules/ice/src/Ice/Properties.js\");\n__webpack_require__(/*! ../Ice/SliceChecksumDict */ \"./node_modules/ice/src/Ice/SliceChecksumDict.js\");\nvar Ice = _ModuleRegistry.module(\"Ice\");\n__webpack_require__(/*! ../IceGrid/Exception */ \"./node_modules/ice/src/IceGrid/Exception.js\");\n__webpack_require__(/*! ../IceGrid/Descriptor */ \"./node_modules/ice/src/IceGrid/Descriptor.js\");\nvar IceGrid = _ModuleRegistry.module(\"IceGrid\");\nvar Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n\n/**\n * An enumeration representing the state of the server.\n *\n **/\nIceGrid.ServerState = Slice.defineEnum([['Inactive', 0], ['Activating', 1], ['ActivationTimedOut', 2], ['Active', 3], ['Deactivating', 4], ['Destroying', 5], ['Destroyed', 6]]);\nSlice.defineDictionary(IceGrid, \"StringObjectProxyDict\", \"StringObjectProxyDictHelper\", \"Ice.StringHelper\", \"Ice.ObjectPrx\", false, undefined, undefined);\n\n/**\n * Information about an Ice object.\n *\n **/\nIceGrid.ObjectInfo = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function _class() {\n    var proxy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class);\n    this.proxy = proxy;\n    this.type = type;\n  }\n  return _createClass(_class, [{\n    key: \"_write\",\n    value: function _write(ostr) {\n      ostr.writeProxy(this.proxy);\n      ostr.writeString(this.type);\n    }\n  }, {\n    key: \"_read\",\n    value: function _read(istr) {\n      this.proxy = istr.readProxy();\n      this.type = istr.readString();\n    }\n  }], [{\n    key: \"minWireSize\",\n    get: function get() {\n      return 3;\n    }\n  }]);\n}();\nSlice.defineStruct(IceGrid.ObjectInfo, false, true);\nSlice.defineSequence(IceGrid, \"ObjectInfoSeqHelper\", \"IceGrid.ObjectInfo\", false);\n\n/**\n * Information about an adapter registered with the IceGrid registry.\n *\n **/\nIceGrid.AdapterInfo = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function _class2() {\n    var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var proxy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var replicaGroupId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n    _classCallCheck(this, _class2);\n    this.id = id;\n    this.proxy = proxy;\n    this.replicaGroupId = replicaGroupId;\n  }\n  return _createClass(_class2, [{\n    key: \"_write\",\n    value: function _write(ostr) {\n      ostr.writeString(this.id);\n      ostr.writeProxy(this.proxy);\n      ostr.writeString(this.replicaGroupId);\n    }\n  }, {\n    key: \"_read\",\n    value: function _read(istr) {\n      this.id = istr.readString();\n      this.proxy = istr.readProxy();\n      this.replicaGroupId = istr.readString();\n    }\n  }], [{\n    key: \"minWireSize\",\n    get: function get() {\n      return 4;\n    }\n  }]);\n}();\nSlice.defineStruct(IceGrid.AdapterInfo, false, true);\nSlice.defineSequence(IceGrid, \"AdapterInfoSeqHelper\", \"IceGrid.AdapterInfo\", false);\n\n/**\n * Information about a server managed by an IceGrid node.\n *\n **/\nIceGrid.ServerInfo = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function _class3() {\n    var application = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var uuid = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    var revision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var node = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"\";\n    var descriptor = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    var sessionId = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : \"\";\n    _classCallCheck(this, _class3);\n    this.application = application;\n    this.uuid = uuid;\n    this.revision = revision;\n    this.node = node;\n    this.descriptor = descriptor;\n    this.sessionId = sessionId;\n  }\n  return _createClass(_class3, [{\n    key: \"_write\",\n    value: function _write(ostr) {\n      ostr.writeString(this.application);\n      ostr.writeString(this.uuid);\n      ostr.writeInt(this.revision);\n      ostr.writeString(this.node);\n      ostr.writeValue(this.descriptor);\n      ostr.writeString(this.sessionId);\n    }\n  }, {\n    key: \"_read\",\n    value: function _read(istr) {\n      var _this = this;\n      this.application = istr.readString();\n      this.uuid = istr.readString();\n      this.revision = istr.readInt();\n      this.node = istr.readString();\n      istr.readValue(function (obj) {\n        return _this.descriptor = obj;\n      }, IceGrid.ServerDescriptor);\n      this.sessionId = istr.readString();\n    }\n  }], [{\n    key: \"minWireSize\",\n    get: function get() {\n      return 9;\n    }\n  }]);\n}();\nSlice.defineStruct(IceGrid.ServerInfo, false, true);\n\n/**\n * Information about an IceGrid node.\n *\n **/\nIceGrid.NodeInfo = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function _class4() {\n    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var os = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    var hostname = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n    var release = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"\";\n    var version = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : \"\";\n    var machine = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : \"\";\n    var nProcessors = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n    var dataDir = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : \"\";\n    _classCallCheck(this, _class4);\n    this.name = name;\n    this.os = os;\n    this.hostname = hostname;\n    this.release = release;\n    this.version = version;\n    this.machine = machine;\n    this.nProcessors = nProcessors;\n    this.dataDir = dataDir;\n  }\n  return _createClass(_class4, [{\n    key: \"_write\",\n    value: function _write(ostr) {\n      ostr.writeString(this.name);\n      ostr.writeString(this.os);\n      ostr.writeString(this.hostname);\n      ostr.writeString(this.release);\n      ostr.writeString(this.version);\n      ostr.writeString(this.machine);\n      ostr.writeInt(this.nProcessors);\n      ostr.writeString(this.dataDir);\n    }\n  }, {\n    key: \"_read\",\n    value: function _read(istr) {\n      this.name = istr.readString();\n      this.os = istr.readString();\n      this.hostname = istr.readString();\n      this.release = istr.readString();\n      this.version = istr.readString();\n      this.machine = istr.readString();\n      this.nProcessors = istr.readInt();\n      this.dataDir = istr.readString();\n    }\n  }], [{\n    key: \"minWireSize\",\n    get: function get() {\n      return 11;\n    }\n  }]);\n}();\nSlice.defineStruct(IceGrid.NodeInfo, true, true);\n\n/**\n * Information about an IceGrid registry replica.\n *\n **/\nIceGrid.RegistryInfo = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function _class5() {\n    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var hostname = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class5);\n    this.name = name;\n    this.hostname = hostname;\n  }\n  return _createClass(_class5, [{\n    key: \"_write\",\n    value: function _write(ostr) {\n      ostr.writeString(this.name);\n      ostr.writeString(this.hostname);\n    }\n  }, {\n    key: \"_read\",\n    value: function _read(istr) {\n      this.name = istr.readString();\n      this.hostname = istr.readString();\n    }\n  }], [{\n    key: \"minWireSize\",\n    get: function get() {\n      return 2;\n    }\n  }]);\n}();\nSlice.defineStruct(IceGrid.RegistryInfo, true, true);\nSlice.defineSequence(IceGrid, \"RegistryInfoSeqHelper\", \"IceGrid.RegistryInfo\", false);\n\n/**\n * Information about the load of a node.\n *\n **/\nIceGrid.LoadInfo = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function _class6() {\n    var avg1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.0;\n    var avg5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.0;\n    var avg15 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.0;\n    _classCallCheck(this, _class6);\n    this.avg1 = avg1;\n    this.avg5 = avg5;\n    this.avg15 = avg15;\n  }\n  return _createClass(_class6, [{\n    key: \"_write\",\n    value: function _write(ostr) {\n      ostr.writeFloat(this.avg1);\n      ostr.writeFloat(this.avg5);\n      ostr.writeFloat(this.avg15);\n    }\n  }, {\n    key: \"_read\",\n    value: function _read(istr) {\n      this.avg1 = istr.readFloat();\n      this.avg5 = istr.readFloat();\n      this.avg15 = istr.readFloat();\n    }\n  }], [{\n    key: \"minWireSize\",\n    get: function get() {\n      return 12;\n    }\n  }]);\n}();\nSlice.defineStruct(IceGrid.LoadInfo, false, false);\n\n/**\n * Information about an IceGrid application.\n *\n **/\nIceGrid.ApplicationInfo = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function _class7() {\n    var uuid = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var createTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Ice.Long(0, 0);\n    var createUser = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n    var updateTime = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new Ice.Long(0, 0);\n    var updateUser = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : \"\";\n    var revision = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n    var descriptor = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : new IceGrid.ApplicationDescriptor();\n    _classCallCheck(this, _class7);\n    this.uuid = uuid;\n    this.createTime = createTime;\n    this.createUser = createUser;\n    this.updateTime = updateTime;\n    this.updateUser = updateUser;\n    this.revision = revision;\n    this.descriptor = descriptor;\n  }\n  return _createClass(_class7, [{\n    key: \"_write\",\n    value: function _write(ostr) {\n      ostr.writeString(this.uuid);\n      ostr.writeLong(this.createTime);\n      ostr.writeString(this.createUser);\n      ostr.writeLong(this.updateTime);\n      ostr.writeString(this.updateUser);\n      ostr.writeInt(this.revision);\n      IceGrid.ApplicationDescriptor.write(ostr, this.descriptor);\n    }\n  }, {\n    key: \"_read\",\n    value: function _read(istr) {\n      this.uuid = istr.readString();\n      this.createTime = istr.readLong();\n      this.createUser = istr.readString();\n      this.updateTime = istr.readLong();\n      this.updateUser = istr.readString();\n      this.revision = istr.readInt();\n      this.descriptor = IceGrid.ApplicationDescriptor.read(istr, this.descriptor);\n    }\n  }], [{\n    key: \"minWireSize\",\n    get: function get() {\n      return 33;\n    }\n  }]);\n}();\nSlice.defineStruct(IceGrid.ApplicationInfo, false, true);\nSlice.defineSequence(IceGrid, \"ApplicationInfoSeqHelper\", \"IceGrid.ApplicationInfo\", false);\n\n/**\n * Information about updates to an IceGrid application.\n *\n **/\nIceGrid.ApplicationUpdateInfo = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function _class8() {\n    var updateTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Ice.Long(0, 0);\n    var updateUser = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    var revision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var descriptor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new IceGrid.ApplicationUpdateDescriptor();\n    _classCallCheck(this, _class8);\n    this.updateTime = updateTime;\n    this.updateUser = updateUser;\n    this.revision = revision;\n    this.descriptor = descriptor;\n  }\n  return _createClass(_class8, [{\n    key: \"_write\",\n    value: function _write(ostr) {\n      ostr.writeLong(this.updateTime);\n      ostr.writeString(this.updateUser);\n      ostr.writeInt(this.revision);\n      IceGrid.ApplicationUpdateDescriptor.write(ostr, this.descriptor);\n    }\n  }, {\n    key: \"_read\",\n    value: function _read(istr) {\n      this.updateTime = istr.readLong();\n      this.updateUser = istr.readString();\n      this.revision = istr.readInt();\n      this.descriptor = IceGrid.ApplicationUpdateDescriptor.read(istr, this.descriptor);\n    }\n  }], [{\n    key: \"minWireSize\",\n    get: function get() {\n      return 28;\n    }\n  }]);\n}();\nSlice.defineStruct(IceGrid.ApplicationUpdateInfo, false, true);\nvar iceC_IceGrid_Admin_ids = [\"::Ice::Object\", \"::IceGrid::Admin\"];\n\n/**\n * The IceGrid administrative interface.\n * <p class=\"Warning\">Allowing access to this interface\n * is a security risk! Please see the IceGrid documentation\n * for further information.\n *\n **/\nIceGrid.Admin = /*#__PURE__*/function (_Ice$Object) {\n  \"use strict\";\n\n  function _class9() {\n    _classCallCheck(this, _class9);\n    return _callSuper(this, _class9, arguments);\n  }\n  _inherits(_class9, _Ice$Object);\n  return _createClass(_class9);\n}(Ice.Object);\nIceGrid.AdminPrx = /*#__PURE__*/function (_Ice$ObjectPrx) {\n  \"use strict\";\n\n  function _class0() {\n    _classCallCheck(this, _class0);\n    return _callSuper(this, _class0, arguments);\n  }\n  _inherits(_class0, _Ice$ObjectPrx);\n  return _createClass(_class0);\n}(Ice.ObjectPrx);\nSlice.defineOperations(IceGrid.Admin, IceGrid.AdminPrx, iceC_IceGrid_Admin_ids, 1, {\n  \"addApplication\": [,,,,, [[IceGrid.ApplicationDescriptor]],, [IceGrid.AccessDeniedException, IceGrid.DeploymentException], true],\n  \"syncApplication\": [,,,,, [[IceGrid.ApplicationDescriptor]],, [IceGrid.AccessDeniedException, IceGrid.ApplicationNotExistException, IceGrid.DeploymentException], true],\n  \"updateApplication\": [,,,,, [[IceGrid.ApplicationUpdateDescriptor]],, [IceGrid.AccessDeniedException, IceGrid.ApplicationNotExistException, IceGrid.DeploymentException], true],\n  \"syncApplicationWithoutRestart\": [,,,,, [[IceGrid.ApplicationDescriptor]],, [IceGrid.AccessDeniedException, IceGrid.ApplicationNotExistException, IceGrid.DeploymentException], true],\n  \"updateApplicationWithoutRestart\": [,,,,, [[IceGrid.ApplicationUpdateDescriptor]],, [IceGrid.AccessDeniedException, IceGrid.ApplicationNotExistException, IceGrid.DeploymentException], true],\n  \"removeApplication\": [,,,,, [[7]],, [IceGrid.AccessDeniedException, IceGrid.ApplicationNotExistException, IceGrid.DeploymentException],,],\n  \"instantiateServer\": [,,,,, [[7], [7], [IceGrid.ServerInstanceDescriptor]],, [IceGrid.AccessDeniedException, IceGrid.ApplicationNotExistException, IceGrid.DeploymentException],,],\n  \"patchApplication\": [,,,,, [[7], [1]],, [IceGrid.ApplicationNotExistException, IceGrid.PatchException],,],\n  \"getApplicationInfo\": [, 2, 1,, [IceGrid.ApplicationInfo], [[7]],, [IceGrid.ApplicationNotExistException],, true],\n  \"getDefaultApplicationDescriptor\": [, 2, 1,, [IceGrid.ApplicationDescriptor],,, [IceGrid.DeploymentException],, true],\n  \"getAllApplicationNames\": [, 2, 1,, [\"Ice.StringSeqHelper\"],,,,,],\n  \"getServerInfo\": [, 2, 1,, [IceGrid.ServerInfo], [[7]],, [IceGrid.ServerNotExistException],, true],\n  \"getServerState\": [, 2, 1,, [IceGrid.ServerState._helper], [[7]],, [IceGrid.DeploymentException, IceGrid.NodeUnreachableException, IceGrid.ServerNotExistException],,],\n  \"getServerPid\": [, 2, 1,, [3], [[7]],, [IceGrid.DeploymentException, IceGrid.NodeUnreachableException, IceGrid.ServerNotExistException],,],\n  \"getServerAdminCategory\": [, 2, 2,, [7],,,,,],\n  \"getServerAdmin\": [, 2, 2,, [9], [[7]],, [IceGrid.DeploymentException, IceGrid.NodeUnreachableException, IceGrid.ServerNotExistException],,],\n  \"enableServer\": [, 2, 2,,, [[7], [1]],, [IceGrid.DeploymentException, IceGrid.NodeUnreachableException, IceGrid.ServerNotExistException],,],\n  \"isServerEnabled\": [, 2, 1,, [1], [[7]],, [IceGrid.DeploymentException, IceGrid.NodeUnreachableException, IceGrid.ServerNotExistException],,],\n  \"startServer\": [,,,,, [[7]],, [IceGrid.DeploymentException, IceGrid.NodeUnreachableException, IceGrid.ServerNotExistException, IceGrid.ServerStartException],,],\n  \"stopServer\": [,,,,, [[7]],, [IceGrid.DeploymentException, IceGrid.NodeUnreachableException, IceGrid.ServerNotExistException, IceGrid.ServerStopException],,],\n  \"patchServer\": [,,,,, [[7], [1]],, [IceGrid.DeploymentException, IceGrid.NodeUnreachableException, IceGrid.PatchException, IceGrid.ServerNotExistException],,],\n  \"sendSignal\": [,,,,, [[7], [7]],, [IceGrid.BadSignalException, IceGrid.DeploymentException, IceGrid.NodeUnreachableException, IceGrid.ServerNotExistException],,],\n  \"getAllServerIds\": [, 2, 1,, [\"Ice.StringSeqHelper\"],,,,,],\n  \"getAdapterInfo\": [, 2, 1,, [\"IceGrid.AdapterInfoSeqHelper\"], [[7]],, [IceGrid.AdapterNotExistException],,],\n  \"removeAdapter\": [,,,,, [[7]],, [IceGrid.AdapterNotExistException, IceGrid.DeploymentException],,],\n  \"getAllAdapterIds\": [, 2, 1,, [\"Ice.StringSeqHelper\"],,,,,],\n  \"addObject\": [,,,,, [[9]],, [IceGrid.DeploymentException, IceGrid.ObjectExistsException],,],\n  \"updateObject\": [,,,,, [[9]],, [IceGrid.DeploymentException, IceGrid.ObjectNotRegisteredException],,],\n  \"addObjectWithType\": [,,,,, [[9], [7]],, [IceGrid.DeploymentException, IceGrid.ObjectExistsException],,],\n  \"removeObject\": [,,,,, [[Ice.Identity]],, [IceGrid.DeploymentException, IceGrid.ObjectNotRegisteredException],,],\n  \"getObjectInfo\": [, 2, 1,, [IceGrid.ObjectInfo], [[Ice.Identity]],, [IceGrid.ObjectNotRegisteredException],,],\n  \"getObjectInfosByType\": [, 2, 1,, [\"IceGrid.ObjectInfoSeqHelper\"], [[7]],,,,],\n  \"getAllObjectInfos\": [, 2, 1,, [\"IceGrid.ObjectInfoSeqHelper\"], [[7]],,,,],\n  \"pingNode\": [, 2, 1,, [1], [[7]],, [IceGrid.NodeNotExistException],,],\n  \"getNodeLoad\": [, 2, 1,, [IceGrid.LoadInfo], [[7]],, [IceGrid.NodeNotExistException, IceGrid.NodeUnreachableException],,],\n  \"getNodeInfo\": [, 2, 1,, [IceGrid.NodeInfo], [[7]],, [IceGrid.NodeNotExistException, IceGrid.NodeUnreachableException],,],\n  \"getNodeAdmin\": [, 2, 2,, [9], [[7]],, [IceGrid.NodeNotExistException, IceGrid.NodeUnreachableException],,],\n  \"getNodeProcessorSocketCount\": [, 2, 1,, [3], [[7]],, [IceGrid.NodeNotExistException, IceGrid.NodeUnreachableException],,],\n  \"shutdownNode\": [,,,,, [[7]],, [IceGrid.NodeNotExistException, IceGrid.NodeUnreachableException],,],\n  \"getNodeHostname\": [, 2, 1,, [7], [[7]],, [IceGrid.NodeNotExistException, IceGrid.NodeUnreachableException],,],\n  \"getAllNodeNames\": [, 2, 1,, [\"Ice.StringSeqHelper\"],,,,,],\n  \"pingRegistry\": [, 2, 2,, [1], [[7]],, [IceGrid.RegistryNotExistException],,],\n  \"getRegistryInfo\": [, 2, 2,, [IceGrid.RegistryInfo], [[7]],, [IceGrid.RegistryNotExistException, IceGrid.RegistryUnreachableException],,],\n  \"getRegistryAdmin\": [, 2, 2,, [9], [[7]],, [IceGrid.RegistryNotExistException],,],\n  \"shutdownRegistry\": [, 2, 2,,, [[7]],, [IceGrid.RegistryNotExistException, IceGrid.RegistryUnreachableException],,],\n  \"getAllRegistryNames\": [, 2, 2,, [\"Ice.StringSeqHelper\"],,,,,],\n  \"shutdown\": [,,,,,,,,,],\n  \"getSliceChecksums\": [, 2, 1,, [\"Ice.SliceChecksumDictHelper\"],,,,,]\n});\nvar iceC_IceGrid_FileIterator_ids = [\"::Ice::Object\", \"::IceGrid::FileIterator\"];\n\n/**\n * This interface provides access to IceGrid log file contents.\n *\n **/\nIceGrid.FileIterator = /*#__PURE__*/function (_Ice$Object2) {\n  \"use strict\";\n\n  function _class1() {\n    _classCallCheck(this, _class1);\n    return _callSuper(this, _class1, arguments);\n  }\n  _inherits(_class1, _Ice$Object2);\n  return _createClass(_class1);\n}(Ice.Object);\nIceGrid.FileIteratorPrx = /*#__PURE__*/function (_Ice$ObjectPrx2) {\n  \"use strict\";\n\n  function _class10() {\n    _classCallCheck(this, _class10);\n    return _callSuper(this, _class10, arguments);\n  }\n  _inherits(_class10, _Ice$ObjectPrx2);\n  return _createClass(_class10);\n}(Ice.ObjectPrx);\nSlice.defineOperations(IceGrid.FileIterator, IceGrid.FileIteratorPrx, iceC_IceGrid_FileIterator_ids, 1, {\n  \"read\": [,,,, [1], [[3]], [[\"Ice.StringSeqHelper\"]], [IceGrid.FileNotAvailableException],,],\n  \"destroy\": [,,,,,,,,,]\n});\n\n/**\n * Dynamic information about the state of a server.\n *\n **/\nIceGrid.ServerDynamicInfo = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function _class11() {\n    var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : IceGrid.ServerState.Inactive;\n    var pid = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var enabled = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    _classCallCheck(this, _class11);\n    this.id = id;\n    this.state = state;\n    this.pid = pid;\n    this.enabled = enabled;\n  }\n  return _createClass(_class11, [{\n    key: \"_write\",\n    value: function _write(ostr) {\n      ostr.writeString(this.id);\n      IceGrid.ServerState._write(ostr, this.state);\n      ostr.writeInt(this.pid);\n      ostr.writeBool(this.enabled);\n    }\n  }, {\n    key: \"_read\",\n    value: function _read(istr) {\n      this.id = istr.readString();\n      this.state = IceGrid.ServerState._read(istr);\n      this.pid = istr.readInt();\n      this.enabled = istr.readBool();\n    }\n  }], [{\n    key: \"minWireSize\",\n    get: function get() {\n      return 7;\n    }\n  }]);\n}();\nSlice.defineStruct(IceGrid.ServerDynamicInfo, true, true);\nSlice.defineSequence(IceGrid, \"ServerDynamicInfoSeqHelper\", \"IceGrid.ServerDynamicInfo\", false);\n\n/**\n * Dynamic information about the state of an adapter.\n *\n **/\nIceGrid.AdapterDynamicInfo = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function _class12() {\n    var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var proxy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    _classCallCheck(this, _class12);\n    this.id = id;\n    this.proxy = proxy;\n  }\n  return _createClass(_class12, [{\n    key: \"_write\",\n    value: function _write(ostr) {\n      ostr.writeString(this.id);\n      ostr.writeProxy(this.proxy);\n    }\n  }, {\n    key: \"_read\",\n    value: function _read(istr) {\n      this.id = istr.readString();\n      this.proxy = istr.readProxy();\n    }\n  }], [{\n    key: \"minWireSize\",\n    get: function get() {\n      return 3;\n    }\n  }]);\n}();\nSlice.defineStruct(IceGrid.AdapterDynamicInfo, false, true);\nSlice.defineSequence(IceGrid, \"AdapterDynamicInfoSeqHelper\", \"IceGrid.AdapterDynamicInfo\", false);\n\n/**\n * Dynamic information about the state of a node.\n *\n **/\nIceGrid.NodeDynamicInfo = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function _class13() {\n    var info = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new IceGrid.NodeInfo();\n    var servers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var adapters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    _classCallCheck(this, _class13);\n    this.info = info;\n    this.servers = servers;\n    this.adapters = adapters;\n  }\n  return _createClass(_class13, [{\n    key: \"_write\",\n    value: function _write(ostr) {\n      IceGrid.NodeInfo.write(ostr, this.info);\n      IceGrid.ServerDynamicInfoSeqHelper.write(ostr, this.servers);\n      IceGrid.AdapterDynamicInfoSeqHelper.write(ostr, this.adapters);\n    }\n  }, {\n    key: \"_read\",\n    value: function _read(istr) {\n      this.info = IceGrid.NodeInfo.read(istr, this.info);\n      this.servers = IceGrid.ServerDynamicInfoSeqHelper.read(istr);\n      this.adapters = IceGrid.AdapterDynamicInfoSeqHelper.read(istr);\n    }\n  }], [{\n    key: \"minWireSize\",\n    get: function get() {\n      return 13;\n    }\n  }]);\n}();\nSlice.defineStruct(IceGrid.NodeDynamicInfo, false, true);\nvar iceC_IceGrid_RegistryObserver_ids = [\"::Ice::Object\", \"::IceGrid::RegistryObserver\"];\n\n/**\n * This interface allows applications to monitor changes the state\n * of the registry.\n *\n **/\nIceGrid.RegistryObserver = /*#__PURE__*/function (_Ice$Object3) {\n  \"use strict\";\n\n  function _class14() {\n    _classCallCheck(this, _class14);\n    return _callSuper(this, _class14, arguments);\n  }\n  _inherits(_class14, _Ice$Object3);\n  return _createClass(_class14);\n}(Ice.Object);\nIceGrid.RegistryObserverPrx = /*#__PURE__*/function (_Ice$ObjectPrx3) {\n  \"use strict\";\n\n  function _class15() {\n    _classCallCheck(this, _class15);\n    return _callSuper(this, _class15, arguments);\n  }\n  _inherits(_class15, _Ice$ObjectPrx3);\n  return _createClass(_class15);\n}(Ice.ObjectPrx);\nSlice.defineOperations(IceGrid.RegistryObserver, IceGrid.RegistryObserverPrx, iceC_IceGrid_RegistryObserver_ids, 1, {\n  \"registryInit\": [,,,,, [[\"IceGrid.RegistryInfoSeqHelper\"]],,,,],\n  \"registryUp\": [,,,,, [[IceGrid.RegistryInfo]],,,,],\n  \"registryDown\": [,,,,, [[7]],,,,]\n});\nSlice.defineSequence(IceGrid, \"NodeDynamicInfoSeqHelper\", \"IceGrid.NodeDynamicInfo\", false);\nvar iceC_IceGrid_NodeObserver_ids = [\"::Ice::Object\", \"::IceGrid::NodeObserver\"];\n\n/**\n * The node observer interface. Observers should implement this\n * interface to receive information about the state of the IceGrid\n * nodes.\n *\n **/\nIceGrid.NodeObserver = /*#__PURE__*/function (_Ice$Object4) {\n  \"use strict\";\n\n  function _class16() {\n    _classCallCheck(this, _class16);\n    return _callSuper(this, _class16, arguments);\n  }\n  _inherits(_class16, _Ice$Object4);\n  return _createClass(_class16);\n}(Ice.Object);\nIceGrid.NodeObserverPrx = /*#__PURE__*/function (_Ice$ObjectPrx4) {\n  \"use strict\";\n\n  function _class17() {\n    _classCallCheck(this, _class17);\n    return _callSuper(this, _class17, arguments);\n  }\n  _inherits(_class17, _Ice$ObjectPrx4);\n  return _createClass(_class17);\n}(Ice.ObjectPrx);\nSlice.defineOperations(IceGrid.NodeObserver, IceGrid.NodeObserverPrx, iceC_IceGrid_NodeObserver_ids, 1, {\n  \"nodeInit\": [,,,,, [[\"IceGrid.NodeDynamicInfoSeqHelper\"]],,,,],\n  \"nodeUp\": [,,,,, [[IceGrid.NodeDynamicInfo]],,,,],\n  \"nodeDown\": [,,,,, [[7]],,,,],\n  \"updateServer\": [,,,,, [[7], [IceGrid.ServerDynamicInfo]],,,,],\n  \"updateAdapter\": [,,,,, [[7], [IceGrid.AdapterDynamicInfo]],,,,]\n});\nvar iceC_IceGrid_ApplicationObserver_ids = [\"::Ice::Object\", \"::IceGrid::ApplicationObserver\"];\n\n/**\n * The database observer interface. Observers should implement this\n * interface to receive information about the state of the IceGrid\n * registry database.\n *\n **/\nIceGrid.ApplicationObserver = /*#__PURE__*/function (_Ice$Object5) {\n  \"use strict\";\n\n  function _class18() {\n    _classCallCheck(this, _class18);\n    return _callSuper(this, _class18, arguments);\n  }\n  _inherits(_class18, _Ice$Object5);\n  return _createClass(_class18);\n}(Ice.Object);\nIceGrid.ApplicationObserverPrx = /*#__PURE__*/function (_Ice$ObjectPrx5) {\n  \"use strict\";\n\n  function _class19() {\n    _classCallCheck(this, _class19);\n    return _callSuper(this, _class19, arguments);\n  }\n  _inherits(_class19, _Ice$ObjectPrx5);\n  return _createClass(_class19);\n}(Ice.ObjectPrx);\nSlice.defineOperations(IceGrid.ApplicationObserver, IceGrid.ApplicationObserverPrx, iceC_IceGrid_ApplicationObserver_ids, 1, {\n  \"applicationInit\": [,,,,, [[3], [\"IceGrid.ApplicationInfoSeqHelper\"]],,, true],\n  \"applicationAdded\": [,,,,, [[3], [IceGrid.ApplicationInfo]],,, true],\n  \"applicationRemoved\": [,,,,, [[3], [7]],,,,],\n  \"applicationUpdated\": [,,,,, [[3], [IceGrid.ApplicationUpdateInfo]],,, true]\n});\nvar iceC_IceGrid_AdapterObserver_ids = [\"::Ice::Object\", \"::IceGrid::AdapterObserver\"];\n\n/**\n * This interface allows applications to monitor the state of object\n * adapters that are registered with IceGrid.\n *\n **/\nIceGrid.AdapterObserver = /*#__PURE__*/function (_Ice$Object6) {\n  \"use strict\";\n\n  function _class20() {\n    _classCallCheck(this, _class20);\n    return _callSuper(this, _class20, arguments);\n  }\n  _inherits(_class20, _Ice$Object6);\n  return _createClass(_class20);\n}(Ice.Object);\nIceGrid.AdapterObserverPrx = /*#__PURE__*/function (_Ice$ObjectPrx6) {\n  \"use strict\";\n\n  function _class21() {\n    _classCallCheck(this, _class21);\n    return _callSuper(this, _class21, arguments);\n  }\n  _inherits(_class21, _Ice$ObjectPrx6);\n  return _createClass(_class21);\n}(Ice.ObjectPrx);\nSlice.defineOperations(IceGrid.AdapterObserver, IceGrid.AdapterObserverPrx, iceC_IceGrid_AdapterObserver_ids, 1, {\n  \"adapterInit\": [,,,,, [[\"IceGrid.AdapterInfoSeqHelper\"]],,,,],\n  \"adapterAdded\": [,,,,, [[IceGrid.AdapterInfo]],,,,],\n  \"adapterUpdated\": [,,,,, [[IceGrid.AdapterInfo]],,,,],\n  \"adapterRemoved\": [,,,,, [[7]],,,,]\n});\nvar iceC_IceGrid_ObjectObserver_ids = [\"::Ice::Object\", \"::IceGrid::ObjectObserver\"];\n\n/**\n * This interface allows applications to monitor IceGrid well-known objects.\n *\n **/\nIceGrid.ObjectObserver = /*#__PURE__*/function (_Ice$Object7) {\n  \"use strict\";\n\n  function _class22() {\n    _classCallCheck(this, _class22);\n    return _callSuper(this, _class22, arguments);\n  }\n  _inherits(_class22, _Ice$Object7);\n  return _createClass(_class22);\n}(Ice.Object);\nIceGrid.ObjectObserverPrx = /*#__PURE__*/function (_Ice$ObjectPrx7) {\n  \"use strict\";\n\n  function _class23() {\n    _classCallCheck(this, _class23);\n    return _callSuper(this, _class23, arguments);\n  }\n  _inherits(_class23, _Ice$ObjectPrx7);\n  return _createClass(_class23);\n}(Ice.ObjectPrx);\nSlice.defineOperations(IceGrid.ObjectObserver, IceGrid.ObjectObserverPrx, iceC_IceGrid_ObjectObserver_ids, 1, {\n  \"objectInit\": [,,,,, [[\"IceGrid.ObjectInfoSeqHelper\"]],,,,],\n  \"objectAdded\": [,,,,, [[IceGrid.ObjectInfo]],,,,],\n  \"objectUpdated\": [,,,,, [[IceGrid.ObjectInfo]],,,,],\n  \"objectRemoved\": [,,,,, [[Ice.Identity]],,,,]\n});\nvar iceC_IceGrid_AdminSession_ids = [\"::Glacier2::Session\", \"::Ice::Object\", \"::IceGrid::AdminSession\"];\n\n/**\n * Used by administrative clients to view,\n * update, and receive observer updates from the IceGrid\n * registry. Admin sessions are created either via the {@link Registry}\n * object or via the registry admin <code>SessionManager</code> object.\n *\n * @see Registry\n *\n **/\nIceGrid.AdminSession = /*#__PURE__*/function (_Ice$Object8) {\n  \"use strict\";\n\n  function _class24() {\n    _classCallCheck(this, _class24);\n    return _callSuper(this, _class24, arguments);\n  }\n  _inherits(_class24, _Ice$Object8);\n  return _createClass(_class24, null, [{\n    key: \"_iceImplements\",\n    get: function get() {\n      return [Glacier2.Session];\n    }\n  }]);\n}(Ice.Object);\nIceGrid.AdminSessionPrx = /*#__PURE__*/function (_Ice$ObjectPrx8) {\n  \"use strict\";\n\n  function _class25() {\n    _classCallCheck(this, _class25);\n    return _callSuper(this, _class25, arguments);\n  }\n  _inherits(_class25, _Ice$ObjectPrx8);\n  return _createClass(_class25, null, [{\n    key: \"_implements\",\n    get: function get() {\n      return [Glacier2.SessionPrx];\n    }\n  }]);\n}(Ice.ObjectPrx);\nSlice.defineOperations(IceGrid.AdminSession, IceGrid.AdminSessionPrx, iceC_IceGrid_AdminSession_ids, 2, {\n  \"keepAlive\": [, 2, 2,,,,,,,],\n  \"getAdmin\": [, 2, 1,, [\"IceGrid.AdminPrx\"],,,,,],\n  \"getAdminCallbackTemplate\": [, 2, 2,, [9],,,,,],\n  \"setObservers\": [, 2, 2,,, [[\"IceGrid.RegistryObserverPrx\"], [\"IceGrid.NodeObserverPrx\"], [\"IceGrid.ApplicationObserverPrx\"], [\"IceGrid.AdapterObserverPrx\"], [\"IceGrid.ObjectObserverPrx\"]],, [IceGrid.ObserverAlreadyRegisteredException],,],\n  \"setObserversByIdentity\": [, 2, 2,,, [[Ice.Identity], [Ice.Identity], [Ice.Identity], [Ice.Identity], [Ice.Identity]],, [IceGrid.ObserverAlreadyRegisteredException],,],\n  \"startUpdate\": [,,,, [3],,, [IceGrid.AccessDeniedException],,],\n  \"finishUpdate\": [,,,,,,, [IceGrid.AccessDeniedException],,],\n  \"getReplicaName\": [, 2, 2,, [7],,,,,],\n  \"openServerLog\": [,,,, [\"IceGrid.FileIteratorPrx\"], [[7], [7], [3]],, [IceGrid.DeploymentException, IceGrid.FileNotAvailableException, IceGrid.NodeUnreachableException, IceGrid.ServerNotExistException],,],\n  \"openServerStdErr\": [,,,, [\"IceGrid.FileIteratorPrx\"], [[7], [3]],, [IceGrid.DeploymentException, IceGrid.FileNotAvailableException, IceGrid.NodeUnreachableException, IceGrid.ServerNotExistException],,],\n  \"openServerStdOut\": [,,,, [\"IceGrid.FileIteratorPrx\"], [[7], [3]],, [IceGrid.DeploymentException, IceGrid.FileNotAvailableException, IceGrid.NodeUnreachableException, IceGrid.ServerNotExistException],,],\n  \"openNodeStdErr\": [,,,, [\"IceGrid.FileIteratorPrx\"], [[7], [3]],, [IceGrid.FileNotAvailableException, IceGrid.NodeNotExistException, IceGrid.NodeUnreachableException],,],\n  \"openNodeStdOut\": [,,,, [\"IceGrid.FileIteratorPrx\"], [[7], [3]],, [IceGrid.FileNotAvailableException, IceGrid.NodeNotExistException, IceGrid.NodeUnreachableException],,],\n  \"openRegistryStdErr\": [,,,, [\"IceGrid.FileIteratorPrx\"], [[7], [3]],, [IceGrid.FileNotAvailableException, IceGrid.RegistryNotExistException, IceGrid.RegistryUnreachableException],,],\n  \"openRegistryStdOut\": [,,,, [\"IceGrid.FileIteratorPrx\"], [[7], [3]],, [IceGrid.FileNotAvailableException, IceGrid.RegistryNotExistException, IceGrid.RegistryUnreachableException],,]\n});\n/* slice2js browser-bundle-skip */\nexports.IceGrid = IceGrid;\n/* slice2js browser-bundle-skip-end */\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/IceGrid/Admin.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/IceGrid/Descriptor.js":
/*!****************************************************!*\
  !*** ./node_modules/ice/src/IceGrid/Descriptor.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `Descriptor.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nvar _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\");\n__webpack_require__(/*! ../Ice/ObjectPrx */ \"./node_modules/ice/src/Ice/ObjectPrx.js\");\n__webpack_require__(/*! ../Ice/Struct */ \"./node_modules/ice/src/Ice/Struct.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\n__webpack_require__(/*! ../Ice/Identity */ \"./node_modules/ice/src/Ice/Identity.js\");\n__webpack_require__(/*! ../Ice/BuiltinSequences */ \"./node_modules/ice/src/Ice/BuiltinSequences.js\");\nvar Ice = _ModuleRegistry.module(\"Ice\");\nvar Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n/* slice2js browser-bundle-skip */\n\nvar IceGrid = _ModuleRegistry.module(\"IceGrid\");\n/* slice2js browser-bundle-skip-end */\n\nSlice.defineDictionary(IceGrid, \"StringStringDict\", \"StringStringDictHelper\", \"Ice.StringHelper\", \"Ice.StringHelper\", false, undefined, undefined);\n\n/**\n * Property descriptor.\n *\n **/\nIceGrid.PropertyDescriptor = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function _class() {\n    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class);\n    this.name = name;\n    this.value = value;\n  }\n  return _createClass(_class, [{\n    key: \"_write\",\n    value: function _write(ostr) {\n      ostr.writeString(this.name);\n      ostr.writeString(this.value);\n    }\n  }, {\n    key: \"_read\",\n    value: function _read(istr) {\n      this.name = istr.readString();\n      this.value = istr.readString();\n    }\n  }], [{\n    key: \"minWireSize\",\n    get: function get() {\n      return 2;\n    }\n  }]);\n}();\nSlice.defineStruct(IceGrid.PropertyDescriptor, true, true);\nSlice.defineSequence(IceGrid, \"PropertyDescriptorSeqHelper\", \"IceGrid.PropertyDescriptor\", false);\n\n/**\n * A property set descriptor.\n *\n **/\nIceGrid.PropertySetDescriptor = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function _class2() {\n    var references = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var properties = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    _classCallCheck(this, _class2);\n    this.references = references;\n    this.properties = properties;\n  }\n  return _createClass(_class2, [{\n    key: \"_write\",\n    value: function _write(ostr) {\n      Ice.StringSeqHelper.write(ostr, this.references);\n      IceGrid.PropertyDescriptorSeqHelper.write(ostr, this.properties);\n    }\n  }, {\n    key: \"_read\",\n    value: function _read(istr) {\n      this.references = Ice.StringSeqHelper.read(istr);\n      this.properties = IceGrid.PropertyDescriptorSeqHelper.read(istr);\n    }\n  }], [{\n    key: \"minWireSize\",\n    get: function get() {\n      return 2;\n    }\n  }]);\n}();\nSlice.defineStruct(IceGrid.PropertySetDescriptor, true, true);\nSlice.defineDictionary(IceGrid, \"PropertySetDescriptorDict\", \"PropertySetDescriptorDictHelper\", \"Ice.StringHelper\", \"IceGrid.PropertySetDescriptor\", false, undefined, undefined);\n\n/**\n * An Ice object descriptor.\n *\n **/\nIceGrid.ObjectDescriptor = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function _class3() {\n    var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Ice.Identity();\n    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    var proxyOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n    _classCallCheck(this, _class3);\n    this.id = id;\n    this.type = type;\n    this.proxyOptions = proxyOptions;\n  }\n  return _createClass(_class3, [{\n    key: \"_write\",\n    value: function _write(ostr) {\n      Ice.Identity.write(ostr, this.id);\n      ostr.writeString(this.type);\n      ostr.writeString(this.proxyOptions);\n    }\n  }, {\n    key: \"_read\",\n    value: function _read(istr) {\n      this.id = Ice.Identity.read(istr, this.id);\n      this.type = istr.readString();\n      this.proxyOptions = istr.readString();\n    }\n  }], [{\n    key: \"minWireSize\",\n    get: function get() {\n      return 4;\n    }\n  }]);\n}();\nSlice.defineStruct(IceGrid.ObjectDescriptor, true, true);\nSlice.defineSequence(IceGrid, \"ObjectDescriptorSeqHelper\", \"IceGrid.ObjectDescriptor\", false);\n\n/**\n * An Ice object adapter descriptor.\n *\n **/\nIceGrid.AdapterDescriptor = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function _class4() {\n    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var description = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    var id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n    var replicaGroupId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"\";\n    var priority = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : \"\";\n    var registerProcess = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n    var serverLifetime = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n    var objects = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;\n    var allocatables = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : null;\n    _classCallCheck(this, _class4);\n    this.name = name;\n    this.description = description;\n    this.id = id;\n    this.replicaGroupId = replicaGroupId;\n    this.priority = priority;\n    this.registerProcess = registerProcess;\n    this.serverLifetime = serverLifetime;\n    this.objects = objects;\n    this.allocatables = allocatables;\n  }\n  return _createClass(_class4, [{\n    key: \"_write\",\n    value: function _write(ostr) {\n      ostr.writeString(this.name);\n      ostr.writeString(this.description);\n      ostr.writeString(this.id);\n      ostr.writeString(this.replicaGroupId);\n      ostr.writeString(this.priority);\n      ostr.writeBool(this.registerProcess);\n      ostr.writeBool(this.serverLifetime);\n      IceGrid.ObjectDescriptorSeqHelper.write(ostr, this.objects);\n      IceGrid.ObjectDescriptorSeqHelper.write(ostr, this.allocatables);\n    }\n  }, {\n    key: \"_read\",\n    value: function _read(istr) {\n      this.name = istr.readString();\n      this.description = istr.readString();\n      this.id = istr.readString();\n      this.replicaGroupId = istr.readString();\n      this.priority = istr.readString();\n      this.registerProcess = istr.readBool();\n      this.serverLifetime = istr.readBool();\n      this.objects = IceGrid.ObjectDescriptorSeqHelper.read(istr);\n      this.allocatables = IceGrid.ObjectDescriptorSeqHelper.read(istr);\n    }\n  }], [{\n    key: \"minWireSize\",\n    get: function get() {\n      return 9;\n    }\n  }]);\n}();\nSlice.defineStruct(IceGrid.AdapterDescriptor, true, true);\nSlice.defineSequence(IceGrid, \"AdapterDescriptorSeqHelper\", \"IceGrid.AdapterDescriptor\", false);\n\n/**\n * A Freeze database environment descriptor.\n *\n **/\nIceGrid.DbEnvDescriptor = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function _class5() {\n    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var description = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    var dbHome = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n    var properties = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    _classCallCheck(this, _class5);\n    this.name = name;\n    this.description = description;\n    this.dbHome = dbHome;\n    this.properties = properties;\n  }\n  return _createClass(_class5, [{\n    key: \"_write\",\n    value: function _write(ostr) {\n      ostr.writeString(this.name);\n      ostr.writeString(this.description);\n      ostr.writeString(this.dbHome);\n      IceGrid.PropertyDescriptorSeqHelper.write(ostr, this.properties);\n    }\n  }, {\n    key: \"_read\",\n    value: function _read(istr) {\n      this.name = istr.readString();\n      this.description = istr.readString();\n      this.dbHome = istr.readString();\n      this.properties = IceGrid.PropertyDescriptorSeqHelper.read(istr);\n    }\n  }], [{\n    key: \"minWireSize\",\n    get: function get() {\n      return 4;\n    }\n  }]);\n}();\nSlice.defineStruct(IceGrid.DbEnvDescriptor, true, true);\nSlice.defineSequence(IceGrid, \"DbEnvDescriptorSeqHelper\", \"IceGrid.DbEnvDescriptor\", false);\nvar iceC_IceGrid_CommunicatorDescriptor_ids = [\"::Ice::Object\", \"::IceGrid::CommunicatorDescriptor\"];\n\n/**\n * A communicator descriptor.\n *\n **/\nIceGrid.CommunicatorDescriptor = /*#__PURE__*/function (_Ice$Value) {\n  \"use strict\";\n\n  function _class6() {\n    var _this;\n    var adapters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var propertySet = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new IceGrid.PropertySetDescriptor();\n    var dbEnvs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    var logs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    var description = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : \"\";\n    _classCallCheck(this, _class6);\n    _this = _callSuper(this, _class6);\n    _this.adapters = adapters;\n    _this.propertySet = propertySet;\n    _this.dbEnvs = dbEnvs;\n    _this.logs = logs;\n    _this.description = description;\n    return _this;\n  }\n  _inherits(_class6, _Ice$Value);\n  return _createClass(_class6, [{\n    key: \"_iceWriteMemberImpl\",\n    value: function _iceWriteMemberImpl(ostr) {\n      IceGrid.AdapterDescriptorSeqHelper.write(ostr, this.adapters);\n      IceGrid.PropertySetDescriptor.write(ostr, this.propertySet);\n      IceGrid.DbEnvDescriptorSeqHelper.write(ostr, this.dbEnvs);\n      Ice.StringSeqHelper.write(ostr, this.logs);\n      ostr.writeString(this.description);\n    }\n  }, {\n    key: \"_iceReadMemberImpl\",\n    value: function _iceReadMemberImpl(istr) {\n      this.adapters = IceGrid.AdapterDescriptorSeqHelper.read(istr);\n      this.propertySet = IceGrid.PropertySetDescriptor.read(istr, this.propertySet);\n      this.dbEnvs = IceGrid.DbEnvDescriptorSeqHelper.read(istr);\n      this.logs = Ice.StringSeqHelper.read(istr);\n      this.description = istr.readString();\n    }\n  }]);\n}(Ice.Value);\nSlice.defineValue(IceGrid.CommunicatorDescriptor, iceC_IceGrid_CommunicatorDescriptor_ids[1], false);\n\n/**\n * A distribution descriptor defines an IcePatch2 server and the\n * directories to retrieve from the patch server.\n *\n **/\nIceGrid.DistributionDescriptor = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function _class7() {\n    var icepatch = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var directories = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    _classCallCheck(this, _class7);\n    this.icepatch = icepatch;\n    this.directories = directories;\n  }\n  return _createClass(_class7, [{\n    key: \"_write\",\n    value: function _write(ostr) {\n      ostr.writeString(this.icepatch);\n      Ice.StringSeqHelper.write(ostr, this.directories);\n    }\n  }, {\n    key: \"_read\",\n    value: function _read(istr) {\n      this.icepatch = istr.readString();\n      this.directories = Ice.StringSeqHelper.read(istr);\n    }\n  }], [{\n    key: \"minWireSize\",\n    get: function get() {\n      return 2;\n    }\n  }]);\n}();\nSlice.defineStruct(IceGrid.DistributionDescriptor, true, true);\nvar iceC_IceGrid_ServerDescriptor_ids = [\"::Ice::Object\", \"::IceGrid::CommunicatorDescriptor\", \"::IceGrid::ServerDescriptor\"];\n\n/**\n * An Ice server descriptor.\n *\n **/\nIceGrid.ServerDescriptor = /*#__PURE__*/function (_IceGrid$Communicator) {\n  \"use strict\";\n\n  function _class8(adapters, propertySet, dbEnvs, logs, description) {\n    var _this2;\n    var id = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : \"\";\n    var exe = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : \"\";\n    var iceVersion = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : \"\";\n    var pwd = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : \"\";\n    var options = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : null;\n    var envs = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : null;\n    var activation = arguments.length > 11 && arguments[11] !== undefined ? arguments[11] : \"\";\n    var activationTimeout = arguments.length > 12 && arguments[12] !== undefined ? arguments[12] : \"\";\n    var deactivationTimeout = arguments.length > 13 && arguments[13] !== undefined ? arguments[13] : \"\";\n    var applicationDistrib = arguments.length > 14 && arguments[14] !== undefined ? arguments[14] : false;\n    var distrib = arguments.length > 15 && arguments[15] !== undefined ? arguments[15] : new IceGrid.DistributionDescriptor();\n    var allocatable = arguments.length > 16 && arguments[16] !== undefined ? arguments[16] : false;\n    var user = arguments.length > 17 && arguments[17] !== undefined ? arguments[17] : \"\";\n    _classCallCheck(this, _class8);\n    _this2 = _callSuper(this, _class8, [adapters, propertySet, dbEnvs, logs, description]);\n    _this2.id = id;\n    _this2.exe = exe;\n    _this2.iceVersion = iceVersion;\n    _this2.pwd = pwd;\n    _this2.options = options;\n    _this2.envs = envs;\n    _this2.activation = activation;\n    _this2.activationTimeout = activationTimeout;\n    _this2.deactivationTimeout = deactivationTimeout;\n    _this2.applicationDistrib = applicationDistrib;\n    _this2.distrib = distrib;\n    _this2.allocatable = allocatable;\n    _this2.user = user;\n    return _this2;\n  }\n  _inherits(_class8, _IceGrid$Communicator);\n  return _createClass(_class8, [{\n    key: \"_iceWriteMemberImpl\",\n    value: function _iceWriteMemberImpl(ostr) {\n      ostr.writeString(this.id);\n      ostr.writeString(this.exe);\n      ostr.writeString(this.iceVersion);\n      ostr.writeString(this.pwd);\n      Ice.StringSeqHelper.write(ostr, this.options);\n      Ice.StringSeqHelper.write(ostr, this.envs);\n      ostr.writeString(this.activation);\n      ostr.writeString(this.activationTimeout);\n      ostr.writeString(this.deactivationTimeout);\n      ostr.writeBool(this.applicationDistrib);\n      IceGrid.DistributionDescriptor.write(ostr, this.distrib);\n      ostr.writeBool(this.allocatable);\n      ostr.writeString(this.user);\n    }\n  }, {\n    key: \"_iceReadMemberImpl\",\n    value: function _iceReadMemberImpl(istr) {\n      this.id = istr.readString();\n      this.exe = istr.readString();\n      this.iceVersion = istr.readString();\n      this.pwd = istr.readString();\n      this.options = Ice.StringSeqHelper.read(istr);\n      this.envs = Ice.StringSeqHelper.read(istr);\n      this.activation = istr.readString();\n      this.activationTimeout = istr.readString();\n      this.deactivationTimeout = istr.readString();\n      this.applicationDistrib = istr.readBool();\n      this.distrib = IceGrid.DistributionDescriptor.read(istr, this.distrib);\n      this.allocatable = istr.readBool();\n      this.user = istr.readString();\n    }\n  }]);\n}(IceGrid.CommunicatorDescriptor);\nSlice.defineValue(IceGrid.ServerDescriptor, iceC_IceGrid_ServerDescriptor_ids[2], false);\nSlice.defineSequence(IceGrid, \"ServerDescriptorSeqHelper\", \"Ice.ObjectHelper\", false, \"IceGrid.ServerDescriptor\");\nvar iceC_IceGrid_ServiceDescriptor_ids = [\"::Ice::Object\", \"::IceGrid::CommunicatorDescriptor\", \"::IceGrid::ServiceDescriptor\"];\n\n/**\n * An IceBox service descriptor.\n *\n **/\nIceGrid.ServiceDescriptor = /*#__PURE__*/function (_IceGrid$Communicator2) {\n  \"use strict\";\n\n  function _class9(adapters, propertySet, dbEnvs, logs, description) {\n    var _this3;\n    var name = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : \"\";\n    var entry = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : \"\";\n    _classCallCheck(this, _class9);\n    _this3 = _callSuper(this, _class9, [adapters, propertySet, dbEnvs, logs, description]);\n    _this3.name = name;\n    _this3.entry = entry;\n    return _this3;\n  }\n  _inherits(_class9, _IceGrid$Communicator2);\n  return _createClass(_class9, [{\n    key: \"_iceWriteMemberImpl\",\n    value: function _iceWriteMemberImpl(ostr) {\n      ostr.writeString(this.name);\n      ostr.writeString(this.entry);\n    }\n  }, {\n    key: \"_iceReadMemberImpl\",\n    value: function _iceReadMemberImpl(istr) {\n      this.name = istr.readString();\n      this.entry = istr.readString();\n    }\n  }]);\n}(IceGrid.CommunicatorDescriptor);\nSlice.defineValue(IceGrid.ServiceDescriptor, iceC_IceGrid_ServiceDescriptor_ids[2], false);\nSlice.defineSequence(IceGrid, \"ServiceDescriptorSeqHelper\", \"Ice.ObjectHelper\", false, \"IceGrid.ServiceDescriptor\");\n\n/**\n * A server template instance descriptor.\n *\n **/\nIceGrid.ServerInstanceDescriptor = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function _class0() {\n    var template = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var parameterValues = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var propertySet = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new IceGrid.PropertySetDescriptor();\n    var servicePropertySets = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    _classCallCheck(this, _class0);\n    this.template = template;\n    this.parameterValues = parameterValues;\n    this.propertySet = propertySet;\n    this.servicePropertySets = servicePropertySets;\n  }\n  return _createClass(_class0, [{\n    key: \"_write\",\n    value: function _write(ostr) {\n      ostr.writeString(this.template);\n      IceGrid.StringStringDictHelper.write(ostr, this.parameterValues);\n      IceGrid.PropertySetDescriptor.write(ostr, this.propertySet);\n      IceGrid.PropertySetDescriptorDictHelper.write(ostr, this.servicePropertySets);\n    }\n  }, {\n    key: \"_read\",\n    value: function _read(istr) {\n      this.template = istr.readString();\n      this.parameterValues = IceGrid.StringStringDictHelper.read(istr);\n      this.propertySet = IceGrid.PropertySetDescriptor.read(istr, this.propertySet);\n      this.servicePropertySets = IceGrid.PropertySetDescriptorDictHelper.read(istr);\n    }\n  }], [{\n    key: \"minWireSize\",\n    get: function get() {\n      return 5;\n    }\n  }]);\n}();\nSlice.defineStruct(IceGrid.ServerInstanceDescriptor, false, true);\nSlice.defineSequence(IceGrid, \"ServerInstanceDescriptorSeqHelper\", \"IceGrid.ServerInstanceDescriptor\", false);\n\n/**\n * A template descriptor for server or service templates.\n *\n **/\nIceGrid.TemplateDescriptor = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function _class1() {\n    var descriptor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var parameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var parameterDefaults = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    _classCallCheck(this, _class1);\n    this.descriptor = descriptor;\n    this.parameters = parameters;\n    this.parameterDefaults = parameterDefaults;\n  }\n  return _createClass(_class1, [{\n    key: \"_write\",\n    value: function _write(ostr) {\n      ostr.writeValue(this.descriptor);\n      Ice.StringSeqHelper.write(ostr, this.parameters);\n      IceGrid.StringStringDictHelper.write(ostr, this.parameterDefaults);\n    }\n  }, {\n    key: \"_read\",\n    value: function _read(istr) {\n      var _this4 = this;\n      istr.readValue(function (obj) {\n        return _this4.descriptor = obj;\n      }, IceGrid.CommunicatorDescriptor);\n      this.parameters = Ice.StringSeqHelper.read(istr);\n      this.parameterDefaults = IceGrid.StringStringDictHelper.read(istr);\n    }\n  }], [{\n    key: \"minWireSize\",\n    get: function get() {\n      return 3;\n    }\n  }]);\n}();\nSlice.defineStruct(IceGrid.TemplateDescriptor, false, true);\nSlice.defineDictionary(IceGrid, \"TemplateDescriptorDict\", \"TemplateDescriptorDictHelper\", \"Ice.StringHelper\", \"IceGrid.TemplateDescriptor\", false, undefined, undefined);\n\n/**\n * A service template instance descriptor.\n *\n **/\nIceGrid.ServiceInstanceDescriptor = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function _class10() {\n    var template = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var parameterValues = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var descriptor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    var propertySet = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new IceGrid.PropertySetDescriptor();\n    _classCallCheck(this, _class10);\n    this.template = template;\n    this.parameterValues = parameterValues;\n    this.descriptor = descriptor;\n    this.propertySet = propertySet;\n  }\n  return _createClass(_class10, [{\n    key: \"_write\",\n    value: function _write(ostr) {\n      ostr.writeString(this.template);\n      IceGrid.StringStringDictHelper.write(ostr, this.parameterValues);\n      ostr.writeValue(this.descriptor);\n      IceGrid.PropertySetDescriptor.write(ostr, this.propertySet);\n    }\n  }, {\n    key: \"_read\",\n    value: function _read(istr) {\n      var _this5 = this;\n      this.template = istr.readString();\n      this.parameterValues = IceGrid.StringStringDictHelper.read(istr);\n      istr.readValue(function (obj) {\n        return _this5.descriptor = obj;\n      }, IceGrid.ServiceDescriptor);\n      this.propertySet = IceGrid.PropertySetDescriptor.read(istr, this.propertySet);\n    }\n  }], [{\n    key: \"minWireSize\",\n    get: function get() {\n      return 5;\n    }\n  }]);\n}();\nSlice.defineStruct(IceGrid.ServiceInstanceDescriptor, false, true);\nSlice.defineSequence(IceGrid, \"ServiceInstanceDescriptorSeqHelper\", \"IceGrid.ServiceInstanceDescriptor\", false);\nvar iceC_IceGrid_IceBoxDescriptor_ids = [\"::Ice::Object\", \"::IceGrid::CommunicatorDescriptor\", \"::IceGrid::IceBoxDescriptor\", \"::IceGrid::ServerDescriptor\"];\n\n/**\n * An IceBox server descriptor.\n *\n **/\nIceGrid.IceBoxDescriptor = /*#__PURE__*/function (_IceGrid$ServerDescri) {\n  \"use strict\";\n\n  function _class11(adapters, propertySet, dbEnvs, logs, description, id, exe, iceVersion, pwd, options, envs, activation, activationTimeout, deactivationTimeout, applicationDistrib, distrib, allocatable, user) {\n    var _this6;\n    var services = arguments.length > 18 && arguments[18] !== undefined ? arguments[18] : null;\n    _classCallCheck(this, _class11);\n    _this6 = _callSuper(this, _class11, [adapters, propertySet, dbEnvs, logs, description, id, exe, iceVersion, pwd, options, envs, activation, activationTimeout, deactivationTimeout, applicationDistrib, distrib, allocatable, user]);\n    _this6.services = services;\n    return _this6;\n  }\n  _inherits(_class11, _IceGrid$ServerDescri);\n  return _createClass(_class11, [{\n    key: \"_iceWriteMemberImpl\",\n    value: function _iceWriteMemberImpl(ostr) {\n      IceGrid.ServiceInstanceDescriptorSeqHelper.write(ostr, this.services);\n    }\n  }, {\n    key: \"_iceReadMemberImpl\",\n    value: function _iceReadMemberImpl(istr) {\n      this.services = IceGrid.ServiceInstanceDescriptorSeqHelper.read(istr);\n    }\n  }]);\n}(IceGrid.ServerDescriptor);\nSlice.defineValue(IceGrid.IceBoxDescriptor, iceC_IceGrid_IceBoxDescriptor_ids[2], false);\n\n/**\n * A node descriptor.\n *\n **/\nIceGrid.NodeDescriptor = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function _class12() {\n    var variables = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var serverInstances = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var servers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    var loadFactor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"\";\n    var description = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : \"\";\n    var propertySets = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n    _classCallCheck(this, _class12);\n    this.variables = variables;\n    this.serverInstances = serverInstances;\n    this.servers = servers;\n    this.loadFactor = loadFactor;\n    this.description = description;\n    this.propertySets = propertySets;\n  }\n  return _createClass(_class12, [{\n    key: \"_write\",\n    value: function _write(ostr) {\n      IceGrid.StringStringDictHelper.write(ostr, this.variables);\n      IceGrid.ServerInstanceDescriptorSeqHelper.write(ostr, this.serverInstances);\n      IceGrid.ServerDescriptorSeqHelper.write(ostr, this.servers);\n      ostr.writeString(this.loadFactor);\n      ostr.writeString(this.description);\n      IceGrid.PropertySetDescriptorDictHelper.write(ostr, this.propertySets);\n    }\n  }, {\n    key: \"_read\",\n    value: function _read(istr) {\n      this.variables = IceGrid.StringStringDictHelper.read(istr);\n      this.serverInstances = IceGrid.ServerInstanceDescriptorSeqHelper.read(istr);\n      this.servers = IceGrid.ServerDescriptorSeqHelper.read(istr);\n      this.loadFactor = istr.readString();\n      this.description = istr.readString();\n      this.propertySets = IceGrid.PropertySetDescriptorDictHelper.read(istr);\n    }\n  }], [{\n    key: \"minWireSize\",\n    get: function get() {\n      return 6;\n    }\n  }]);\n}();\nSlice.defineStruct(IceGrid.NodeDescriptor, false, true);\nSlice.defineDictionary(IceGrid, \"NodeDescriptorDict\", \"NodeDescriptorDictHelper\", \"Ice.StringHelper\", \"IceGrid.NodeDescriptor\", false, undefined, undefined);\nvar iceC_IceGrid_LoadBalancingPolicy_ids = [\"::Ice::Object\", \"::IceGrid::LoadBalancingPolicy\"];\n\n/**\n * A base class for load balancing policies.\n *\n **/\nIceGrid.LoadBalancingPolicy = /*#__PURE__*/function (_Ice$Value2) {\n  \"use strict\";\n\n  function _class13() {\n    var _this7;\n    var nReplicas = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    _classCallCheck(this, _class13);\n    _this7 = _callSuper(this, _class13);\n    _this7.nReplicas = nReplicas;\n    return _this7;\n  }\n  _inherits(_class13, _Ice$Value2);\n  return _createClass(_class13, [{\n    key: \"_iceWriteMemberImpl\",\n    value: function _iceWriteMemberImpl(ostr) {\n      ostr.writeString(this.nReplicas);\n    }\n  }, {\n    key: \"_iceReadMemberImpl\",\n    value: function _iceReadMemberImpl(istr) {\n      this.nReplicas = istr.readString();\n    }\n  }]);\n}(Ice.Value);\nSlice.defineValue(IceGrid.LoadBalancingPolicy, iceC_IceGrid_LoadBalancingPolicy_ids[1], false);\nvar iceC_IceGrid_RandomLoadBalancingPolicy_ids = [\"::Ice::Object\", \"::IceGrid::LoadBalancingPolicy\", \"::IceGrid::RandomLoadBalancingPolicy\"];\n\n/**\n * Random load balancing policy.\n *\n **/\nIceGrid.RandomLoadBalancingPolicy = /*#__PURE__*/function (_IceGrid$LoadBalancin) {\n  \"use strict\";\n\n  function _class14(nReplicas) {\n    _classCallCheck(this, _class14);\n    return _callSuper(this, _class14, [nReplicas]);\n  }\n  _inherits(_class14, _IceGrid$LoadBalancin);\n  return _createClass(_class14);\n}(IceGrid.LoadBalancingPolicy);\nSlice.defineValue(IceGrid.RandomLoadBalancingPolicy, iceC_IceGrid_RandomLoadBalancingPolicy_ids[2], false);\nvar iceC_IceGrid_OrderedLoadBalancingPolicy_ids = [\"::Ice::Object\", \"::IceGrid::LoadBalancingPolicy\", \"::IceGrid::OrderedLoadBalancingPolicy\"];\n\n/**\n * Ordered load balancing policy.\n *\n **/\nIceGrid.OrderedLoadBalancingPolicy = /*#__PURE__*/function (_IceGrid$LoadBalancin2) {\n  \"use strict\";\n\n  function _class15(nReplicas) {\n    _classCallCheck(this, _class15);\n    return _callSuper(this, _class15, [nReplicas]);\n  }\n  _inherits(_class15, _IceGrid$LoadBalancin2);\n  return _createClass(_class15);\n}(IceGrid.LoadBalancingPolicy);\nSlice.defineValue(IceGrid.OrderedLoadBalancingPolicy, iceC_IceGrid_OrderedLoadBalancingPolicy_ids[2], false);\nvar iceC_IceGrid_RoundRobinLoadBalancingPolicy_ids = [\"::Ice::Object\", \"::IceGrid::LoadBalancingPolicy\", \"::IceGrid::RoundRobinLoadBalancingPolicy\"];\n\n/**\n * Round robin load balancing policy.\n *\n **/\nIceGrid.RoundRobinLoadBalancingPolicy = /*#__PURE__*/function (_IceGrid$LoadBalancin3) {\n  \"use strict\";\n\n  function _class16(nReplicas) {\n    _classCallCheck(this, _class16);\n    return _callSuper(this, _class16, [nReplicas]);\n  }\n  _inherits(_class16, _IceGrid$LoadBalancin3);\n  return _createClass(_class16);\n}(IceGrid.LoadBalancingPolicy);\nSlice.defineValue(IceGrid.RoundRobinLoadBalancingPolicy, iceC_IceGrid_RoundRobinLoadBalancingPolicy_ids[2], false);\nvar iceC_IceGrid_AdaptiveLoadBalancingPolicy_ids = [\"::Ice::Object\", \"::IceGrid::AdaptiveLoadBalancingPolicy\", \"::IceGrid::LoadBalancingPolicy\"];\n\n/**\n * Adaptive load balancing policy.\n *\n **/\nIceGrid.AdaptiveLoadBalancingPolicy = /*#__PURE__*/function (_IceGrid$LoadBalancin4) {\n  \"use strict\";\n\n  function _class17(nReplicas) {\n    var _this8;\n    var loadSample = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class17);\n    _this8 = _callSuper(this, _class17, [nReplicas]);\n    _this8.loadSample = loadSample;\n    return _this8;\n  }\n  _inherits(_class17, _IceGrid$LoadBalancin4);\n  return _createClass(_class17, [{\n    key: \"_iceWriteMemberImpl\",\n    value: function _iceWriteMemberImpl(ostr) {\n      ostr.writeString(this.loadSample);\n    }\n  }, {\n    key: \"_iceReadMemberImpl\",\n    value: function _iceReadMemberImpl(istr) {\n      this.loadSample = istr.readString();\n    }\n  }]);\n}(IceGrid.LoadBalancingPolicy);\nSlice.defineValue(IceGrid.AdaptiveLoadBalancingPolicy, iceC_IceGrid_AdaptiveLoadBalancingPolicy_ids[1], false);\n\n/**\n * A replica group descriptor.\n *\n **/\nIceGrid.ReplicaGroupDescriptor = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function _class18() {\n    var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var loadBalancing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var proxyOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n    var objects = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    var description = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : \"\";\n    var filter = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : \"\";\n    _classCallCheck(this, _class18);\n    this.id = id;\n    this.loadBalancing = loadBalancing;\n    this.proxyOptions = proxyOptions;\n    this.objects = objects;\n    this.description = description;\n    this.filter = filter;\n  }\n  return _createClass(_class18, [{\n    key: \"_write\",\n    value: function _write(ostr) {\n      ostr.writeString(this.id);\n      ostr.writeValue(this.loadBalancing);\n      ostr.writeString(this.proxyOptions);\n      IceGrid.ObjectDescriptorSeqHelper.write(ostr, this.objects);\n      ostr.writeString(this.description);\n      ostr.writeString(this.filter);\n    }\n  }, {\n    key: \"_read\",\n    value: function _read(istr) {\n      var _this9 = this;\n      this.id = istr.readString();\n      istr.readValue(function (obj) {\n        return _this9.loadBalancing = obj;\n      }, IceGrid.LoadBalancingPolicy);\n      this.proxyOptions = istr.readString();\n      this.objects = IceGrid.ObjectDescriptorSeqHelper.read(istr);\n      this.description = istr.readString();\n      this.filter = istr.readString();\n    }\n  }], [{\n    key: \"minWireSize\",\n    get: function get() {\n      return 6;\n    }\n  }]);\n}();\nSlice.defineStruct(IceGrid.ReplicaGroupDescriptor, false, true);\nSlice.defineSequence(IceGrid, \"ReplicaGroupDescriptorSeqHelper\", \"IceGrid.ReplicaGroupDescriptor\", false);\n\n/**\n * An application descriptor.\n *\n **/\nIceGrid.ApplicationDescriptor = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function _class19() {\n    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var variables = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var replicaGroups = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    var serverTemplates = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    var serviceTemplates = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    var nodes = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n    var distrib = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : new IceGrid.DistributionDescriptor();\n    var description = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : \"\";\n    var propertySets = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : null;\n    _classCallCheck(this, _class19);\n    this.name = name;\n    this.variables = variables;\n    this.replicaGroups = replicaGroups;\n    this.serverTemplates = serverTemplates;\n    this.serviceTemplates = serviceTemplates;\n    this.nodes = nodes;\n    this.distrib = distrib;\n    this.description = description;\n    this.propertySets = propertySets;\n  }\n  return _createClass(_class19, [{\n    key: \"_write\",\n    value: function _write(ostr) {\n      ostr.writeString(this.name);\n      IceGrid.StringStringDictHelper.write(ostr, this.variables);\n      IceGrid.ReplicaGroupDescriptorSeqHelper.write(ostr, this.replicaGroups);\n      IceGrid.TemplateDescriptorDictHelper.write(ostr, this.serverTemplates);\n      IceGrid.TemplateDescriptorDictHelper.write(ostr, this.serviceTemplates);\n      IceGrid.NodeDescriptorDictHelper.write(ostr, this.nodes);\n      IceGrid.DistributionDescriptor.write(ostr, this.distrib);\n      ostr.writeString(this.description);\n      IceGrid.PropertySetDescriptorDictHelper.write(ostr, this.propertySets);\n    }\n  }, {\n    key: \"_read\",\n    value: function _read(istr) {\n      this.name = istr.readString();\n      this.variables = IceGrid.StringStringDictHelper.read(istr);\n      this.replicaGroups = IceGrid.ReplicaGroupDescriptorSeqHelper.read(istr);\n      this.serverTemplates = IceGrid.TemplateDescriptorDictHelper.read(istr);\n      this.serviceTemplates = IceGrid.TemplateDescriptorDictHelper.read(istr);\n      this.nodes = IceGrid.NodeDescriptorDictHelper.read(istr);\n      this.distrib = IceGrid.DistributionDescriptor.read(istr, this.distrib);\n      this.description = istr.readString();\n      this.propertySets = IceGrid.PropertySetDescriptorDictHelper.read(istr);\n    }\n  }], [{\n    key: \"minWireSize\",\n    get: function get() {\n      return 10;\n    }\n  }]);\n}();\nSlice.defineStruct(IceGrid.ApplicationDescriptor, false, true);\nSlice.defineSequence(IceGrid, \"ApplicationDescriptorSeqHelper\", \"IceGrid.ApplicationDescriptor\", false);\nvar iceC_IceGrid_BoxedString_ids = [\"::Ice::Object\", \"::IceGrid::BoxedString\"];\n\n/**\n * A \"boxed\" string.\n *\n **/\nIceGrid.BoxedString = /*#__PURE__*/function (_Ice$Value3) {\n  \"use strict\";\n\n  function _class20() {\n    var _this0;\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    _classCallCheck(this, _class20);\n    _this0 = _callSuper(this, _class20);\n    _this0.value = value;\n    return _this0;\n  }\n  _inherits(_class20, _Ice$Value3);\n  return _createClass(_class20, [{\n    key: \"_iceWriteMemberImpl\",\n    value: function _iceWriteMemberImpl(ostr) {\n      ostr.writeString(this.value);\n    }\n  }, {\n    key: \"_iceReadMemberImpl\",\n    value: function _iceReadMemberImpl(istr) {\n      this.value = istr.readString();\n    }\n  }]);\n}(Ice.Value);\nSlice.defineValue(IceGrid.BoxedString, iceC_IceGrid_BoxedString_ids[1], false);\n\n/**\n * A node update descriptor to describe the updates to apply to a\n * node of a deployed application.\n *\n **/\nIceGrid.NodeUpdateDescriptor = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function _class21() {\n    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var description = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var variables = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    var removeVariables = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    var propertySets = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    var removePropertySets = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n    var serverInstances = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n    var servers = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;\n    var removeServers = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : null;\n    var loadFactor = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : null;\n    _classCallCheck(this, _class21);\n    this.name = name;\n    this.description = description;\n    this.variables = variables;\n    this.removeVariables = removeVariables;\n    this.propertySets = propertySets;\n    this.removePropertySets = removePropertySets;\n    this.serverInstances = serverInstances;\n    this.servers = servers;\n    this.removeServers = removeServers;\n    this.loadFactor = loadFactor;\n  }\n  return _createClass(_class21, [{\n    key: \"_write\",\n    value: function _write(ostr) {\n      ostr.writeString(this.name);\n      ostr.writeValue(this.description);\n      IceGrid.StringStringDictHelper.write(ostr, this.variables);\n      Ice.StringSeqHelper.write(ostr, this.removeVariables);\n      IceGrid.PropertySetDescriptorDictHelper.write(ostr, this.propertySets);\n      Ice.StringSeqHelper.write(ostr, this.removePropertySets);\n      IceGrid.ServerInstanceDescriptorSeqHelper.write(ostr, this.serverInstances);\n      IceGrid.ServerDescriptorSeqHelper.write(ostr, this.servers);\n      Ice.StringSeqHelper.write(ostr, this.removeServers);\n      ostr.writeValue(this.loadFactor);\n    }\n  }, {\n    key: \"_read\",\n    value: function _read(istr) {\n      var _this1 = this;\n      this.name = istr.readString();\n      istr.readValue(function (obj) {\n        return _this1.description = obj;\n      }, IceGrid.BoxedString);\n      this.variables = IceGrid.StringStringDictHelper.read(istr);\n      this.removeVariables = Ice.StringSeqHelper.read(istr);\n      this.propertySets = IceGrid.PropertySetDescriptorDictHelper.read(istr);\n      this.removePropertySets = Ice.StringSeqHelper.read(istr);\n      this.serverInstances = IceGrid.ServerInstanceDescriptorSeqHelper.read(istr);\n      this.servers = IceGrid.ServerDescriptorSeqHelper.read(istr);\n      this.removeServers = Ice.StringSeqHelper.read(istr);\n      istr.readValue(function (obj) {\n        return _this1.loadFactor = obj;\n      }, IceGrid.BoxedString);\n    }\n  }], [{\n    key: \"minWireSize\",\n    get: function get() {\n      return 10;\n    }\n  }]);\n}();\nSlice.defineStruct(IceGrid.NodeUpdateDescriptor, false, true);\nSlice.defineSequence(IceGrid, \"NodeUpdateDescriptorSeqHelper\", \"IceGrid.NodeUpdateDescriptor\", false);\nvar iceC_IceGrid_BoxedDistributionDescriptor_ids = [\"::Ice::Object\", \"::IceGrid::BoxedDistributionDescriptor\"];\n\n/**\n * A \"boxed\" distribution descriptor.\n *\n **/\nIceGrid.BoxedDistributionDescriptor = /*#__PURE__*/function (_Ice$Value4) {\n  \"use strict\";\n\n  function _class22() {\n    var _this10;\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new IceGrid.DistributionDescriptor();\n    _classCallCheck(this, _class22);\n    _this10 = _callSuper(this, _class22);\n    _this10.value = value;\n    return _this10;\n  }\n  _inherits(_class22, _Ice$Value4);\n  return _createClass(_class22, [{\n    key: \"_iceWriteMemberImpl\",\n    value: function _iceWriteMemberImpl(ostr) {\n      IceGrid.DistributionDescriptor.write(ostr, this.value);\n    }\n  }, {\n    key: \"_iceReadMemberImpl\",\n    value: function _iceReadMemberImpl(istr) {\n      this.value = IceGrid.DistributionDescriptor.read(istr, this.value);\n    }\n  }]);\n}(Ice.Value);\nSlice.defineValue(IceGrid.BoxedDistributionDescriptor, iceC_IceGrid_BoxedDistributionDescriptor_ids[1], false);\n\n/**\n * An application update descriptor to describe the updates to apply\n * to a deployed application.\n *\n **/\nIceGrid.ApplicationUpdateDescriptor = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function _class23() {\n    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var description = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var distrib = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    var variables = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    var removeVariables = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    var propertySets = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n    var removePropertySets = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n    var replicaGroups = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;\n    var removeReplicaGroups = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : null;\n    var serverTemplates = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : null;\n    var removeServerTemplates = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : null;\n    var serviceTemplates = arguments.length > 11 && arguments[11] !== undefined ? arguments[11] : null;\n    var removeServiceTemplates = arguments.length > 12 && arguments[12] !== undefined ? arguments[12] : null;\n    var nodes = arguments.length > 13 && arguments[13] !== undefined ? arguments[13] : null;\n    var removeNodes = arguments.length > 14 && arguments[14] !== undefined ? arguments[14] : null;\n    _classCallCheck(this, _class23);\n    this.name = name;\n    this.description = description;\n    this.distrib = distrib;\n    this.variables = variables;\n    this.removeVariables = removeVariables;\n    this.propertySets = propertySets;\n    this.removePropertySets = removePropertySets;\n    this.replicaGroups = replicaGroups;\n    this.removeReplicaGroups = removeReplicaGroups;\n    this.serverTemplates = serverTemplates;\n    this.removeServerTemplates = removeServerTemplates;\n    this.serviceTemplates = serviceTemplates;\n    this.removeServiceTemplates = removeServiceTemplates;\n    this.nodes = nodes;\n    this.removeNodes = removeNodes;\n  }\n  return _createClass(_class23, [{\n    key: \"_write\",\n    value: function _write(ostr) {\n      ostr.writeString(this.name);\n      ostr.writeValue(this.description);\n      ostr.writeValue(this.distrib);\n      IceGrid.StringStringDictHelper.write(ostr, this.variables);\n      Ice.StringSeqHelper.write(ostr, this.removeVariables);\n      IceGrid.PropertySetDescriptorDictHelper.write(ostr, this.propertySets);\n      Ice.StringSeqHelper.write(ostr, this.removePropertySets);\n      IceGrid.ReplicaGroupDescriptorSeqHelper.write(ostr, this.replicaGroups);\n      Ice.StringSeqHelper.write(ostr, this.removeReplicaGroups);\n      IceGrid.TemplateDescriptorDictHelper.write(ostr, this.serverTemplates);\n      Ice.StringSeqHelper.write(ostr, this.removeServerTemplates);\n      IceGrid.TemplateDescriptorDictHelper.write(ostr, this.serviceTemplates);\n      Ice.StringSeqHelper.write(ostr, this.removeServiceTemplates);\n      IceGrid.NodeUpdateDescriptorSeqHelper.write(ostr, this.nodes);\n      Ice.StringSeqHelper.write(ostr, this.removeNodes);\n    }\n  }, {\n    key: \"_read\",\n    value: function _read(istr) {\n      var _this11 = this;\n      this.name = istr.readString();\n      istr.readValue(function (obj) {\n        return _this11.description = obj;\n      }, IceGrid.BoxedString);\n      istr.readValue(function (obj) {\n        return _this11.distrib = obj;\n      }, IceGrid.BoxedDistributionDescriptor);\n      this.variables = IceGrid.StringStringDictHelper.read(istr);\n      this.removeVariables = Ice.StringSeqHelper.read(istr);\n      this.propertySets = IceGrid.PropertySetDescriptorDictHelper.read(istr);\n      this.removePropertySets = Ice.StringSeqHelper.read(istr);\n      this.replicaGroups = IceGrid.ReplicaGroupDescriptorSeqHelper.read(istr);\n      this.removeReplicaGroups = Ice.StringSeqHelper.read(istr);\n      this.serverTemplates = IceGrid.TemplateDescriptorDictHelper.read(istr);\n      this.removeServerTemplates = Ice.StringSeqHelper.read(istr);\n      this.serviceTemplates = IceGrid.TemplateDescriptorDictHelper.read(istr);\n      this.removeServiceTemplates = Ice.StringSeqHelper.read(istr);\n      this.nodes = IceGrid.NodeUpdateDescriptorSeqHelper.read(istr);\n      this.removeNodes = Ice.StringSeqHelper.read(istr);\n    }\n  }], [{\n    key: \"minWireSize\",\n    get: function get() {\n      return 15;\n    }\n  }]);\n}();\nSlice.defineStruct(IceGrid.ApplicationUpdateDescriptor, false, true);\n/* slice2js browser-bundle-skip */\nexports.IceGrid = IceGrid;\n/* slice2js browser-bundle-skip-end */\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/IceGrid/Descriptor.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/IceGrid/Exception.js":
/*!***************************************************!*\
  !*** ./node_modules/ice/src/IceGrid/Exception.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `Exception.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nvar _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Exception */ \"./node_modules/ice/src/Ice/Exception.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\n__webpack_require__(/*! ../Ice/Identity */ \"./node_modules/ice/src/Ice/Identity.js\");\n__webpack_require__(/*! ../Ice/BuiltinSequences */ \"./node_modules/ice/src/Ice/BuiltinSequences.js\");\nvar Ice = _ModuleRegistry.module(\"Ice\");\nvar Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n/* slice2js browser-bundle-skip */\n\nvar IceGrid = _ModuleRegistry.module(\"IceGrid\");\n/* slice2js browser-bundle-skip-end */\n\n/**\n * This exception is raised if an application does not exist.\n *\n **/\nIceGrid.ApplicationNotExistException = /*#__PURE__*/function (_Ice$UserException) {\n  \"use strict\";\n\n  function _class() {\n    var _this;\n    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class);\n    _this = _callSuper(this, _class, [_cause]);\n    _this.name = name;\n    return _this;\n  }\n  _inherits(_class, _Ice$UserException);\n  return _createClass(_class, [{\n    key: \"_mostDerivedType\",\n    value: function _mostDerivedType() {\n      return IceGrid.ApplicationNotExistException;\n    }\n  }, {\n    key: \"_writeMemberImpl\",\n    value: function _writeMemberImpl(ostr) {\n      ostr.writeString(this.name);\n    }\n  }, {\n    key: \"_readMemberImpl\",\n    value: function _readMemberImpl(istr) {\n      this.name = istr.readString();\n    }\n  }], [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.UserException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::IceGrid::ApplicationNotExistException\";\n    }\n  }]);\n}(Ice.UserException);\n\n/**\n * This exception is raised if a server does not exist.\n *\n **/\nIceGrid.ServerNotExistException = /*#__PURE__*/function (_Ice$UserException2) {\n  \"use strict\";\n\n  function _class2() {\n    var _this2;\n    var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class2);\n    _this2 = _callSuper(this, _class2, [_cause]);\n    _this2.id = id;\n    return _this2;\n  }\n  _inherits(_class2, _Ice$UserException2);\n  return _createClass(_class2, [{\n    key: \"_mostDerivedType\",\n    value: function _mostDerivedType() {\n      return IceGrid.ServerNotExistException;\n    }\n  }, {\n    key: \"_writeMemberImpl\",\n    value: function _writeMemberImpl(ostr) {\n      ostr.writeString(this.id);\n    }\n  }, {\n    key: \"_readMemberImpl\",\n    value: function _readMemberImpl(istr) {\n      this.id = istr.readString();\n    }\n  }], [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.UserException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::IceGrid::ServerNotExistException\";\n    }\n  }]);\n}(Ice.UserException);\n\n/**\n * This exception is raised if a server failed to start.\n *\n **/\nIceGrid.ServerStartException = /*#__PURE__*/function (_Ice$UserException3) {\n  \"use strict\";\n\n  function _class3() {\n    var _this3;\n    var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var reason = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    var _cause = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n    _classCallCheck(this, _class3);\n    _this3 = _callSuper(this, _class3, [_cause]);\n    _this3.id = id;\n    _this3.reason = reason;\n    return _this3;\n  }\n  _inherits(_class3, _Ice$UserException3);\n  return _createClass(_class3, [{\n    key: \"_mostDerivedType\",\n    value: function _mostDerivedType() {\n      return IceGrid.ServerStartException;\n    }\n  }, {\n    key: \"_writeMemberImpl\",\n    value: function _writeMemberImpl(ostr) {\n      ostr.writeString(this.id);\n      ostr.writeString(this.reason);\n    }\n  }, {\n    key: \"_readMemberImpl\",\n    value: function _readMemberImpl(istr) {\n      this.id = istr.readString();\n      this.reason = istr.readString();\n    }\n  }], [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.UserException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::IceGrid::ServerStartException\";\n    }\n  }]);\n}(Ice.UserException);\n\n/**\n * This exception is raised if a server failed to stop.\n *\n **/\nIceGrid.ServerStopException = /*#__PURE__*/function (_Ice$UserException4) {\n  \"use strict\";\n\n  function _class4() {\n    var _this4;\n    var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var reason = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    var _cause = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n    _classCallCheck(this, _class4);\n    _this4 = _callSuper(this, _class4, [_cause]);\n    _this4.id = id;\n    _this4.reason = reason;\n    return _this4;\n  }\n  _inherits(_class4, _Ice$UserException4);\n  return _createClass(_class4, [{\n    key: \"_mostDerivedType\",\n    value: function _mostDerivedType() {\n      return IceGrid.ServerStopException;\n    }\n  }, {\n    key: \"_writeMemberImpl\",\n    value: function _writeMemberImpl(ostr) {\n      ostr.writeString(this.id);\n      ostr.writeString(this.reason);\n    }\n  }, {\n    key: \"_readMemberImpl\",\n    value: function _readMemberImpl(istr) {\n      this.id = istr.readString();\n      this.reason = istr.readString();\n    }\n  }], [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.UserException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::IceGrid::ServerStopException\";\n    }\n  }]);\n}(Ice.UserException);\n\n/**\n * This exception is raised if an adapter does not exist.\n *\n **/\nIceGrid.AdapterNotExistException = /*#__PURE__*/function (_Ice$UserException5) {\n  \"use strict\";\n\n  function _class5() {\n    var _this5;\n    var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class5);\n    _this5 = _callSuper(this, _class5, [_cause]);\n    _this5.id = id;\n    return _this5;\n  }\n  _inherits(_class5, _Ice$UserException5);\n  return _createClass(_class5, [{\n    key: \"_mostDerivedType\",\n    value: function _mostDerivedType() {\n      return IceGrid.AdapterNotExistException;\n    }\n  }, {\n    key: \"_writeMemberImpl\",\n    value: function _writeMemberImpl(ostr) {\n      ostr.writeString(this.id);\n    }\n  }, {\n    key: \"_readMemberImpl\",\n    value: function _readMemberImpl(istr) {\n      this.id = istr.readString();\n    }\n  }], [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.UserException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::IceGrid::AdapterNotExistException\";\n    }\n  }]);\n}(Ice.UserException);\n\n/**\n * This exception is raised if an object already exists.\n *\n **/\nIceGrid.ObjectExistsException = /*#__PURE__*/function (_Ice$UserException6) {\n  \"use strict\";\n\n  function _class6() {\n    var _this6;\n    var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Ice.Identity();\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class6);\n    _this6 = _callSuper(this, _class6, [_cause]);\n    _this6.id = id;\n    return _this6;\n  }\n  _inherits(_class6, _Ice$UserException6);\n  return _createClass(_class6, [{\n    key: \"_mostDerivedType\",\n    value: function _mostDerivedType() {\n      return IceGrid.ObjectExistsException;\n    }\n  }, {\n    key: \"_writeMemberImpl\",\n    value: function _writeMemberImpl(ostr) {\n      Ice.Identity.write(ostr, this.id);\n    }\n  }, {\n    key: \"_readMemberImpl\",\n    value: function _readMemberImpl(istr) {\n      this.id = Ice.Identity.read(istr, this.id);\n    }\n  }], [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.UserException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::IceGrid::ObjectExistsException\";\n    }\n  }]);\n}(Ice.UserException);\n\n/**\n * This exception is raised if an object is not registered.\n *\n **/\nIceGrid.ObjectNotRegisteredException = /*#__PURE__*/function (_Ice$UserException7) {\n  \"use strict\";\n\n  function _class7() {\n    var _this7;\n    var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Ice.Identity();\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class7);\n    _this7 = _callSuper(this, _class7, [_cause]);\n    _this7.id = id;\n    return _this7;\n  }\n  _inherits(_class7, _Ice$UserException7);\n  return _createClass(_class7, [{\n    key: \"_mostDerivedType\",\n    value: function _mostDerivedType() {\n      return IceGrid.ObjectNotRegisteredException;\n    }\n  }, {\n    key: \"_writeMemberImpl\",\n    value: function _writeMemberImpl(ostr) {\n      Ice.Identity.write(ostr, this.id);\n    }\n  }, {\n    key: \"_readMemberImpl\",\n    value: function _readMemberImpl(istr) {\n      this.id = Ice.Identity.read(istr, this.id);\n    }\n  }], [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.UserException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::IceGrid::ObjectNotRegisteredException\";\n    }\n  }]);\n}(Ice.UserException);\n\n/**\n * This exception is raised if a node does not exist.\n *\n **/\nIceGrid.NodeNotExistException = /*#__PURE__*/function (_Ice$UserException8) {\n  \"use strict\";\n\n  function _class8() {\n    var _this8;\n    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class8);\n    _this8 = _callSuper(this, _class8, [_cause]);\n    _this8.name = name;\n    return _this8;\n  }\n  _inherits(_class8, _Ice$UserException8);\n  return _createClass(_class8, [{\n    key: \"_mostDerivedType\",\n    value: function _mostDerivedType() {\n      return IceGrid.NodeNotExistException;\n    }\n  }, {\n    key: \"_writeMemberImpl\",\n    value: function _writeMemberImpl(ostr) {\n      ostr.writeString(this.name);\n    }\n  }, {\n    key: \"_readMemberImpl\",\n    value: function _readMemberImpl(istr) {\n      this.name = istr.readString();\n    }\n  }], [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.UserException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::IceGrid::NodeNotExistException\";\n    }\n  }]);\n}(Ice.UserException);\n\n/**\n * This exception is raised if a registry does not exist.\n *\n **/\nIceGrid.RegistryNotExistException = /*#__PURE__*/function (_Ice$UserException9) {\n  \"use strict\";\n\n  function _class9() {\n    var _this9;\n    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class9);\n    _this9 = _callSuper(this, _class9, [_cause]);\n    _this9.name = name;\n    return _this9;\n  }\n  _inherits(_class9, _Ice$UserException9);\n  return _createClass(_class9, [{\n    key: \"_mostDerivedType\",\n    value: function _mostDerivedType() {\n      return IceGrid.RegistryNotExistException;\n    }\n  }, {\n    key: \"_writeMemberImpl\",\n    value: function _writeMemberImpl(ostr) {\n      ostr.writeString(this.name);\n    }\n  }, {\n    key: \"_readMemberImpl\",\n    value: function _readMemberImpl(istr) {\n      this.name = istr.readString();\n    }\n  }], [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.UserException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::IceGrid::RegistryNotExistException\";\n    }\n  }]);\n}(Ice.UserException);\n\n/**\n * An exception for deployment errors.\n *\n **/\nIceGrid.DeploymentException = /*#__PURE__*/function (_Ice$UserException0) {\n  \"use strict\";\n\n  function _class0() {\n    var _this0;\n    var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class0);\n    _this0 = _callSuper(this, _class0, [_cause]);\n    _this0.reason = reason;\n    return _this0;\n  }\n  _inherits(_class0, _Ice$UserException0);\n  return _createClass(_class0, [{\n    key: \"_mostDerivedType\",\n    value: function _mostDerivedType() {\n      return IceGrid.DeploymentException;\n    }\n  }, {\n    key: \"_writeMemberImpl\",\n    value: function _writeMemberImpl(ostr) {\n      ostr.writeString(this.reason);\n    }\n  }, {\n    key: \"_readMemberImpl\",\n    value: function _readMemberImpl(istr) {\n      this.reason = istr.readString();\n    }\n  }], [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.UserException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::IceGrid::DeploymentException\";\n    }\n  }]);\n}(Ice.UserException);\n\n/**\n * This exception is raised if a node could not be reached.\n *\n **/\nIceGrid.NodeUnreachableException = /*#__PURE__*/function (_Ice$UserException1) {\n  \"use strict\";\n\n  function _class1() {\n    var _this1;\n    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var reason = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    var _cause = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n    _classCallCheck(this, _class1);\n    _this1 = _callSuper(this, _class1, [_cause]);\n    _this1.name = name;\n    _this1.reason = reason;\n    return _this1;\n  }\n  _inherits(_class1, _Ice$UserException1);\n  return _createClass(_class1, [{\n    key: \"_mostDerivedType\",\n    value: function _mostDerivedType() {\n      return IceGrid.NodeUnreachableException;\n    }\n  }, {\n    key: \"_writeMemberImpl\",\n    value: function _writeMemberImpl(ostr) {\n      ostr.writeString(this.name);\n      ostr.writeString(this.reason);\n    }\n  }, {\n    key: \"_readMemberImpl\",\n    value: function _readMemberImpl(istr) {\n      this.name = istr.readString();\n      this.reason = istr.readString();\n    }\n  }], [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.UserException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::IceGrid::NodeUnreachableException\";\n    }\n  }]);\n}(Ice.UserException);\n\n/**\n * This exception is raised if a server could not be reached.\n *\n **/\nIceGrid.ServerUnreachableException = /*#__PURE__*/function (_Ice$UserException10) {\n  \"use strict\";\n\n  function _class10() {\n    var _this10;\n    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var reason = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    var _cause = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n    _classCallCheck(this, _class10);\n    _this10 = _callSuper(this, _class10, [_cause]);\n    _this10.name = name;\n    _this10.reason = reason;\n    return _this10;\n  }\n  _inherits(_class10, _Ice$UserException10);\n  return _createClass(_class10, [{\n    key: \"_mostDerivedType\",\n    value: function _mostDerivedType() {\n      return IceGrid.ServerUnreachableException;\n    }\n  }, {\n    key: \"_writeMemberImpl\",\n    value: function _writeMemberImpl(ostr) {\n      ostr.writeString(this.name);\n      ostr.writeString(this.reason);\n    }\n  }, {\n    key: \"_readMemberImpl\",\n    value: function _readMemberImpl(istr) {\n      this.name = istr.readString();\n      this.reason = istr.readString();\n    }\n  }], [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.UserException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::IceGrid::ServerUnreachableException\";\n    }\n  }]);\n}(Ice.UserException);\n\n/**\n * This exception is raised if a registry could not be reached.\n *\n **/\nIceGrid.RegistryUnreachableException = /*#__PURE__*/function (_Ice$UserException11) {\n  \"use strict\";\n\n  function _class11() {\n    var _this11;\n    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var reason = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    var _cause = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n    _classCallCheck(this, _class11);\n    _this11 = _callSuper(this, _class11, [_cause]);\n    _this11.name = name;\n    _this11.reason = reason;\n    return _this11;\n  }\n  _inherits(_class11, _Ice$UserException11);\n  return _createClass(_class11, [{\n    key: \"_mostDerivedType\",\n    value: function _mostDerivedType() {\n      return IceGrid.RegistryUnreachableException;\n    }\n  }, {\n    key: \"_writeMemberImpl\",\n    value: function _writeMemberImpl(ostr) {\n      ostr.writeString(this.name);\n      ostr.writeString(this.reason);\n    }\n  }, {\n    key: \"_readMemberImpl\",\n    value: function _readMemberImpl(istr) {\n      this.name = istr.readString();\n      this.reason = istr.readString();\n    }\n  }], [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.UserException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::IceGrid::RegistryUnreachableException\";\n    }\n  }]);\n}(Ice.UserException);\n\n/**\n * This exception is raised if an unknown signal was sent to\n * to a server.\n *\n **/\nIceGrid.BadSignalException = /*#__PURE__*/function (_Ice$UserException12) {\n  \"use strict\";\n\n  function _class12() {\n    var _this12;\n    var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class12);\n    _this12 = _callSuper(this, _class12, [_cause]);\n    _this12.reason = reason;\n    return _this12;\n  }\n  _inherits(_class12, _Ice$UserException12);\n  return _createClass(_class12, [{\n    key: \"_mostDerivedType\",\n    value: function _mostDerivedType() {\n      return IceGrid.BadSignalException;\n    }\n  }, {\n    key: \"_writeMemberImpl\",\n    value: function _writeMemberImpl(ostr) {\n      ostr.writeString(this.reason);\n    }\n  }, {\n    key: \"_readMemberImpl\",\n    value: function _readMemberImpl(istr) {\n      this.reason = istr.readString();\n    }\n  }], [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.UserException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::IceGrid::BadSignalException\";\n    }\n  }]);\n}(Ice.UserException);\n\n/**\n * This exception is raised if a patch failed.\n *\n **/\nIceGrid.PatchException = /*#__PURE__*/function (_Ice$UserException13) {\n  \"use strict\";\n\n  function _class13() {\n    var _this13;\n    var reasons = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class13);\n    _this13 = _callSuper(this, _class13, [_cause]);\n    _this13.reasons = reasons;\n    return _this13;\n  }\n  _inherits(_class13, _Ice$UserException13);\n  return _createClass(_class13, [{\n    key: \"_mostDerivedType\",\n    value: function _mostDerivedType() {\n      return IceGrid.PatchException;\n    }\n  }, {\n    key: \"_writeMemberImpl\",\n    value: function _writeMemberImpl(ostr) {\n      Ice.StringSeqHelper.write(ostr, this.reasons);\n    }\n  }, {\n    key: \"_readMemberImpl\",\n    value: function _readMemberImpl(istr) {\n      this.reasons = Ice.StringSeqHelper.read(istr);\n    }\n  }], [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.UserException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::IceGrid::PatchException\";\n    }\n  }]);\n}(Ice.UserException);\n\n/**\n * This exception is raised if a registry lock wasn't\n * acquired or is already held by a session.\n *\n **/\nIceGrid.AccessDeniedException = /*#__PURE__*/function (_Ice$UserException14) {\n  \"use strict\";\n\n  function _class14() {\n    var _this14;\n    var lockUserId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class14);\n    _this14 = _callSuper(this, _class14, [_cause]);\n    _this14.lockUserId = lockUserId;\n    return _this14;\n  }\n  _inherits(_class14, _Ice$UserException14);\n  return _createClass(_class14, [{\n    key: \"_mostDerivedType\",\n    value: function _mostDerivedType() {\n      return IceGrid.AccessDeniedException;\n    }\n  }, {\n    key: \"_writeMemberImpl\",\n    value: function _writeMemberImpl(ostr) {\n      ostr.writeString(this.lockUserId);\n    }\n  }, {\n    key: \"_readMemberImpl\",\n    value: function _readMemberImpl(istr) {\n      this.lockUserId = istr.readString();\n    }\n  }], [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.UserException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::IceGrid::AccessDeniedException\";\n    }\n  }]);\n}(Ice.UserException);\n\n/**\n * This exception is raised if the allocation of an object failed.\n *\n **/\nIceGrid.AllocationException = /*#__PURE__*/function (_Ice$UserException15) {\n  \"use strict\";\n\n  function _class15() {\n    var _this15;\n    var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class15);\n    _this15 = _callSuper(this, _class15, [_cause]);\n    _this15.reason = reason;\n    return _this15;\n  }\n  _inherits(_class15, _Ice$UserException15);\n  return _createClass(_class15, [{\n    key: \"_mostDerivedType\",\n    value: function _mostDerivedType() {\n      return IceGrid.AllocationException;\n    }\n  }, {\n    key: \"_writeMemberImpl\",\n    value: function _writeMemberImpl(ostr) {\n      ostr.writeString(this.reason);\n    }\n  }, {\n    key: \"_readMemberImpl\",\n    value: function _readMemberImpl(istr) {\n      this.reason = istr.readString();\n    }\n  }], [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.UserException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::IceGrid::AllocationException\";\n    }\n  }]);\n}(Ice.UserException);\n\n/**\n * This exception is raised if the request to allocate an object times\n * out.\n *\n **/\nIceGrid.AllocationTimeoutException = /*#__PURE__*/function (_IceGrid$AllocationEx) {\n  \"use strict\";\n\n  function _class16(reason) {\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class16);\n    return _callSuper(this, _class16, [reason, _cause]);\n  }\n  _inherits(_class16, _IceGrid$AllocationEx);\n  return _createClass(_class16, [{\n    key: \"_mostDerivedType\",\n    value: function _mostDerivedType() {\n      return IceGrid.AllocationTimeoutException;\n    }\n  }], [{\n    key: \"_parent\",\n    get: function get() {\n      return IceGrid.AllocationException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::IceGrid::AllocationTimeoutException\";\n    }\n  }]);\n}(IceGrid.AllocationException);\n\n/**\n * This exception is raised if a client is denied the ability to create\n * a session with IceGrid.\n *\n **/\nIceGrid.PermissionDeniedException = /*#__PURE__*/function (_Ice$UserException16) {\n  \"use strict\";\n\n  function _class17() {\n    var _this16;\n    var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class17);\n    _this16 = _callSuper(this, _class17, [_cause]);\n    _this16.reason = reason;\n    return _this16;\n  }\n  _inherits(_class17, _Ice$UserException16);\n  return _createClass(_class17, [{\n    key: \"_mostDerivedType\",\n    value: function _mostDerivedType() {\n      return IceGrid.PermissionDeniedException;\n    }\n  }, {\n    key: \"_writeMemberImpl\",\n    value: function _writeMemberImpl(ostr) {\n      ostr.writeString(this.reason);\n    }\n  }, {\n    key: \"_readMemberImpl\",\n    value: function _readMemberImpl(istr) {\n      this.reason = istr.readString();\n    }\n  }], [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.UserException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::IceGrid::PermissionDeniedException\";\n    }\n  }]);\n}(Ice.UserException);\n\n/**\n * This exception is raised if an observer is already registered with\n * the registry.\n *\n * @see AdminSession#setObservers\n * @see AdminSession#setObserversByIdentity\n *\n **/\nIceGrid.ObserverAlreadyRegisteredException = /*#__PURE__*/function (_Ice$UserException17) {\n  \"use strict\";\n\n  function _class18() {\n    var _this17;\n    var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Ice.Identity();\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class18);\n    _this17 = _callSuper(this, _class18, [_cause]);\n    _this17.id = id;\n    return _this17;\n  }\n  _inherits(_class18, _Ice$UserException17);\n  return _createClass(_class18, [{\n    key: \"_mostDerivedType\",\n    value: function _mostDerivedType() {\n      return IceGrid.ObserverAlreadyRegisteredException;\n    }\n  }, {\n    key: \"_writeMemberImpl\",\n    value: function _writeMemberImpl(ostr) {\n      Ice.Identity.write(ostr, this.id);\n    }\n  }, {\n    key: \"_readMemberImpl\",\n    value: function _readMemberImpl(istr) {\n      this.id = Ice.Identity.read(istr, this.id);\n    }\n  }], [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.UserException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::IceGrid::ObserverAlreadyRegisteredException\";\n    }\n  }]);\n}(Ice.UserException);\n\n/**\n * This exception is raised if a file is not available.\n *\n * @see AdminSession#openServerStdOut\n * @see AdminSession#openServerStdErr\n * @see AdminSession#openNodeStdOut\n * @see AdminSession#openNodeStdErr\n * @see AdminSession#openRegistryStdOut\n * @see AdminSession#openRegistryStdErr\n *\n **/\nIceGrid.FileNotAvailableException = /*#__PURE__*/function (_Ice$UserException18) {\n  \"use strict\";\n\n  function _class19() {\n    var _this18;\n    var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class19);\n    _this18 = _callSuper(this, _class19, [_cause]);\n    _this18.reason = reason;\n    return _this18;\n  }\n  _inherits(_class19, _Ice$UserException18);\n  return _createClass(_class19, [{\n    key: \"_mostDerivedType\",\n    value: function _mostDerivedType() {\n      return IceGrid.FileNotAvailableException;\n    }\n  }, {\n    key: \"_writeMemberImpl\",\n    value: function _writeMemberImpl(ostr) {\n      ostr.writeString(this.reason);\n    }\n  }, {\n    key: \"_readMemberImpl\",\n    value: function _readMemberImpl(istr) {\n      this.reason = istr.readString();\n    }\n  }], [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.UserException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::IceGrid::FileNotAvailableException\";\n    }\n  }]);\n}(Ice.UserException);\n/* slice2js browser-bundle-skip */\nexports.IceGrid = IceGrid;\n/* slice2js browser-bundle-skip-end */\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/IceGrid/Exception.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/IceGrid/FileParser.js":
/*!****************************************************!*\
  !*** ./node_modules/ice/src/IceGrid/FileParser.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `FileParser.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nvar _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\");\n__webpack_require__(/*! ../Ice/ObjectPrx */ \"./node_modules/ice/src/Ice/ObjectPrx.js\");\n__webpack_require__(/*! ../Ice/Operation */ \"./node_modules/ice/src/Ice/Operation.js\");\n__webpack_require__(/*! ../Ice/Exception */ \"./node_modules/ice/src/Ice/Exception.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\nvar Ice = _ModuleRegistry.module(\"Ice\");\nvar IceGrid = (__webpack_require__(/*! ../IceGrid/Admin */ \"./node_modules/ice/src/IceGrid/Admin.js\").IceGrid);\nvar Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n\n/**\n * This exception is raised if an error occurs during parsing.\n *\n **/\nIceGrid.ParseException = /*#__PURE__*/function (_Ice$UserException) {\n  \"use strict\";\n\n  function _class() {\n    var _this;\n    var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class);\n    _this = _callSuper(this, _class, [_cause]);\n    _this.reason = reason;\n    return _this;\n  }\n  _inherits(_class, _Ice$UserException);\n  return _createClass(_class, [{\n    key: \"_mostDerivedType\",\n    value: function _mostDerivedType() {\n      return IceGrid.ParseException;\n    }\n  }, {\n    key: \"_writeMemberImpl\",\n    value: function _writeMemberImpl(ostr) {\n      ostr.writeString(this.reason);\n    }\n  }, {\n    key: \"_readMemberImpl\",\n    value: function _readMemberImpl(istr) {\n      this.reason = istr.readString();\n    }\n  }], [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.UserException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::IceGrid::ParseException\";\n    }\n  }]);\n}(Ice.UserException);\nvar iceC_IceGrid_FileParser_ids = [\"::Ice::Object\", \"::IceGrid::FileParser\"];\n\n/**\n * <code>icegridadmin</code> provides a {@link FileParser}\n * object to transform XML files into {@link ApplicationDescriptor}\n * objects.\n *\n **/\nIceGrid.FileParser = /*#__PURE__*/function (_Ice$Object) {\n  \"use strict\";\n\n  function _class2() {\n    _classCallCheck(this, _class2);\n    return _callSuper(this, _class2, arguments);\n  }\n  _inherits(_class2, _Ice$Object);\n  return _createClass(_class2);\n}(Ice.Object);\nIceGrid.FileParserPrx = /*#__PURE__*/function (_Ice$ObjectPrx) {\n  \"use strict\";\n\n  function _class3() {\n    _classCallCheck(this, _class3);\n    return _callSuper(this, _class3, arguments);\n  }\n  _inherits(_class3, _Ice$ObjectPrx);\n  return _createClass(_class3);\n}(Ice.ObjectPrx);\nSlice.defineOperations(IceGrid.FileParser, IceGrid.FileParserPrx, iceC_IceGrid_FileParser_ids, 1, {\n  \"parse\": [, 2, 2,, [IceGrid.ApplicationDescriptor], [[7], [\"IceGrid.AdminPrx\"]],, [IceGrid.ParseException],, true]\n});\n/* slice2js browser-bundle-skip */\nexports.IceGrid = IceGrid;\n/* slice2js browser-bundle-skip-end */\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/IceGrid/FileParser.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/IceGrid/IceGrid.js":
/*!*************************************************!*\
  !*** ./node_modules/ice/src/IceGrid/IceGrid.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nvar _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../IceGrid/Admin */ \"./node_modules/ice/src/IceGrid/Admin.js\");\n__webpack_require__(/*! ../IceGrid/Descriptor */ \"./node_modules/ice/src/IceGrid/Descriptor.js\");\n__webpack_require__(/*! ../IceGrid/Exception */ \"./node_modules/ice/src/IceGrid/Exception.js\");\n__webpack_require__(/*! ../IceGrid/FileParser */ \"./node_modules/ice/src/IceGrid/FileParser.js\");\n__webpack_require__(/*! ../IceGrid/Registry */ \"./node_modules/ice/src/IceGrid/Registry.js\");\n__webpack_require__(/*! ../IceGrid/Session */ \"./node_modules/ice/src/IceGrid/Session.js\");\n__webpack_require__(/*! ../IceGrid/UserAccountMapper */ \"./node_modules/ice/src/IceGrid/UserAccountMapper.js\");\nmodule.exports.IceGrid = _ModuleRegistry.module(\"IceGrid\");\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/IceGrid/IceGrid.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/IceGrid/Registry.js":
/*!**************************************************!*\
  !*** ./node_modules/ice/src/IceGrid/Registry.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `Registry.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nvar _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\");\n__webpack_require__(/*! ../Ice/ObjectPrx */ \"./node_modules/ice/src/Ice/ObjectPrx.js\");\n__webpack_require__(/*! ../Ice/Operation */ \"./node_modules/ice/src/Ice/Operation.js\");\n__webpack_require__(/*! ../Ice/EnumBase */ \"./node_modules/ice/src/Ice/EnumBase.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\n__webpack_require__(/*! ../Ice/Locator */ \"./node_modules/ice/src/Ice/Locator.js\");\nvar Ice = _ModuleRegistry.module(\"Ice\");\n__webpack_require__(/*! ../IceGrid/Exception */ \"./node_modules/ice/src/IceGrid/Exception.js\");\n__webpack_require__(/*! ../IceGrid/Session */ \"./node_modules/ice/src/IceGrid/Session.js\");\n__webpack_require__(/*! ../IceGrid/Admin */ \"./node_modules/ice/src/IceGrid/Admin.js\");\nvar IceGrid = _ModuleRegistry.module(\"IceGrid\");\nvar Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n\n/**\n * Determines which load sampling interval to use.\n *\n **/\nIceGrid.LoadSample = Slice.defineEnum([['LoadSample1', 0], ['LoadSample5', 1], ['LoadSample15', 2]]);\nvar iceC_IceGrid_Query_ids = [\"::Ice::Object\", \"::IceGrid::Query\"];\n\n/**\n * The IceGrid query interface. This interface is accessible to\n * Ice clients who wish to look up well-known objects.\n *\n **/\nIceGrid.Query = /*#__PURE__*/function (_Ice$Object) {\n  \"use strict\";\n\n  function _class() {\n    _classCallCheck(this, _class);\n    return _callSuper(this, _class, arguments);\n  }\n  _inherits(_class, _Ice$Object);\n  return _createClass(_class);\n}(Ice.Object);\nIceGrid.QueryPrx = /*#__PURE__*/function (_Ice$ObjectPrx) {\n  \"use strict\";\n\n  function _class2() {\n    _classCallCheck(this, _class2);\n    return _callSuper(this, _class2, arguments);\n  }\n  _inherits(_class2, _Ice$ObjectPrx);\n  return _createClass(_class2);\n}(Ice.ObjectPrx);\nSlice.defineOperations(IceGrid.Query, IceGrid.QueryPrx, iceC_IceGrid_Query_ids, 1, {\n  \"findObjectById\": [, 2, 1,, [9], [[Ice.Identity]],,,,],\n  \"findObjectByType\": [, 2, 1,, [9], [[7]],,,,],\n  \"findObjectByTypeOnLeastLoadedNode\": [, 2, 1,, [9], [[7], [IceGrid.LoadSample._helper]],,,,],\n  \"findAllObjectsByType\": [, 2, 1,, [\"Ice.ObjectProxySeqHelper\"], [[7]],,,,],\n  \"findAllReplicas\": [, 2, 2,, [\"Ice.ObjectProxySeqHelper\"], [[9]],,,,]\n});\nvar iceC_IceGrid_Registry_ids = [\"::Ice::Object\", \"::IceGrid::Registry\"];\n\n/**\n * The IceGrid registry allows clients create sessions\n * directly with the registry.\n *\n * @see Session\n * @see AdminSession\n *\n **/\nIceGrid.Registry = /*#__PURE__*/function (_Ice$Object2) {\n  \"use strict\";\n\n  function _class3() {\n    _classCallCheck(this, _class3);\n    return _callSuper(this, _class3, arguments);\n  }\n  _inherits(_class3, _Ice$Object2);\n  return _createClass(_class3);\n}(Ice.Object);\nIceGrid.RegistryPrx = /*#__PURE__*/function (_Ice$ObjectPrx2) {\n  \"use strict\";\n\n  function _class4() {\n    _classCallCheck(this, _class4);\n    return _callSuper(this, _class4, arguments);\n  }\n  _inherits(_class4, _Ice$ObjectPrx2);\n  return _createClass(_class4);\n}(Ice.ObjectPrx);\nSlice.defineOperations(IceGrid.Registry, IceGrid.RegistryPrx, iceC_IceGrid_Registry_ids, 1, {\n  \"createSession\": [,,,, [\"IceGrid.SessionPrx\"], [[7], [7]],, [IceGrid.PermissionDeniedException],,],\n  \"createAdminSession\": [,,,, [\"IceGrid.AdminSessionPrx\"], [[7], [7]],, [IceGrid.PermissionDeniedException],,],\n  \"createSessionFromSecureConnection\": [,,,, [\"IceGrid.SessionPrx\"],,, [IceGrid.PermissionDeniedException],,],\n  \"createAdminSessionFromSecureConnection\": [,,,, [\"IceGrid.AdminSessionPrx\"],,, [IceGrid.PermissionDeniedException],,],\n  \"getSessionTimeout\": [, 2, 1,, [3],,,,,],\n  \"getACMTimeout\": [, 2, 1,, [3],,,,,]\n});\nvar iceC_IceGrid_Locator_ids = [\"::Ice::Locator\", \"::Ice::Object\", \"::IceGrid::Locator\"];\n\n/**\n * The IceGrid locator interface provides access to the {@link Query}\n * and {@link Registry} object of the IceGrid registry.\n *\n * @see Query\n * @see Registry\n *\n **/\nIceGrid.Locator = /*#__PURE__*/function (_Ice$Object3) {\n  \"use strict\";\n\n  function _class5() {\n    _classCallCheck(this, _class5);\n    return _callSuper(this, _class5, arguments);\n  }\n  _inherits(_class5, _Ice$Object3);\n  return _createClass(_class5, null, [{\n    key: \"_iceImplements\",\n    get: function get() {\n      return [Ice.Locator];\n    }\n  }]);\n}(Ice.Object);\nIceGrid.LocatorPrx = /*#__PURE__*/function (_Ice$ObjectPrx3) {\n  \"use strict\";\n\n  function _class6() {\n    _classCallCheck(this, _class6);\n    return _callSuper(this, _class6, arguments);\n  }\n  _inherits(_class6, _Ice$ObjectPrx3);\n  return _createClass(_class6, null, [{\n    key: \"_implements\",\n    get: function get() {\n      return [Ice.LocatorPrx];\n    }\n  }]);\n}(Ice.ObjectPrx);\nSlice.defineOperations(IceGrid.Locator, IceGrid.LocatorPrx, iceC_IceGrid_Locator_ids, 2, {\n  \"getLocalRegistry\": [, 2, 2,, [\"IceGrid.RegistryPrx\"],,,,,],\n  \"getLocalQuery\": [, 2, 2,, [\"IceGrid.QueryPrx\"],,,,,]\n});\n/* slice2js browser-bundle-skip */\nexports.IceGrid = IceGrid;\n/* slice2js browser-bundle-skip-end */\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/IceGrid/Registry.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/IceGrid/Session.js":
/*!*************************************************!*\
  !*** ./node_modules/ice/src/IceGrid/Session.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `Session.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nvar _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\nvar Glacier2 = (__webpack_require__(/*! ../Glacier2/Session */ \"./node_modules/ice/src/Glacier2/Session.js\").Glacier2);\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\");\n__webpack_require__(/*! ../Ice/ObjectPrx */ \"./node_modules/ice/src/Ice/ObjectPrx.js\");\n__webpack_require__(/*! ../Ice/Operation */ \"./node_modules/ice/src/Ice/Operation.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\nvar Ice = _ModuleRegistry.module(\"Ice\");\nvar IceGrid = (__webpack_require__(/*! ../IceGrid/Exception */ \"./node_modules/ice/src/IceGrid/Exception.js\").IceGrid);\nvar Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n\nvar iceC_IceGrid_Session_ids = [\"::Glacier2::Session\", \"::Ice::Object\", \"::IceGrid::Session\"];\n\n/**\n * A session object is used by IceGrid clients to allocate and\n * release objects. Client sessions are created either via the\n * {@link Registry} object or via the registry client <code>SessionManager</code>\n * object.\n *\n * @see Registry\n *\n **/\nIceGrid.Session = /*#__PURE__*/function (_Ice$Object) {\n  \"use strict\";\n\n  function _class() {\n    _classCallCheck(this, _class);\n    return _callSuper(this, _class, arguments);\n  }\n  _inherits(_class, _Ice$Object);\n  return _createClass(_class, null, [{\n    key: \"_iceImplements\",\n    get: function get() {\n      return [Glacier2.Session];\n    }\n  }]);\n}(Ice.Object);\nIceGrid.SessionPrx = /*#__PURE__*/function (_Ice$ObjectPrx) {\n  \"use strict\";\n\n  function _class2() {\n    _classCallCheck(this, _class2);\n    return _callSuper(this, _class2, arguments);\n  }\n  _inherits(_class2, _Ice$ObjectPrx);\n  return _createClass(_class2, null, [{\n    key: \"_implements\",\n    get: function get() {\n      return [Glacier2.SessionPrx];\n    }\n  }]);\n}(Ice.ObjectPrx);\nSlice.defineOperations(IceGrid.Session, IceGrid.SessionPrx, iceC_IceGrid_Session_ids, 2, {\n  \"keepAlive\": [, 2, 2,,,,,,,],\n  \"allocateObjectById\": [,,,, [9], [[Ice.Identity]],, [IceGrid.AllocationException, IceGrid.ObjectNotRegisteredException],,],\n  \"allocateObjectByType\": [,,,, [9], [[7]],, [IceGrid.AllocationException],,],\n  \"releaseObject\": [,,,,, [[Ice.Identity]],, [IceGrid.AllocationException, IceGrid.ObjectNotRegisteredException],,],\n  \"setAllocationTimeout\": [, 2, 2,,, [[3]],,,,]\n});\n/* slice2js browser-bundle-skip */\nexports.IceGrid = IceGrid;\n/* slice2js browser-bundle-skip-end */\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/IceGrid/Session.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/IceGrid/UserAccountMapper.js":
/*!***********************************************************!*\
  !*** ./node_modules/ice/src/IceGrid/UserAccountMapper.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `UserAccountMapper.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nvar _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\");\n__webpack_require__(/*! ../Ice/ObjectPrx */ \"./node_modules/ice/src/Ice/ObjectPrx.js\");\n__webpack_require__(/*! ../Ice/Operation */ \"./node_modules/ice/src/Ice/Operation.js\");\n__webpack_require__(/*! ../Ice/Exception */ \"./node_modules/ice/src/Ice/Exception.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\nvar Ice = _ModuleRegistry.module(\"Ice\");\nvar Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n/* slice2js browser-bundle-skip */\n\nvar IceGrid = _ModuleRegistry.module(\"IceGrid\");\n/* slice2js browser-bundle-skip-end */\n\n/**\n * This exception is raised if a user account for a given session\n * identifier can't be found.\n *\n **/\nIceGrid.UserAccountNotFoundException = /*#__PURE__*/function (_Ice$UserException) {\n  \"use strict\";\n\n  function _class() {\n    var _cause = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    _classCallCheck(this, _class);\n    return _callSuper(this, _class, [_cause]);\n  }\n  _inherits(_class, _Ice$UserException);\n  return _createClass(_class, [{\n    key: \"_mostDerivedType\",\n    value: function _mostDerivedType() {\n      return IceGrid.UserAccountNotFoundException;\n    }\n  }], [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.UserException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::IceGrid::UserAccountNotFoundException\";\n    }\n  }]);\n}(Ice.UserException);\nvar iceC_IceGrid_UserAccountMapper_ids = [\"::Ice::Object\", \"::IceGrid::UserAccountMapper\"];\n\n/**\n * A user account mapper object is used by IceGrid nodes to map\n * session identifiers to user accounts.\n *\n **/\nIceGrid.UserAccountMapper = /*#__PURE__*/function (_Ice$Object) {\n  \"use strict\";\n\n  function _class2() {\n    _classCallCheck(this, _class2);\n    return _callSuper(this, _class2, arguments);\n  }\n  _inherits(_class2, _Ice$Object);\n  return _createClass(_class2);\n}(Ice.Object);\nIceGrid.UserAccountMapperPrx = /*#__PURE__*/function (_Ice$ObjectPrx) {\n  \"use strict\";\n\n  function _class3() {\n    _classCallCheck(this, _class3);\n    return _callSuper(this, _class3, arguments);\n  }\n  _inherits(_class3, _Ice$ObjectPrx);\n  return _createClass(_class3);\n}(Ice.ObjectPrx);\nSlice.defineOperations(IceGrid.UserAccountMapper, IceGrid.UserAccountMapperPrx, iceC_IceGrid_UserAccountMapper_ids, 1, {\n  \"getUserAccount\": [,,,, [7], [[7]],, [IceGrid.UserAccountNotFoundException],,]\n});\n/* slice2js browser-bundle-skip */\nexports.IceGrid = IceGrid;\n/* slice2js browser-bundle-skip-end */\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/IceGrid/UserAccountMapper.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/IceStorm/IceStorm.js":
/*!***************************************************!*\
  !*** ./node_modules/ice/src/IceStorm/IceStorm.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `IceStorm.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nvar _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\");\n__webpack_require__(/*! ../Ice/ObjectPrx */ \"./node_modules/ice/src/Ice/ObjectPrx.js\");\n__webpack_require__(/*! ../Ice/Operation */ \"./node_modules/ice/src/Ice/Operation.js\");\n__webpack_require__(/*! ../Ice/Struct */ \"./node_modules/ice/src/Ice/Struct.js\");\n__webpack_require__(/*! ../Ice/Exception */ \"./node_modules/ice/src/Ice/Exception.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\n__webpack_require__(/*! ../Ice/Identity */ \"./node_modules/ice/src/Ice/Identity.js\");\n__webpack_require__(/*! ../Ice/SliceChecksumDict */ \"./node_modules/ice/src/Ice/SliceChecksumDict.js\");\nvar Ice = _ModuleRegistry.module(\"Ice\");\nvar IceMX = (__webpack_require__(/*! ../IceStorm/Metrics */ \"./node_modules/ice/src/IceStorm/Metrics.js\").IceMX);\nvar Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n/* slice2js browser-bundle-skip */\n\nvar IceStorm = _ModuleRegistry.module(\"IceStorm\");\n/* slice2js browser-bundle-skip-end */\n\n/**\n * Information on the topic links.\n *\n **/\nIceStorm.LinkInfo = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function _class() {\n    var theTopic = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    var cost = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    _classCallCheck(this, _class);\n    this.theTopic = theTopic;\n    this.name = name;\n    this.cost = cost;\n  }\n  return _createClass(_class, [{\n    key: \"_write\",\n    value: function _write(ostr) {\n      IceStorm.TopicPrx.write(ostr, this.theTopic);\n      ostr.writeString(this.name);\n      ostr.writeInt(this.cost);\n    }\n  }, {\n    key: \"_read\",\n    value: function _read(istr) {\n      this.theTopic = IceStorm.TopicPrx.read(istr, this.theTopic);\n      this.name = istr.readString();\n      this.cost = istr.readInt();\n    }\n  }], [{\n    key: \"minWireSize\",\n    get: function get() {\n      return 7;\n    }\n  }]);\n}();\nSlice.defineStruct(IceStorm.LinkInfo, false, true);\nSlice.defineSequence(IceStorm, \"LinkInfoSeqHelper\", \"IceStorm.LinkInfo\", false);\nSlice.defineDictionary(IceStorm, \"QoS\", \"QoSHelper\", \"Ice.StringHelper\", \"Ice.StringHelper\", false, undefined, undefined);\n\n/**\n * This exception indicates that an attempt was made to create a link\n * that already exists.\n *\n **/\nIceStorm.LinkExists = /*#__PURE__*/function (_Ice$UserException) {\n  \"use strict\";\n\n  function _class2() {\n    var _this;\n    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class2);\n    _this = _callSuper(this, _class2, [_cause]);\n    _this.name = name;\n    return _this;\n  }\n  _inherits(_class2, _Ice$UserException);\n  return _createClass(_class2, [{\n    key: \"_mostDerivedType\",\n    value: function _mostDerivedType() {\n      return IceStorm.LinkExists;\n    }\n  }, {\n    key: \"_writeMemberImpl\",\n    value: function _writeMemberImpl(ostr) {\n      ostr.writeString(this.name);\n    }\n  }, {\n    key: \"_readMemberImpl\",\n    value: function _readMemberImpl(istr) {\n      this.name = istr.readString();\n    }\n  }], [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.UserException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::IceStorm::LinkExists\";\n    }\n  }]);\n}(Ice.UserException);\n\n/**\n * This exception indicates that an attempt was made to remove a\n * link that does not exist.\n *\n **/\nIceStorm.NoSuchLink = /*#__PURE__*/function (_Ice$UserException2) {\n  \"use strict\";\n\n  function _class3() {\n    var _this2;\n    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class3);\n    _this2 = _callSuper(this, _class3, [_cause]);\n    _this2.name = name;\n    return _this2;\n  }\n  _inherits(_class3, _Ice$UserException2);\n  return _createClass(_class3, [{\n    key: \"_mostDerivedType\",\n    value: function _mostDerivedType() {\n      return IceStorm.NoSuchLink;\n    }\n  }, {\n    key: \"_writeMemberImpl\",\n    value: function _writeMemberImpl(ostr) {\n      ostr.writeString(this.name);\n    }\n  }, {\n    key: \"_readMemberImpl\",\n    value: function _readMemberImpl(istr) {\n      this.name = istr.readString();\n    }\n  }], [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.UserException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::IceStorm::NoSuchLink\";\n    }\n  }]);\n}(Ice.UserException);\n\n/**\n * This exception indicates that an attempt was made to subscribe\n * a proxy for which a subscription already exists.\n *\n **/\nIceStorm.AlreadySubscribed = /*#__PURE__*/function (_Ice$UserException3) {\n  \"use strict\";\n\n  function _class4() {\n    var _cause = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    _classCallCheck(this, _class4);\n    return _callSuper(this, _class4, [_cause]);\n  }\n  _inherits(_class4, _Ice$UserException3);\n  return _createClass(_class4, [{\n    key: \"_mostDerivedType\",\n    value: function _mostDerivedType() {\n      return IceStorm.AlreadySubscribed;\n    }\n  }], [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.UserException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::IceStorm::AlreadySubscribed\";\n    }\n  }]);\n}(Ice.UserException);\n\n/**\n * This exception indicates that an attempt was made to subscribe\n * a proxy that is null.\n *\n **/\nIceStorm.InvalidSubscriber = /*#__PURE__*/function (_Ice$UserException4) {\n  \"use strict\";\n\n  function _class5() {\n    var _this3;\n    var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class5);\n    _this3 = _callSuper(this, _class5, [_cause]);\n    _this3.reason = reason;\n    return _this3;\n  }\n  _inherits(_class5, _Ice$UserException4);\n  return _createClass(_class5, [{\n    key: \"_mostDerivedType\",\n    value: function _mostDerivedType() {\n      return IceStorm.InvalidSubscriber;\n    }\n  }, {\n    key: \"_writeMemberImpl\",\n    value: function _writeMemberImpl(ostr) {\n      ostr.writeString(this.reason);\n    }\n  }, {\n    key: \"_readMemberImpl\",\n    value: function _readMemberImpl(istr) {\n      this.reason = istr.readString();\n    }\n  }], [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.UserException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::IceStorm::InvalidSubscriber\";\n    }\n  }]);\n}(Ice.UserException);\n\n/**\n * This exception indicates that a subscription failed due to an\n * invalid QoS.\n *\n **/\nIceStorm.BadQoS = /*#__PURE__*/function (_Ice$UserException5) {\n  \"use strict\";\n\n  function _class6() {\n    var _this4;\n    var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class6);\n    _this4 = _callSuper(this, _class6, [_cause]);\n    _this4.reason = reason;\n    return _this4;\n  }\n  _inherits(_class6, _Ice$UserException5);\n  return _createClass(_class6, [{\n    key: \"_mostDerivedType\",\n    value: function _mostDerivedType() {\n      return IceStorm.BadQoS;\n    }\n  }, {\n    key: \"_writeMemberImpl\",\n    value: function _writeMemberImpl(ostr) {\n      ostr.writeString(this.reason);\n    }\n  }, {\n    key: \"_readMemberImpl\",\n    value: function _readMemberImpl(istr) {\n      this.reason = istr.readString();\n    }\n  }], [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.UserException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::IceStorm::BadQoS\";\n    }\n  }]);\n}(Ice.UserException);\nvar iceC_IceStorm_Topic_ids = [\"::Ice::Object\", \"::IceStorm::Topic\"];\n\n/**\n * Publishers publish information on a particular topic. A topic\n * logically represents a type.\n *\n * @see TopicManager\n *\n **/\nIceStorm.Topic = /*#__PURE__*/function (_Ice$Object) {\n  \"use strict\";\n\n  function _class7() {\n    _classCallCheck(this, _class7);\n    return _callSuper(this, _class7, arguments);\n  }\n  _inherits(_class7, _Ice$Object);\n  return _createClass(_class7);\n}(Ice.Object);\nIceStorm.TopicPrx = /*#__PURE__*/function (_Ice$ObjectPrx) {\n  \"use strict\";\n\n  function _class8() {\n    _classCallCheck(this, _class8);\n    return _callSuper(this, _class8, arguments);\n  }\n  _inherits(_class8, _Ice$ObjectPrx);\n  return _createClass(_class8);\n}(Ice.ObjectPrx);\nSlice.defineOperations(IceStorm.Topic, IceStorm.TopicPrx, iceC_IceStorm_Topic_ids, 1, {\n  \"getName\": [, 2, 1,, [7],,,,,],\n  \"getPublisher\": [, 2, 1,, [9],,,,,],\n  \"getNonReplicatedPublisher\": [, 2, 1,, [9],,,,,],\n  \"subscribeAndGetPublisher\": [,,,, [9], [[\"IceStorm.QoSHelper\"], [9]],, [IceStorm.AlreadySubscribed, IceStorm.BadQoS, IceStorm.InvalidSubscriber],,],\n  \"unsubscribe\": [, 2, 2,,, [[9]],,,,],\n  \"link\": [,,,,, [[\"IceStorm.TopicPrx\"], [3]],, [IceStorm.LinkExists],,],\n  \"unlink\": [,,,,, [[\"IceStorm.TopicPrx\"]],, [IceStorm.NoSuchLink],,],\n  \"getLinkInfoSeq\": [, 2, 1,, [\"IceStorm.LinkInfoSeqHelper\"],,,,,],\n  \"getSubscribers\": [,,,, [\"Ice.IdentitySeqHelper\"],,,,,],\n  \"destroy\": [,,,,,,,,,]\n});\nSlice.defineDictionary(IceStorm, \"TopicDict\", \"TopicDictHelper\", \"Ice.StringHelper\", \"IceStorm.TopicPrx\", false, undefined, undefined);\n\n/**\n * This exception indicates that an attempt was made to create a topic\n * that already exists.\n *\n **/\nIceStorm.TopicExists = /*#__PURE__*/function (_Ice$UserException6) {\n  \"use strict\";\n\n  function _class9() {\n    var _this5;\n    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class9);\n    _this5 = _callSuper(this, _class9, [_cause]);\n    _this5.name = name;\n    return _this5;\n  }\n  _inherits(_class9, _Ice$UserException6);\n  return _createClass(_class9, [{\n    key: \"_mostDerivedType\",\n    value: function _mostDerivedType() {\n      return IceStorm.TopicExists;\n    }\n  }, {\n    key: \"_writeMemberImpl\",\n    value: function _writeMemberImpl(ostr) {\n      ostr.writeString(this.name);\n    }\n  }, {\n    key: \"_readMemberImpl\",\n    value: function _readMemberImpl(istr) {\n      this.name = istr.readString();\n    }\n  }], [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.UserException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::IceStorm::TopicExists\";\n    }\n  }]);\n}(Ice.UserException);\n\n/**\n * This exception indicates that an attempt was made to retrieve a\n * topic that does not exist.\n *\n **/\nIceStorm.NoSuchTopic = /*#__PURE__*/function (_Ice$UserException7) {\n  \"use strict\";\n\n  function _class0() {\n    var _this6;\n    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, _class0);\n    _this6 = _callSuper(this, _class0, [_cause]);\n    _this6.name = name;\n    return _this6;\n  }\n  _inherits(_class0, _Ice$UserException7);\n  return _createClass(_class0, [{\n    key: \"_mostDerivedType\",\n    value: function _mostDerivedType() {\n      return IceStorm.NoSuchTopic;\n    }\n  }, {\n    key: \"_writeMemberImpl\",\n    value: function _writeMemberImpl(ostr) {\n      ostr.writeString(this.name);\n    }\n  }, {\n    key: \"_readMemberImpl\",\n    value: function _readMemberImpl(istr) {\n      this.name = istr.readString();\n    }\n  }], [{\n    key: \"_parent\",\n    get: function get() {\n      return Ice.UserException;\n    }\n  }, {\n    key: \"_id\",\n    get: function get() {\n      return \"::IceStorm::NoSuchTopic\";\n    }\n  }]);\n}(Ice.UserException);\nvar iceC_IceStorm_TopicManager_ids = [\"::Ice::Object\", \"::IceStorm::TopicManager\"];\n\n/**\n * A topic manager manages topics, and subscribers to topics.\n *\n * @see Topic\n *\n **/\nIceStorm.TopicManager = /*#__PURE__*/function (_Ice$Object2) {\n  \"use strict\";\n\n  function _class1() {\n    _classCallCheck(this, _class1);\n    return _callSuper(this, _class1, arguments);\n  }\n  _inherits(_class1, _Ice$Object2);\n  return _createClass(_class1);\n}(Ice.Object);\nIceStorm.TopicManagerPrx = /*#__PURE__*/function (_Ice$ObjectPrx2) {\n  \"use strict\";\n\n  function _class10() {\n    _classCallCheck(this, _class10);\n    return _callSuper(this, _class10, arguments);\n  }\n  _inherits(_class10, _Ice$ObjectPrx2);\n  return _createClass(_class10);\n}(Ice.ObjectPrx);\nSlice.defineOperations(IceStorm.TopicManager, IceStorm.TopicManagerPrx, iceC_IceStorm_TopicManager_ids, 1, {\n  \"create\": [,,,, [\"IceStorm.TopicPrx\"], [[7]],, [IceStorm.TopicExists],,],\n  \"retrieve\": [, 2, 1,, [\"IceStorm.TopicPrx\"], [[7]],, [IceStorm.NoSuchTopic],,],\n  \"retrieveAll\": [, 2, 1,, [\"IceStorm.TopicDictHelper\"],,,,,],\n  \"getSliceChecksums\": [, 2, 1,, [\"Ice.SliceChecksumDictHelper\"],,,,,]\n});\nvar iceC_IceStorm_Finder_ids = [\"::Ice::Object\", \"::IceStorm::Finder\"];\n\n/**\n * This inferface is advertised by the IceStorm service through the\n * Ice object with the identity `IceStorm/Finder'. This allows clients\n * to retrieve the topic manager with just the endpoint information of\n * the IceStorm service.\n *\n **/\nIceStorm.Finder = /*#__PURE__*/function (_Ice$Object3) {\n  \"use strict\";\n\n  function _class11() {\n    _classCallCheck(this, _class11);\n    return _callSuper(this, _class11, arguments);\n  }\n  _inherits(_class11, _Ice$Object3);\n  return _createClass(_class11);\n}(Ice.Object);\nIceStorm.FinderPrx = /*#__PURE__*/function (_Ice$ObjectPrx3) {\n  \"use strict\";\n\n  function _class12() {\n    _classCallCheck(this, _class12);\n    return _callSuper(this, _class12, arguments);\n  }\n  _inherits(_class12, _Ice$ObjectPrx3);\n  return _createClass(_class12);\n}(Ice.ObjectPrx);\nSlice.defineOperations(IceStorm.Finder, IceStorm.FinderPrx, iceC_IceStorm_Finder_ids, 1, {\n  \"getTopicManager\": [,,,, [\"IceStorm.TopicManagerPrx\"],,,,,]\n});\n/* slice2js browser-bundle-skip */\nexports.IceStorm = IceStorm;\n/* slice2js browser-bundle-skip-end */\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/IceStorm/IceStorm.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/IceStorm/Metrics.js":
/*!**************************************************!*\
  !*** ./node_modules/ice/src/IceStorm/Metrics.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `Metrics.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nvar _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\");\n__webpack_require__(/*! ../Ice/ObjectPrx */ \"./node_modules/ice/src/Ice/ObjectPrx.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\nvar Ice = _ModuleRegistry.module(\"Ice\");\nvar IceMX = (__webpack_require__(/*! ../Ice/Metrics */ \"./node_modules/ice/src/Ice/Metrics.js\").IceMX);\nvar Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n\nvar iceC_IceMX_TopicMetrics_ids = [\"::Ice::Object\", \"::IceMX::Metrics\", \"::IceMX::TopicMetrics\"];\n\n/**\n * Provides information on IceStorm topics.\n *\n **/\nIceMX.TopicMetrics = /*#__PURE__*/function (_IceMX$Metrics) {\n  \"use strict\";\n\n  function _class(id, total, current, totalLifetime, failures) {\n    var _this;\n    var published = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : new Ice.Long(0, 0);\n    var forwarded = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : new Ice.Long(0, 0);\n    _classCallCheck(this, _class);\n    _this = _callSuper(this, _class, [id, total, current, totalLifetime, failures]);\n    _this.published = published;\n    _this.forwarded = forwarded;\n    return _this;\n  }\n  _inherits(_class, _IceMX$Metrics);\n  return _createClass(_class, [{\n    key: \"_iceWriteMemberImpl\",\n    value: function _iceWriteMemberImpl(ostr) {\n      ostr.writeLong(this.published);\n      ostr.writeLong(this.forwarded);\n    }\n  }, {\n    key: \"_iceReadMemberImpl\",\n    value: function _iceReadMemberImpl(istr) {\n      this.published = istr.readLong();\n      this.forwarded = istr.readLong();\n    }\n  }]);\n}(IceMX.Metrics);\nSlice.defineValue(IceMX.TopicMetrics, iceC_IceMX_TopicMetrics_ids[2], false);\nvar iceC_IceMX_SubscriberMetrics_ids = [\"::Ice::Object\", \"::IceMX::Metrics\", \"::IceMX::SubscriberMetrics\"];\n\n/**\n * Provides information on IceStorm subscribers.\n *\n **/\nIceMX.SubscriberMetrics = /*#__PURE__*/function (_IceMX$Metrics2) {\n  \"use strict\";\n\n  function _class2(id, total, current, totalLifetime, failures) {\n    var _this2;\n    var queued = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n    var outstanding = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n    var delivered = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : new Ice.Long(0, 0);\n    _classCallCheck(this, _class2);\n    _this2 = _callSuper(this, _class2, [id, total, current, totalLifetime, failures]);\n    _this2.queued = queued;\n    _this2.outstanding = outstanding;\n    _this2.delivered = delivered;\n    return _this2;\n  }\n  _inherits(_class2, _IceMX$Metrics2);\n  return _createClass(_class2, [{\n    key: \"_iceWriteMemberImpl\",\n    value: function _iceWriteMemberImpl(ostr) {\n      ostr.writeInt(this.queued);\n      ostr.writeInt(this.outstanding);\n      ostr.writeLong(this.delivered);\n    }\n  }, {\n    key: \"_iceReadMemberImpl\",\n    value: function _iceReadMemberImpl(istr) {\n      this.queued = istr.readInt();\n      this.outstanding = istr.readInt();\n      this.delivered = istr.readLong();\n    }\n  }]);\n}(IceMX.Metrics);\nSlice.defineValue(IceMX.SubscriberMetrics, iceC_IceMX_SubscriberMetrics_ids[2], false);\n/* slice2js browser-bundle-skip */\nexports.IceMX = IceMX;\n/* slice2js browser-bundle-skip-end */\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/IceStorm/Metrics.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/index.js":
/*!***************************************!*\
  !*** ./node_modules/ice/src/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nmodule.exports.Ice = __webpack_require__(/*! ./Ice/Ice */ \"./node_modules/ice/src/Ice/Ice.js\").Ice;\nmodule.exports.IceMX = __webpack_require__(/*! ./Ice/Ice */ \"./node_modules/ice/src/Ice/Ice.js\").IceMX;\nmodule.exports.IceSSL = __webpack_require__(/*! ./Ice/Ice */ \"./node_modules/ice/src/Ice/Ice.js\").IceSSL;\nmodule.exports.Glacier2 = __webpack_require__(/*! ./Glacier2/Glacier2 */ \"./node_modules/ice/src/Glacier2/Glacier2.js\").Glacier2;\nmodule.exports.IceGrid = __webpack_require__(/*! ./IceGrid/IceGrid */ \"./node_modules/ice/src/IceGrid/IceGrid.js\").IceGrid;\nmodule.exports.IceStorm = __webpack_require__(/*! ./IceStorm/IceStorm */ \"./node_modules/ice/src/IceStorm/IceStorm.js\").IceStorm;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/ice/src/index.js?\n}");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";
eval("{\n\nvar stylesInDOM = [];\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n  return result;\n}\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n    identifiers.push(identifier);\n  }\n  return identifiers;\n}\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n  return updater;\n}\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n    var newLastIdentifiers = modulesToDom(newList, options);\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n      var _index = getIndexByIdentifier(_identifier);\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n    lastIdentifiers = newLastIdentifiers;\n  };\n};\n\n//# sourceURL=webpack://chat-web-client/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?\n}");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";
eval("{\n\nvar memo = {};\n\n/* istanbul ignore next  */\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target);\n\n    // Special case to return head of iframe instead of iframe itself\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n    memo[target] = styleTarget;\n  }\n  return memo[target];\n}\n\n/* istanbul ignore next  */\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n  if (!target) {\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n  }\n  target.appendChild(style);\n}\nmodule.exports = insertBySelector;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/style-loader/dist/runtime/insertBySelector.js?\n}");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";
eval("{\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement(\"style\");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\nmodule.exports = insertStyleElement;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/style-loader/dist/runtime/insertStyleElement.js?\n}");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("{\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce =  true ? __webpack_require__.nc : 0;\n  if (nonce) {\n    styleElement.setAttribute(\"nonce\", nonce);\n  }\n}\nmodule.exports = setAttributesWithoutAttributes;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js?\n}");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";
eval("{\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = \"\";\n  if (obj.supports) {\n    css += \"@supports (\".concat(obj.supports, \") {\");\n  }\n  if (obj.media) {\n    css += \"@media \".concat(obj.media, \" {\");\n  }\n  var needLayer = typeof obj.layer !== \"undefined\";\n  if (needLayer) {\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\n  }\n  css += obj.css;\n  if (needLayer) {\n    css += \"}\";\n  }\n  if (obj.media) {\n    css += \"}\";\n  }\n  if (obj.supports) {\n    css += \"}\";\n  }\n  var sourceMap = obj.sourceMap;\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  }\n\n  // For old IE\n  /* istanbul ignore if  */\n  options.styleTagTransform(css, styleElement, options.options);\n}\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n  styleElement.parentNode.removeChild(styleElement);\n}\n\n/* istanbul ignore next  */\nfunction domAPI(options) {\n  if (typeof document === \"undefined\") {\n    return {\n      update: function update() {},\n      remove: function remove() {}\n    };\n  }\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\nmodule.exports = domAPI;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/style-loader/dist/runtime/styleDomAPI.js?\n}");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";
eval("{\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\nmodule.exports = styleTagTransform;\n\n//# sourceURL=webpack://chat-web-client/./node_modules/style-loader/dist/runtime/styleTagTransform.js?\n}");

/***/ }),

/***/ "./src/generated/Chat.js":
/*!*******************************!*\
  !*** ./src/generated/Chat.js ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `Chat.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n(function (module, require, exports) {\n  var Ice = require(\"ice\").Ice;\n  var _ModuleRegistry = Ice._ModuleRegistry;\n  var Slice = Ice.Slice;\n  var Chat = _ModuleRegistry.module(\"Chat\");\n  Chat.Message = /*#__PURE__*/function () {\n    \"use strict\";\n\n    function _class() {\n      var from = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n      var content = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n      var timestamp = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new Ice.Long(0, 0);\n      var isGroup = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n      _classCallCheck(this, _class);\n      this.from = from;\n      this.to = to;\n      this.content = content;\n      this.timestamp = timestamp;\n      this.isGroup = isGroup;\n    }\n    return _createClass(_class, [{\n      key: \"_write\",\n      value: function _write(ostr) {\n        ostr.writeString(this.from);\n        ostr.writeString(this.to);\n        ostr.writeString(this.content);\n        ostr.writeLong(this.timestamp);\n        ostr.writeBool(this.isGroup);\n      }\n    }, {\n      key: \"_read\",\n      value: function _read(istr) {\n        this.from = istr.readString();\n        this.to = istr.readString();\n        this.content = istr.readString();\n        this.timestamp = istr.readLong();\n        this.isGroup = istr.readBool();\n      }\n    }], [{\n      key: \"minWireSize\",\n      get: function get() {\n        return 12;\n      }\n    }]);\n  }();\n  Slice.defineStruct(Chat.Message, true, true);\n  Chat.User = /*#__PURE__*/function () {\n    \"use strict\";\n\n    function _class2() {\n      var username = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n      var isOnline = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      _classCallCheck(this, _class2);\n      this.username = username;\n      this.isOnline = isOnline;\n    }\n    return _createClass(_class2, [{\n      key: \"_write\",\n      value: function _write(ostr) {\n        ostr.writeString(this.username);\n        ostr.writeBool(this.isOnline);\n      }\n    }, {\n      key: \"_read\",\n      value: function _read(istr) {\n        this.username = istr.readString();\n        this.isOnline = istr.readBool();\n      }\n    }], [{\n      key: \"minWireSize\",\n      get: function get() {\n        return 2;\n      }\n    }]);\n  }();\n  Slice.defineStruct(Chat.User, true, true);\n  Slice.defineSequence(Chat, \"MessageSeqHelper\", \"Chat.Message\", false);\n  Slice.defineSequence(Chat, \"UserSeqHelper\", \"Chat.User\", false);\n  Slice.defineSequence(Chat, \"StringSeqHelper\", \"Ice.StringHelper\", false);\n  Slice.defineSequence(Chat, \"ByteSeqHelper\", \"Ice.ByteHelper\", true);\n  Chat.GroupInfo = /*#__PURE__*/function () {\n    \"use strict\";\n\n    function _class3() {\n      var groupName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n      var members = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      _classCallCheck(this, _class3);\n      this.groupName = groupName;\n      this.members = members;\n    }\n    return _createClass(_class3, [{\n      key: \"_write\",\n      value: function _write(ostr) {\n        ostr.writeString(this.groupName);\n        Chat.StringSeqHelper.write(ostr, this.members);\n      }\n    }, {\n      key: \"_read\",\n      value: function _read(istr) {\n        this.groupName = istr.readString();\n        this.members = Chat.StringSeqHelper.read(istr);\n      }\n    }], [{\n      key: \"minWireSize\",\n      get: function get() {\n        return 2;\n      }\n    }]);\n  }();\n  Slice.defineStruct(Chat.GroupInfo, true, true);\n  Slice.defineDictionary(Chat, \"UserStatusMap\", \"UserStatusMapHelper\", \"Ice.StringHelper\", \"Ice.BoolHelper\", false, undefined, undefined);\n  var iceC_Chat_ChatCallback_ids = [\"::Chat::ChatCallback\", \"::Ice::Object\"];\n  Chat.ChatCallback = /*#__PURE__*/function (_Ice$Object) {\n    \"use strict\";\n\n    function _class4() {\n      _classCallCheck(this, _class4);\n      return _callSuper(this, _class4, arguments);\n    }\n    _inherits(_class4, _Ice$Object);\n    return _createClass(_class4);\n  }(Ice.Object);\n  Chat.ChatCallbackPrx = /*#__PURE__*/function (_Ice$ObjectPrx) {\n    \"use strict\";\n\n    function _class5() {\n      _classCallCheck(this, _class5);\n      return _callSuper(this, _class5, arguments);\n    }\n    _inherits(_class5, _Ice$ObjectPrx);\n    return _createClass(_class5);\n  }(Ice.ObjectPrx);\n  Slice.defineOperations(Chat.ChatCallback, Chat.ChatCallbackPrx, iceC_Chat_ChatCallback_ids, 0, {\n    \"onNewMessage\": [,,,,, [[Chat.Message]],,,,],\n    \"onUserStatusChanged\": [,,,,, [[Chat.User]],,,,],\n    \"onGroupMemberAdded\": [,,,,, [[7], [7]],,,,],\n    \"onVoiceNoteReceived\": [,,,,, [[7], [7], [\"Chat.ByteSeqHelper\"], [1]],,,,],\n    \"onIncomingCall\": [,,,,, [[7]],,,,],\n    \"onWebRTCSignal\": [,,,,, [[7], [7], [7]],,,,],\n    \"onICECandidate\": [,,,,, [[7], [7]],,,,],\n    \"onCallEnded\": [,,,,, [[7]],,,,],\n    \"onAudioChunk\": [,,,,, [[7], [\"Chat.ByteSeqHelper\"]],,,,],\n    \"onCallAccepted\": [,,,,, [[7]],,,,]\n  });\n  Chat.Response = /*#__PURE__*/function () {\n    \"use strict\";\n\n    function _class6() {\n      var success = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n      _classCallCheck(this, _class6);\n      this.success = success;\n      this.message = message;\n    }\n    return _createClass(_class6, [{\n      key: \"_write\",\n      value: function _write(ostr) {\n        ostr.writeBool(this.success);\n        ostr.writeString(this.message);\n      }\n    }, {\n      key: \"_read\",\n      value: function _read(istr) {\n        this.success = istr.readBool();\n        this.message = istr.readString();\n      }\n    }], [{\n      key: \"minWireSize\",\n      get: function get() {\n        return 2;\n      }\n    }]);\n  }();\n  Slice.defineStruct(Chat.Response, true, true);\n  var iceC_Chat_ChatService_ids = [\"::Chat::ChatService\", \"::Ice::Object\"];\n  Chat.ChatService = /*#__PURE__*/function (_Ice$Object2) {\n    \"use strict\";\n\n    function _class7() {\n      _classCallCheck(this, _class7);\n      return _callSuper(this, _class7, arguments);\n    }\n    _inherits(_class7, _Ice$Object2);\n    return _createClass(_class7);\n  }(Ice.Object);\n  Chat.ChatServicePrx = /*#__PURE__*/function (_Ice$ObjectPrx2) {\n    \"use strict\";\n\n    function _class8() {\n      _classCallCheck(this, _class8);\n      return _callSuper(this, _class8, arguments);\n    }\n    _inherits(_class8, _Ice$ObjectPrx2);\n    return _createClass(_class8);\n  }(Ice.ObjectPrx);\n  Slice.defineOperations(Chat.ChatService, Chat.ChatServicePrx, iceC_Chat_ChatService_ids, 0, {\n    \"login\": [,,,, [Chat.Response], [[7], [\"Chat.ChatCallbackPrx\"]],,,,],\n    \"logout\": [,,,, [Chat.Response], [[7]],,,,],\n    \"getOnlineUsers\": [,,,, [\"Chat.StringSeqHelper\"],,,,,],\n    \"getAllUsers\": [,,,, [\"Chat.UserStatusMapHelper\"],,,,,],\n    \"sendMessageToUser\": [,,,, [Chat.Response], [[7], [7], [7]],,,,],\n    \"sendMessageToGroup\": [,,,, [Chat.Response], [[7], [7], [7]],,,,],\n    \"getPendingMessages\": [,,,, [\"Chat.MessageSeqHelper\"], [[7]],,,,],\n    \"createGroup\": [,,,, [Chat.Response], [[7], [7]],,,,],\n    \"addToGroup\": [,,,, [Chat.Response], [[7], [7]],,,,],\n    \"getGroups\": [,,,, [\"Chat.StringSeqHelper\"],,,,,],\n    \"getUserGroups\": [,,,, [\"Chat.StringSeqHelper\"], [[7]],,,,],\n    \"getGroupMembers\": [,,,, [\"Chat.StringSeqHelper\"], [[7]],,,,],\n    \"getHistory\": [,,,, [\"Chat.StringSeqHelper\"], [[7]],,,,],\n    \"sendVoiceNoteToUser\": [,,,, [Chat.Response], [[7], [7], [\"Chat.ByteSeqHelper\"]],,,,],\n    \"sendVoiceNoteToGroup\": [,,,, [Chat.Response], [[7], [7], [\"Chat.ByteSeqHelper\"]],,,,],\n    \"initiateCall\": [,,,, [Chat.Response], [[7], [7]],,,,],\n    \"sendWebRTCSignal\": [,,,, [Chat.Response], [[7], [7], [7], [7]],,,,],\n    \"sendICECandidate\": [,,,, [Chat.Response], [[7], [7], [7]],,,,],\n    \"endCall\": [,,,, [Chat.Response], [[7], [7]],,,,],\n    \"sendAudioChunk\": [,,,, [Chat.Response], [[7], [7], [\"Chat.ByteSeqHelper\"]],,,,],\n    \"acceptCall\": [,,,, [Chat.Response], [[7], [7]],,,,]\n  });\n  exports.Chat = Chat;\n})(typeof global !== \"undefined\" && typeof global.process !== \"undefined\" ? module : undefined, typeof global !== \"undefined\" && typeof global.process !== \"undefined\" ? require : typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope ? self.Ice._require : window.Ice._require, typeof global !== \"undefined\" && typeof global.process !== \"undefined\" ? exports : typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope ? self : window);\n\n//# sourceURL=webpack://chat-web-client/./src/generated/Chat.js?\n}");

/***/ }),

/***/ "./src/pages/Chat.js":
/*!***************************!*\
  !*** ./src/pages/Chat.js ***!
  \***************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _router_Router_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../router/Router.js */ \"./src/router/Router.js\");\n/* harmony import */ var _services_iceDelegate_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../services/iceDelegate.js */ \"./src/services/iceDelegate.js\");\n/* harmony import */ var _services_audioRecorder_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../services/audioRecorder.js */ \"./src/services/audioRecorder.js\");\n/* harmony import */ var _services_webrtcService_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../services/webrtcService.js */ \"./src/services/webrtcService.js\");\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = \"function\" == typeof Symbol ? Symbol : {}, n = r.iterator || \"@@iterator\", o = r.toStringTag || \"@@toStringTag\"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, \"_invoke\", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError(\"Generator is already running\"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = \"next\"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError(\"iterator result is not an object\"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i[\"return\"]) && t.call(i), c < 2 && (u = TypeError(\"The iterator does not provide a '\" + o + \"' method\"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, \"GeneratorFunction\")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, \"constructor\", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = \"GeneratorFunction\", _regeneratorDefine2(GeneratorFunctionPrototype, o, \"GeneratorFunction\"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, \"Generator\"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, \"toString\", function () { return \"[object Generator]\"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }\nfunction _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, \"\", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o(\"next\", 0), o(\"throw\", 1), o(\"return\", 2)); }, _regeneratorDefine2(e, r, n, t); }\nfunction asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"next\", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"throw\", n); } _next(void 0); }); }; }\n\n\n\n\nfunction Chat() {\n  var username = sessionStorage.getItem('username');\n  if (!username) {\n    window.location.href = '/';\n    return document.createElement('div');\n  }\n  var container = document.createElement('div');\n  container.className = 'chat-container';\n\n  // Sidebar\n  var sidebar = createSidebar(username);\n  container.appendChild(sidebar);\n\n  // Chat Area\n  var chatArea = createChatArea();\n  container.appendChild(chatArea);\n\n  // Initialize connection\n  initializeChat(username);\n  return container;\n}\nfunction createSidebar(username) {\n  var sidebar = document.createElement('div');\n  sidebar.className = 'sidebar';\n\n  // Header\n  var header = document.createElement('div');\n  header.className = 'sidebar-header';\n  var userTitle = document.createElement('h2');\n  userTitle.innerText = username;\n  header.appendChild(userTitle);\n  var status = document.createElement('p');\n  status.innerText = ' Chat';\n  header.appendChild(status);\n  sidebar.appendChild(header);\n\n  // Tabs\n  var tabs = document.createElement('div');\n  tabs.className = 'sidebar-tabs';\n  var usersTab = document.createElement('button');\n  usersTab.innerText = 'Users';\n  usersTab.className = 'active';\n  usersTab.onclick = function () {\n    usersTab.classList.add('active');\n    groupsTab.classList.remove('active');\n    showUsers();\n  };\n  var groupsTab = document.createElement('button');\n  groupsTab.innerText = 'Groups';\n  groupsTab.onclick = function () {\n    groupsTab.classList.add('active');\n    usersTab.classList.remove('active');\n    showGroups();\n  };\n  tabs.appendChild(usersTab);\n  tabs.appendChild(groupsTab);\n  sidebar.appendChild(tabs);\n\n  // Content\n  var content = document.createElement('div');\n  content.className = 'sidebar-content';\n  content.id = 'sidebar-content';\n  sidebar.appendChild(content);\n  return sidebar;\n}\nfunction createChatArea() {\n  var chatArea = document.createElement('div');\n  chatArea.className = 'chat-area';\n\n  // Header\n  var header = document.createElement('div');\n  header.className = 'chat-header';\n  var title = document.createElement('h3');\n  title.id = 'chat-title';\n  title.innerText = 'Select a conversation';\n  header.appendChild(title);\n\n  // Botn de llamada\n  var callButton = document.createElement('button');\n  callButton.className = 'call-btn';\n  callButton.innerHTML = '';\n  callButton.title = 'Iniciar llamada';\n  callButton.id = 'call-button';\n  callButton.style.display = 'none'; // Oculto por defecto\n  callButton.onclick = handleCallButton;\n  header.appendChild(callButton);\n  chatArea.appendChild(header);\n\n  // Contenedor de llamada (videos)\n  var callContainer = document.createElement('div');\n  callContainer.className = 'call-container';\n  callContainer.id = 'callContainer';\n  callContainer.style.display = 'none';\n  chatArea.appendChild(callContainer);\n\n  // Messages\n  var messages = document.createElement('div');\n  messages.className = 'chat-messages';\n  messages.id = 'chat-messages';\n  chatArea.appendChild(messages);\n\n  // Input (inicialmente oculto)\n  var inputArea = document.createElement('div');\n  inputArea.className = 'chat-input';\n  inputArea.id = 'chat-input-area';\n  inputArea.style.display = 'none'; // Oculto por defecto\n\n  // Botn de grabacin de audio\n  var voiceButton = document.createElement('button');\n  voiceButton.className = 'voice-btn';\n  voiceButton.innerHTML = '';\n  voiceButton.title = 'Grabar nota de voz';\n  voiceButton.onclick = toggleVoiceRecording;\n  var input = document.createElement('input');\n  input.type = 'text';\n  input.placeholder = 'Type a message...';\n  input.id = 'message-input';\n  input.onkeypress = function (e) {\n    if (e.key === 'Enter') {\n      sendMessage();\n    }\n  };\n  var sendBtn = document.createElement('button');\n  sendBtn.innerText = 'Send';\n  sendBtn.onclick = sendMessage;\n  inputArea.appendChild(voiceButton);\n  inputArea.appendChild(input);\n  inputArea.appendChild(sendBtn);\n  chatArea.appendChild(inputArea);\n  return chatArea;\n}\nfunction initializeChat(_x) {\n  return _initializeChat.apply(this, arguments);\n}\nfunction _initializeChat() {\n  _initializeChat = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(username) {\n    var loginResult, _t2;\n    return _regenerator().w(function (_context2) {\n      while (1) switch (_context2.p = _context2.n) {\n        case 0:\n          _context2.p = 0;\n          console.log('[CHAT]  Inicializando Ice para usuario:', username);\n\n          // Inicializar Ice con callbacks para notificaciones en tiempo real\n          _context2.n = 1;\n          return (0,_services_iceDelegate_js__WEBPACK_IMPORTED_MODULE_1__.initIce)(username, {\n            // Callback: mensaje nuevo recibido\n            onMessageReceived: function onMessageReceived(msg) {\n              console.log('[CHAT]  Mensaje recibido via Ice:', msg);\n              processIncomingMessageFromIce(msg);\n            },\n            // Callback: cambio de estado de usuario\n            onUserStatusChanged: function onUserStatusChanged(user) {\n              console.log('[CHAT]  Estado de usuario cambi:', user);\n              updateUserStatusInUI(user);\n            },\n            // Callback: nuevo miembro agregado a grupo\n            onGroupMemberAdded: function onGroupMemberAdded(groupName, username) {\n              console.log('[CHAT]  Miembro agregado al grupo:', groupName, username);\n              refreshGroupIfVisible(groupName);\n            },\n            // Callback: nota de voz recibida\n            onVoiceNoteReceived: function onVoiceNoteReceived(from, to, audioData, isGroup) {\n              console.log('[CHAT]  Nota de voz recibida de:', from, 'para:', to, 'isGroup:', isGroup);\n              playReceivedVoiceNote(from, to, audioData, isGroup);\n            },\n            // Callbacks de llamadas WebRTC\n            onIncomingCall: function onIncomingCall(from) {\n              console.log('[CHAT]  Llamada entrante de:', from);\n              handleIncomingCall(from);\n            },\n            onWebRTCSignal: function onWebRTCSignal(from, signalType, signalData) {\n              console.log('[CHAT]  Seal WebRTC de:', from, 'tipo:', signalType);\n              // Ya no se usa con WebSocket\n            },\n            onICECandidate: function onICECandidate(from, candidate) {\n              console.log('[CHAT]  Candidato ICE de:', from);\n              // Ya no se usa con WebSocket\n            },\n            onCallEnded: function onCallEnded(from) {\n              console.log('[CHAT]  Llamada terminada por:', from);\n              endCallUI();\n            },\n            // Nuevos callbacks para audio streaming\n            onAudioChunk: function onAudioChunk(from, audioData) {\n              console.log('[CHAT]  Audio chunk recibido de:', from, 'tamao:', audioData.length);\n              (0,_services_webrtcService_js__WEBPACK_IMPORTED_MODULE_3__.receiveAudioChunk)(audioData);\n            },\n            onCallAccepted: function onCallAccepted(from) {\n              console.log('[CHAT]  Llamada aceptada por:', from);\n              showCallActiveUI(from);\n            }\n          });\n        case 1:\n          loginResult = _context2.v;\n          if (loginResult.success) {\n            _context2.n = 2;\n            break;\n          }\n          alert('Error al conectar con Ice: ' + loginResult.message);\n          return _context2.a(2);\n        case 2:\n          console.log('[CHAT]  Conectado a Ice:', loginResult.message);\n\n          // Inicializar WebRTC\n          (0,_services_webrtcService_js__WEBPACK_IMPORTED_MODULE_3__.initWebRTC)(username);\n          console.log('[CHAT]  WebRTC inicializado');\n\n          // Cargar usuarios\n          _context2.n = 3;\n          return showUsers();\n        case 3:\n          // NO MS POLLING - Ice usa notificaciones push en tiempo real\n          // El servidor enviar mensajes automticamente via callbacks\n          console.log('[CHAT]  Sistema de tiempo real activo (sin polling)');\n\n          // Cargar historial de mensajes\n          _context2.n = 4;\n          return loadMessageHistory(username);\n        case 4:\n          // Verificar soporte de audio\n          if ((0,_services_audioRecorder_js__WEBPACK_IMPORTED_MODULE_2__.isAudioRecordingSupported)()) {\n            console.log('[CHAT]  Grabacin de audio soportada');\n          } else {\n            console.warn('[CHAT]  Grabacin de audio NO soportada en este navegador');\n          }\n          _context2.n = 6;\n          break;\n        case 5:\n          _context2.p = 5;\n          _t2 = _context2.v;\n          console.error('[CHAT]  Error inicializando chat:', _t2);\n          alert('Error al conectar con el servidor Ice: ' + _t2.message);\n        case 6:\n          return _context2.a(2);\n      }\n    }, _callee2, null, [[0, 5]]);\n  }));\n  return _initializeChat.apply(this, arguments);\n}\nfunction loadMessageHistory(_x2) {\n  return _loadMessageHistory.apply(this, arguments);\n} // ============================================\n// POLLING ELIMINADO - Ice usa push notifications\n// ============================================\n// Ya no se necesita polling, Ice enva mensajes en tiempo real via callbacks\n// El servidor llama directamente a onMessageReceived cuando llega un mensaje\n/**\r\n * Procesar mensaje recibido desde Ice callback (tiempo real)\r\n */\nfunction _loadMessageHistory() {\n  _loadMessageHistory = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3(username) {\n    var result, _t3;\n    return _regenerator().w(function (_context3) {\n      while (1) switch (_context3.p = _context3.n) {\n        case 0:\n          _context3.p = 0;\n          _context3.n = 1;\n          return (0,_services_iceDelegate_js__WEBPACK_IMPORTED_MODULE_1__.getHistory)(username);\n        case 1:\n          result = _context3.v;\n          if (result.success && result.history) {\n            console.log('[DEBUG] Loading history, total entries:', result.history.length);\n\n            // Procesar mensajes histricos\n            result.history.forEach(function (entry) {\n              try {\n                var _entry$match, _entry$match2, _entry$match3;\n                // Parsear el registro (formato: {type:text,from:X,target:Y,isGroup:false,msg:...,ts:...})\n                var from = (_entry$match = entry.match(/from:([^,]+)/)) === null || _entry$match === void 0 ? void 0 : _entry$match[1];\n                var target = (_entry$match2 = entry.match(/target:([^,]+)/)) === null || _entry$match2 === void 0 ? void 0 : _entry$match2[1];\n                var isGroup = entry.includes('isGroup:true');\n                var msg = (_entry$match3 = entry.match(/msg:([^,]+)/)) === null || _entry$match3 === void 0 ? void 0 : _entry$match3[1];\n                if (!from || !target || !msg) return;\n\n                // Determinar la clave del chat\n                var chatKey;\n                var messageFrom;\n                if (isGroup) {\n                  chatKey = \"group_\".concat(target);\n                  messageFrom = from;\n                } else {\n                  // Para mensajes privados, la clave es el otro usuario\n                  chatKey = from === username ? \"user_\".concat(target) : \"user_\".concat(from);\n                  messageFrom = from;\n                }\n\n                // Agregar al cache SIN DUPLICAR\n                if (!messageCache[chatKey]) {\n                  messageCache[chatKey] = [];\n                }\n\n                // Verificar si el mensaje ya existe (por contenido y from)\n                var isDuplicate = messageCache[chatKey].some(function (m) {\n                  return m.from === messageFrom && m.content === msg;\n                });\n                if (!isDuplicate) {\n                  messageCache[chatKey].push({\n                    from: messageFrom,\n                    content: msg,\n                    isSent: from === username,\n                    timestamp: new Date()\n                  });\n                }\n              } catch (err) {\n                console.error('Error parsing history entry:', entry, err);\n              }\n            });\n            console.log('[DEBUG] Loaded message history, cache:', messageCache);\n          }\n          _context3.n = 3;\n          break;\n        case 2:\n          _context3.p = 2;\n          _t3 = _context3.v;\n          console.error('Error loading message history:', _t3);\n        case 3:\n          return _context3.a(2);\n      }\n    }, _callee3, null, [[0, 2]]);\n  }));\n  return _loadMessageHistory.apply(this, arguments);\n}\nfunction processIncomingMessageFromIce(msg) {\n  console.log('[CHAT]  Procesando mensaje Ice:', msg);\n  var username = sessionStorage.getItem('username');\n  var chatKey = msg.isGroup ? \"group_\".concat(msg.to) : \"user_\".concat(msg.from);\n\n  // Agregar al cache\n  if (!messageCache[chatKey]) {\n    messageCache[chatKey] = [];\n  }\n\n  // Verificar duplicados\n  var isDuplicate = messageCache[chatKey].some(function (m) {\n    return m.from === msg.from && m.content === msg.content;\n  });\n  if (!isDuplicate) {\n    messageCache[chatKey].push({\n      from: msg.from,\n      content: msg.content,\n      isSent: false,\n      timestamp: new Date(msg.timestamp)\n    });\n\n    // Mostrar si est en la conversacin actual\n    if (currentChat) {\n      var isCurrentChat = msg.isGroup ? currentChat.type === 'group' && currentChat.name === msg.to : currentChat.type === 'user' && currentChat.name === msg.from;\n      if (isCurrentChat) {\n        addMessageToUI(msg.from, msg.content, false);\n\n        // Notificacin sonora o visual opcional\n        showNewMessageNotification(msg.from);\n      }\n    }\n  }\n}\n\n/**\r\n * Actualizar estado de usuario en la UI\r\n */\nfunction updateUserStatusInUI(user) {\n  var _document$querySelect;\n  console.log('[CHAT]  Actualizando estado de usuario:', user.username, user.isOnline ? 'online' : 'offline');\n\n  // Refrescar lista de usuarios si est visible\n  var sidebarContent = document.getElementById('sidebar-content');\n  if (sidebarContent && ((_document$querySelect = document.querySelector('.sidebar-tabs button.active')) === null || _document$querySelect === void 0 ? void 0 : _document$querySelect.innerText) === 'Users') {\n    loadUsersList();\n  }\n}\n\n/**\r\n * Refrescar grupo si est visible\r\n */\nfunction refreshGroupIfVisible(groupName) {\n  var _document$querySelect2;\n  console.log('[CHAT]  Refrescando grupo:', groupName);\n\n  // Si estamos viendo grupos, refrescar\n  var sidebarContent = document.getElementById('sidebar-content');\n  if (sidebarContent && ((_document$querySelect2 = document.querySelector('.sidebar-tabs button.active')) === null || _document$querySelect2 === void 0 ? void 0 : _document$querySelect2.innerText) === 'Groups') {\n    loadGroupsList();\n  }\n}\n\n/**\r\n * Mostrar notificacin de nuevo mensaje\r\n */\nfunction showNewMessageNotification(from) {\n  // Cambiar ttulo de la pgina temporalmente\n  var originalTitle = document.title;\n  document.title = \"\\uD83D\\uDCAC Mensaje de \".concat(from);\n  setTimeout(function () {\n    document.title = originalTitle;\n  }, 3000);\n\n  // Podras agregar un sonido aqu\n  // new Audio('/notification.mp3').play();\n}\n\n// ============================================\n// FUNCIN ANTIGUA DE POLLING - YA NO SE USA\n// ============================================\n// Esta funcin procesaba mensajes del formato string \"MSG|from|content\"\n// Ahora usamos processIncomingMessageFromIce() que recibe objetos Message directamente\n/*\r\nfunction processIncomingMessage(msg) {\r\n    // Format: \"MSG|from|content\" or \"GROUP|groupName|from|content\"\r\n    const parts = msg.split('|');\r\n    \r\n    console.log('Processing incoming message:', msg, 'Parts:', parts);\r\n    \r\n    if (parts[0] === 'MSG') {\r\n        // Direct message\r\n        const from = parts[1];\r\n        const content = parts[2];\r\n        const chatKey = `user_${from}`;\r\n        \r\n        console.log('Direct message from:', from, 'Current chat:', currentChat);\r\n        \r\n        // Agregar al cache SIN DUPLICAR\r\n        if (!messageCache[chatKey]) {\r\n            messageCache[chatKey] = [];\r\n        }\r\n        \r\n        // Verificar si el mensaje ya existe\r\n        const isDuplicate = messageCache[chatKey].some(m => \r\n            m.from === from && m.content === content\r\n        );\r\n        \r\n        if (!isDuplicate) {\r\n            messageCache[chatKey].push({ from, content, isSent: false, timestamp: new Date() });\r\n            \r\n            // Only show if we're in that conversation\r\n            if (currentChat && currentChat.type === 'user' && currentChat.name === from) {\r\n                addMessageToUI(from, content, false);\r\n            }\r\n        }\r\n    } else if (parts[0] === 'GROUP') {\r\n        // Group message\r\n        const groupName = parts[1];\r\n        const from = parts[2];\r\n        const content = parts[3];\r\n        const chatKey = `group_${groupName}`;\r\n        \r\n        console.log('Group message - Group:', groupName, 'From:', from, 'Current chat:', currentChat);\r\n        \r\n        // Agregar al cache SIN DUPLICAR\r\n        if (!messageCache[chatKey]) {\r\n            messageCache[chatKey] = [];\r\n        }\r\n        \r\n        // Verificar si el mensaje ya existe\r\n        const isDuplicate = messageCache[chatKey].some(m => \r\n            m.from === from && m.content === content\r\n        );\r\n        \r\n        if (!isDuplicate) {\r\n            messageCache[chatKey].push({ from, content, isSent: false, timestamp: new Date() });\r\n            \r\n            // Only show if we're in that group conversation\r\n            if (currentChat && currentChat.type === 'group' && currentChat.name === groupName) {\r\n                addMessageToUI(from, content, false);\r\n            }\r\n        }\r\n    }\r\n}\r\n*/\nfunction showUsers() {\n  return _showUsers.apply(this, arguments);\n}\nfunction _showUsers() {\n  _showUsers = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4() {\n    var content;\n    return _regenerator().w(function (_context4) {\n      while (1) switch (_context4.n) {\n        case 0:\n          content = document.getElementById('sidebar-content');\n          content.innerHTML = '<p style=\"padding: 20px; text-align: center;\">Loading users...</p>';\n\n          // Clear group polling interval if active\n          if (groupListInterval) {\n            clearInterval(groupListInterval);\n            groupListInterval = null;\n          }\n\n          // Start user list polling\n          if (!userListInterval) {\n            userListInterval = setInterval(loadUsersList, 5000); // Refresh every 5 seconds\n          }\n          _context4.n = 1;\n          return loadUsersList();\n        case 1:\n          return _context4.a(2);\n      }\n    }, _callee4);\n  }));\n  return _showUsers.apply(this, arguments);\n}\nfunction loadUsersList() {\n  return _loadUsersList.apply(this, arguments);\n}\nfunction _loadUsersList() {\n  _loadUsersList = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5() {\n    var content, result, currentUsername, usersMap, allUsers, header, _t4;\n    return _regenerator().w(function (_context5) {\n      while (1) switch (_context5.p = _context5.n) {\n        case 0:\n          content = document.getElementById('sidebar-content');\n          _context5.p = 1;\n          _context5.n = 2;\n          return (0,_services_iceDelegate_js__WEBPACK_IMPORTED_MODULE_1__.getAllUsers)();\n        case 2:\n          result = _context5.v;\n          content.innerHTML = '';\n          if (!(!result.success || !result.users)) {\n            _context5.n = 3;\n            break;\n          }\n          content.innerHTML = '<p style=\"padding: 20px; text-align: center; color: #999;\">No users found</p>';\n          return _context5.a(2);\n        case 3:\n          currentUsername = sessionStorage.getItem('username');\n          usersMap = result.users; // {username: isOnline}\n          // Mostrar todos los usuarios sin distincin de estado\n          allUsers = Object.keys(usersMap).filter(function (username) {\n            return username !== currentUsername;\n          });\n          if (!(allUsers.length === 0)) {\n            _context5.n = 4;\n            break;\n          }\n          content.innerHTML = '<p style=\"padding: 20px; text-align: center; color: #999;\">No other users</p>';\n          return _context5.a(2);\n        case 4:\n          // Crear header simple\n          header = document.createElement('div');\n          header.style.cssText = 'padding: 10px 15px; font-weight: 600; color: #667eea; font-size: 0.85rem;';\n          header.innerText = \"\\uFFFD USERS (\".concat(allUsers.length, \")\");\n          content.appendChild(header);\n\n          // Mostrar todos los usuarios\n          allUsers.forEach(function (username) {\n            var userItem = document.createElement('div');\n            userItem.className = 'user-item';\n            userItem.onclick = function () {\n              return selectUser(username);\n            };\n            var avatar = document.createElement('div');\n            avatar.className = 'user-avatar';\n            avatar.innerText = username.charAt(0).toUpperCase();\n            avatar.style.background = '#667eea';\n            var info = document.createElement('div');\n            info.className = 'user-info';\n            var name = document.createElement('div');\n            name.className = 'user-name';\n            name.innerText = username;\n            info.appendChild(name);\n            userItem.appendChild(avatar);\n            userItem.appendChild(info);\n            content.appendChild(userItem);\n          });\n          _context5.n = 6;\n          break;\n        case 5:\n          _context5.p = 5;\n          _t4 = _context5.v;\n          console.error('Error loading users:', _t4);\n          content.innerHTML = '<p style=\"padding: 20px; text-align: center; color: red;\">Error loading users</p>';\n        case 6:\n          return _context5.a(2);\n      }\n    }, _callee5, null, [[1, 5]]);\n  }));\n  return _loadUsersList.apply(this, arguments);\n}\nfunction showGroups() {\n  return _showGroups.apply(this, arguments);\n}\nfunction _showGroups() {\n  _showGroups = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6() {\n    var content;\n    return _regenerator().w(function (_context6) {\n      while (1) switch (_context6.n) {\n        case 0:\n          content = document.getElementById('sidebar-content');\n          content.innerHTML = '<p style=\"padding: 20px; text-align: center;\">Loading groups...</p>';\n\n          // Clear user polling interval if active\n          if (userListInterval) {\n            clearInterval(userListInterval);\n            userListInterval = null;\n          }\n\n          // Start group list polling\n          if (!groupListInterval) {\n            groupListInterval = setInterval(loadGroupsList, 5000); // Refresh every 5 seconds\n          }\n          _context6.n = 1;\n          return loadGroupsList();\n        case 1:\n          return _context6.a(2);\n      }\n    }, _callee6);\n  }));\n  return _showGroups.apply(this, arguments);\n}\nfunction loadGroupsList() {\n  return _loadGroupsList.apply(this, arguments);\n}\nfunction _loadGroupsList() {\n  _loadGroupsList = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee7() {\n    var content, username, result, createBtn, noGroups, _t5;\n    return _regenerator().w(function (_context7) {\n      while (1) switch (_context7.p = _context7.n) {\n        case 0:\n          content = document.getElementById('sidebar-content');\n          _context7.p = 1;\n          username = sessionStorage.getItem('username');\n          _context7.n = 2;\n          return (0,_services_iceDelegate_js__WEBPACK_IMPORTED_MODULE_1__.getUserGroups)(username);\n        case 2:\n          result = _context7.v;\n          content.innerHTML = '';\n\n          // Add \"Create Group\" button\n          createBtn = document.createElement('button');\n          createBtn.className = 'create-group-btn';\n          createBtn.innerText = '+ Create Group';\n          createBtn.style.cssText = 'margin: 10px; padding: 10px; width: calc(100% - 20px); background: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer;';\n          createBtn.onclick = showCreateGroupDialog;\n          content.appendChild(createBtn);\n          if (!(!result.success || !result.groups || result.groups.length === 0)) {\n            _context7.n = 3;\n            break;\n          }\n          noGroups = document.createElement('p');\n          noGroups.style.cssText = 'padding: 20px; text-align: center; color: #999;';\n          noGroups.innerText = 'No groups yet. Create one!';\n          content.appendChild(noGroups);\n          return _context7.a(2);\n        case 3:\n          result.groups.forEach(function (groupName) {\n            var groupItem = document.createElement('div');\n            groupItem.className = 'user-item';\n            groupItem.onclick = function () {\n              return selectGroup(groupName);\n            };\n            var avatar = document.createElement('div');\n            avatar.className = 'user-avatar';\n            avatar.innerText = groupName.charAt(0).toUpperCase();\n            avatar.style.background = '#28a745';\n            var info = document.createElement('div');\n            info.className = 'user-info';\n            var name = document.createElement('div');\n            name.className = 'user-name';\n            name.innerText = groupName;\n            var status = document.createElement('div');\n            status.className = 'user-status';\n            status.innerText = 'group';\n            info.appendChild(name);\n            info.appendChild(status);\n            groupItem.appendChild(avatar);\n            groupItem.appendChild(info);\n            content.appendChild(groupItem);\n          });\n          _context7.n = 5;\n          break;\n        case 4:\n          _context7.p = 4;\n          _t5 = _context7.v;\n          console.error('Error loading groups:', _t5);\n          content.innerHTML = '<p style=\"padding: 20px; text-align: center; color: red;\">Error loading groups</p>';\n        case 5:\n          return _context7.a(2);\n      }\n    }, _callee7, null, [[1, 4]]);\n  }));\n  return _loadGroupsList.apply(this, arguments);\n}\nfunction showCreateGroupDialog() {\n  return _showCreateGroupDialog.apply(this, arguments);\n}\nfunction _showCreateGroupDialog() {\n  _showCreateGroupDialog = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee9() {\n    var modal, modalContent, title, groupNameLabel, groupNameInput, membersLabel, usersList, result, currentUsername, allUsernames, info, actions, cancelBtn, createBtn, _t8;\n    return _regenerator().w(function (_context9) {\n      while (1) switch (_context9.p = _context9.n) {\n        case 0:\n          // Crear modal\n          modal = document.createElement('div');\n          modal.className = 'modal';\n          modal.style.display = 'flex';\n          modalContent = document.createElement('div');\n          modalContent.className = 'modal-content';\n          modalContent.style.maxWidth = '500px';\n          title = document.createElement('h2');\n          title.innerText = ' Create New Group';\n          title.style.marginBottom = '20px';\n          groupNameLabel = document.createElement('label');\n          groupNameLabel.innerText = 'Group Name:';\n          groupNameLabel.style.display = 'block';\n          groupNameLabel.style.marginBottom = '8px';\n          groupNameLabel.style.fontWeight = '600';\n          groupNameInput = document.createElement('input');\n          groupNameInput.type = 'text';\n          groupNameInput.placeholder = 'Enter group name...';\n          groupNameInput.style.marginBottom = '15px';\n          membersLabel = document.createElement('label');\n          membersLabel.innerText = 'Select Members:';\n          membersLabel.style.display = 'block';\n          membersLabel.style.marginBottom = '8px';\n          membersLabel.style.fontWeight = '600';\n          usersList = document.createElement('div');\n          usersList.className = 'group-modal-users';\n          usersList.innerHTML = '<p style=\"text-align: center; padding: 20px;\">Loading users...</p>';\n\n          // Obtener TODOS los usuarios (no solo online)\n          _context9.p = 1;\n          _context9.n = 2;\n          return (0,_services_iceDelegate_js__WEBPACK_IMPORTED_MODULE_1__.getAllUsers)();\n        case 2:\n          result = _context9.v;\n          currentUsername = sessionStorage.getItem('username');\n          if (result.success && result.users) {\n            usersList.innerHTML = '';\n\n            // result.users es un objeto {username: isOnline}\n            allUsernames = Object.keys(result.users).filter(function (u) {\n              return u !== currentUsername;\n            });\n            if (allUsernames.length > 0) {\n              allUsernames.forEach(function (username) {\n                var item = document.createElement('div');\n                item.className = 'user-checkbox-item';\n                var checkbox = document.createElement('input');\n                checkbox.type = 'checkbox';\n                checkbox.id = \"user-\".concat(username);\n                checkbox.value = username;\n                var label = document.createElement('label');\n                label.htmlFor = \"user-\".concat(username);\n                label.innerText = username;\n                item.appendChild(checkbox);\n                item.appendChild(label);\n                usersList.appendChild(item);\n\n                // Make entire item clickable\n                item.onclick = function (e) {\n                  if (e.target !== checkbox) {\n                    checkbox.checked = !checkbox.checked;\n                  }\n                };\n              });\n              info = document.createElement('div');\n              info.className = 'group-modal-info';\n              info.innerText = \"You will be added as admin automatically\";\n              usersList.appendChild(info);\n            } else {\n              usersList.innerHTML = '<p style=\"text-align: center; padding: 20px; color: #999;\">No other users available</p>';\n            }\n          } else {\n            usersList.innerHTML = '<p style=\"text-align: center; padding: 20px; color: #999;\">No other users available</p>';\n          }\n          _context9.n = 4;\n          break;\n        case 3:\n          _context9.p = 3;\n          _t8 = _context9.v;\n          usersList.innerHTML = '<p style=\"text-align: center; padding: 20px; color: red;\">Error loading users</p>';\n        case 4:\n          actions = document.createElement('div');\n          actions.className = 'modal-actions';\n          cancelBtn = document.createElement('button');\n          cancelBtn.className = 'btn-cancel';\n          cancelBtn.innerText = 'Cancel';\n          cancelBtn.onclick = function () {\n            document.body.removeChild(modal);\n          };\n          createBtn = document.createElement('button');\n          createBtn.className = 'btn-create';\n          createBtn.innerText = 'Create Group';\n          createBtn.onclick = /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee8() {\n            var groupName, username, checkboxes, selectedUsers, _result, _iterator, _step, member, _t6, _t7;\n            return _regenerator().w(function (_context8) {\n              while (1) switch (_context8.p = _context8.n) {\n                case 0:\n                  groupName = groupNameInput.value.trim();\n                  if (groupName) {\n                    _context8.n = 1;\n                    break;\n                  }\n                  alert('Please enter a group name');\n                  return _context8.a(2);\n                case 1:\n                  username = sessionStorage.getItem('username');\n                  checkboxes = usersList.querySelectorAll('input[type=\"checkbox\"]:checked');\n                  selectedUsers = Array.from(checkboxes).map(function (cb) {\n                    return cb.value;\n                  });\n                  _context8.p = 2;\n                  _context8.n = 3;\n                  return (0,_services_iceDelegate_js__WEBPACK_IMPORTED_MODULE_1__.createGroup)(groupName, username);\n                case 3:\n                  _result = _context8.v;\n                  if (_result.success) {\n                    _context8.n = 4;\n                    break;\n                  }\n                  alert('Error creating group: ' + _result.message);\n                  return _context8.a(2);\n                case 4:\n                  // Agregar miembros seleccionados\n                  _iterator = _createForOfIteratorHelper(selectedUsers);\n                  _context8.p = 5;\n                  _iterator.s();\n                case 6:\n                  if ((_step = _iterator.n()).done) {\n                    _context8.n = 8;\n                    break;\n                  }\n                  member = _step.value;\n                  _context8.n = 7;\n                  return (0,_services_iceDelegate_js__WEBPACK_IMPORTED_MODULE_1__.addMemberToGroup)(groupName, member);\n                case 7:\n                  _context8.n = 6;\n                  break;\n                case 8:\n                  _context8.n = 10;\n                  break;\n                case 9:\n                  _context8.p = 9;\n                  _t6 = _context8.v;\n                  _iterator.e(_t6);\n                case 10:\n                  _context8.p = 10;\n                  _iterator.f();\n                  return _context8.f(10);\n                case 11:\n                  document.body.removeChild(modal);\n                  alert(\"Group \\\"\".concat(groupName, \"\\\" created with \").concat(selectedUsers.length, \" members!\"));\n                  showGroups(); // Refresh\n                  _context8.n = 13;\n                  break;\n                case 12:\n                  _context8.p = 12;\n                  _t7 = _context8.v;\n                  alert('Error creating group: ' + _t7.message);\n                case 13:\n                  return _context8.a(2);\n              }\n            }, _callee8, null, [[5, 9, 10, 11], [2, 12]]);\n          }));\n          actions.appendChild(cancelBtn);\n          actions.appendChild(createBtn);\n          modalContent.appendChild(title);\n          modalContent.appendChild(groupNameLabel);\n          modalContent.appendChild(groupNameInput);\n          modalContent.appendChild(membersLabel);\n          modalContent.appendChild(usersList);\n          modalContent.appendChild(actions);\n          modal.appendChild(modalContent);\n          document.body.appendChild(modal);\n          groupNameInput.focus();\n        case 5:\n          return _context9.a(2);\n      }\n    }, _callee9, null, [[1, 3]]);\n  }));\n  return _showCreateGroupDialog.apply(this, arguments);\n}\nfunction showAddMembersDialog(_x3) {\n  return _showAddMembersDialog.apply(this, arguments);\n}\nfunction _showAddMembersDialog() {\n  _showAddMembersDialog = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee0(groupName) {\n    var result, username, otherUsers, membersToAdd, members, _iterator2, _step2, member, _t9, _t0;\n    return _regenerator().w(function (_context0) {\n      while (1) switch (_context0.p = _context0.n) {\n        case 0:\n          _context0.p = 0;\n          _context0.n = 1;\n          return (0,_services_iceDelegate_js__WEBPACK_IMPORTED_MODULE_1__.getOnlineUsers)();\n        case 1:\n          result = _context0.v;\n          if (!(!result.success || !result.users)) {\n            _context0.n = 2;\n            break;\n          }\n          alert('Error loading users');\n          return _context0.a(2);\n        case 2:\n          username = sessionStorage.getItem('username');\n          otherUsers = result.users.filter(function (u) {\n            return u !== username;\n          });\n          if (!(otherUsers.length === 0)) {\n            _context0.n = 3;\n            break;\n          }\n          alert('No other users online');\n          showGroups();\n          return _context0.a(2);\n        case 3:\n          membersToAdd = prompt('Enter usernames to add (comma-separated):\\nAvailable: ' + otherUsers.join(', '));\n          if (membersToAdd) {\n            _context0.n = 4;\n            break;\n          }\n          showGroups();\n          return _context0.a(2);\n        case 4:\n          members = membersToAdd.split(',').map(function (m) {\n            return m.trim();\n          }); // Add each member\n          _iterator2 = _createForOfIteratorHelper(members);\n          _context0.p = 5;\n          _iterator2.s();\n        case 6:\n          if ((_step2 = _iterator2.n()).done) {\n            _context0.n = 8;\n            break;\n          }\n          member = _step2.value;\n          if (!otherUsers.includes(member)) {\n            _context0.n = 7;\n            break;\n          }\n          _context0.n = 7;\n          return (0,_services_iceDelegate_js__WEBPACK_IMPORTED_MODULE_1__.addMemberToGroup)(groupName, member);\n        case 7:\n          _context0.n = 6;\n          break;\n        case 8:\n          _context0.n = 10;\n          break;\n        case 9:\n          _context0.p = 9;\n          _t9 = _context0.v;\n          _iterator2.e(_t9);\n        case 10:\n          _context0.p = 10;\n          _iterator2.f();\n          return _context0.f(10);\n        case 11:\n          alert('Members added successfully!');\n          showGroups();\n          _context0.n = 13;\n          break;\n        case 12:\n          _context0.p = 12;\n          _t0 = _context0.v;\n          console.error('Error adding members:', _t0);\n          alert('Failed to add members');\n          showGroups();\n        case 13:\n          return _context0.a(2);\n      }\n    }, _callee0, null, [[5, 9, 10, 11], [0, 12]]);\n  }));\n  return _showAddMembersDialog.apply(this, arguments);\n}\nfunction selectGroup(_x4) {\n  return _selectGroup.apply(this, arguments);\n}\nfunction _selectGroup() {\n  _selectGroup = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee1(groupName) {\n    var inputArea, callButton, username, messagesArea, chatKey, _t1;\n    return _regenerator().w(function (_context1) {\n      while (1) switch (_context1.p = _context1.n) {\n        case 0:\n          currentChat = {\n            type: 'group',\n            name: groupName\n          };\n          document.getElementById('chat-title').innerText = ' ' + groupName;\n\n          // Mostrar input de mensaje\n          inputArea = document.getElementById('chat-input-area');\n          if (inputArea) {\n            inputArea.style.display = 'flex';\n          }\n\n          // Ocultar botn de llamada para grupos\n          callButton = document.getElementById('call-button');\n          if (callButton) {\n            callButton.style.display = 'none';\n          }\n\n          // Clear previous selection\n          document.querySelectorAll('.user-item').forEach(function (item) {\n            item.classList.remove('active');\n          });\n\n          // Mark selected\n          event.currentTarget.classList.add('active');\n\n          // Auto-join group if not already a member\n          username = sessionStorage.getItem('username');\n          _context1.p = 1;\n          _context1.n = 2;\n          return (0,_services_iceDelegate_js__WEBPACK_IMPORTED_MODULE_1__.addMemberToGroup)(groupName, username);\n        case 2:\n          _context1.n = 4;\n          break;\n        case 3:\n          _context1.p = 3;\n          _t1 = _context1.v;\n          console.log('Already in group or error joining:', _t1);\n        case 4:\n          // Load messages from cache (texto y voz)\n          messagesArea = document.getElementById('chat-messages');\n          messagesArea.innerHTML = '';\n          chatKey = \"group_\".concat(groupName);\n          if (messageCache[chatKey] && messageCache[chatKey].length > 0) {\n            messageCache[chatKey].forEach(function (msg) {\n              if (msg.isVoiceNote) {\n                addVoiceNoteToUI(msg.from, msg.isSent, msg.audioData);\n              } else {\n                addMessageToUI(msg.from, msg.content, msg.isSent);\n              }\n            });\n          } else {\n            messagesArea.innerHTML = '<p style=\"text-align: center; color: #999; padding: 20px;\">Group chat: ' + groupName + '</p>';\n          }\n        case 5:\n          return _context1.a(2);\n      }\n    }, _callee1, null, [[1, 3]]);\n  }));\n  return _selectGroup.apply(this, arguments);\n}\nvar currentChat = null;\nvar messageCache = {}; // Cache de mensajes por conversacin\nvar userListInterval = null;\nvar groupListInterval = null;\nfunction selectUser(username) {\n  currentChat = {\n    type: 'user',\n    name: username\n  };\n  document.getElementById('chat-title').innerText = username;\n\n  // Mostrar input de mensaje\n  var inputArea = document.getElementById('chat-input-area');\n  if (inputArea) {\n    inputArea.style.display = 'flex';\n  }\n\n  // Mostrar botn de llamada para usuarios (no para grupos)\n  var callButton = document.getElementById('call-button');\n  if (callButton) {\n    callButton.style.display = 'block';\n  }\n\n  // Clear previous selection\n  document.querySelectorAll('.user-item').forEach(function (item) {\n    item.classList.remove('active');\n  });\n\n  // Mark selected\n  event.currentTarget.classList.add('active');\n\n  // Load messages from cache (texto y voz)\n  var messagesArea = document.getElementById('chat-messages');\n  messagesArea.innerHTML = '';\n  var chatKey = \"user_\".concat(username);\n  if (messageCache[chatKey] && messageCache[chatKey].length > 0) {\n    messageCache[chatKey].forEach(function (msg) {\n      if (msg.isVoiceNote) {\n        addVoiceNoteToUI(msg.from, msg.isSent, msg.audioData);\n      } else {\n        addMessageToUI(msg.from, msg.content, msg.isSent);\n      }\n    });\n  } else {\n    messagesArea.innerHTML = '<p style=\"text-align: center; color: #999; padding: 20px;\">Start a conversation with ' + username + '</p>';\n  }\n}\nfunction sendMessage() {\n  return _sendMessage.apply(this, arguments);\n}\nfunction _sendMessage() {\n  _sendMessage = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee10() {\n    var input, message, username, result, chatKey, _t10;\n    return _regenerator().w(function (_context10) {\n      while (1) switch (_context10.p = _context10.n) {\n        case 0:\n          input = document.getElementById('message-input');\n          message = input.value.trim();\n          if (!(!message || !currentChat)) {\n            _context10.n = 1;\n            break;\n          }\n          return _context10.a(2);\n        case 1:\n          username = sessionStorage.getItem('username');\n          _context10.p = 2;\n          if (!(currentChat.type === 'user')) {\n            _context10.n = 4;\n            break;\n          }\n          _context10.n = 3;\n          return (0,_services_iceDelegate_js__WEBPACK_IMPORTED_MODULE_1__.sendMessageToUser)(username, currentChat.name, message);\n        case 3:\n          result = _context10.v;\n          chatKey = \"user_\".concat(currentChat.name);\n          _context10.n = 6;\n          break;\n        case 4:\n          if (!(currentChat.type === 'group')) {\n            _context10.n = 6;\n            break;\n          }\n          _context10.n = 5;\n          return (0,_services_iceDelegate_js__WEBPACK_IMPORTED_MODULE_1__.sendMessageToGroup)(username, currentChat.name, message);\n        case 5:\n          result = _context10.v;\n          chatKey = \"group_\".concat(currentChat.name);\n        case 6:\n          if (result.success) {\n            _context10.n = 7;\n            break;\n          }\n          alert('Error al enviar mensaje: ' + result.message);\n          return _context10.a(2);\n        case 7:\n          // Guardar en cache\n          if (!messageCache[chatKey]) {\n            messageCache[chatKey] = [];\n          }\n          messageCache[chatKey].push({\n            from: username,\n            content: message,\n            isSent: true,\n            timestamp: new Date()\n          });\n\n          // Add message to UI\n          addMessageToUI(username, message, true);\n          input.value = '';\n          _context10.n = 9;\n          break;\n        case 8:\n          _context10.p = 8;\n          _t10 = _context10.v;\n          console.error('Error sending message:', _t10);\n          alert('Failed to send message');\n        case 9:\n          return _context10.a(2);\n      }\n    }, _callee10, null, [[2, 8]]);\n  }));\n  return _sendMessage.apply(this, arguments);\n}\nfunction addMessageToUI(from, content, isSent) {\n  var messagesArea = document.getElementById('chat-messages');\n\n  // Remove placeholder if exists\n  if (messagesArea.children.length === 1 && messagesArea.children[0].tagName === 'P') {\n    messagesArea.innerHTML = '';\n  }\n  var messageDiv = document.createElement('div');\n  messageDiv.className = 'message ' + (isSent ? 'sent' : 'received');\n  var header = document.createElement('div');\n  header.className = 'message-header';\n  header.innerText = from;\n  var bubble = document.createElement('div');\n  bubble.className = 'message-bubble';\n  bubble.innerText = content;\n  var time = document.createElement('div');\n  time.className = 'message-time';\n  time.innerText = new Date().toLocaleTimeString();\n  messageDiv.appendChild(header);\n  messageDiv.appendChild(bubble);\n  messageDiv.appendChild(time);\n  messagesArea.appendChild(messageDiv);\n  messagesArea.scrollTop = messagesArea.scrollHeight;\n}\n\n// ============================================\n// FUNCIONES DE NOTAS DE VOZ\n// ============================================\n\nvar isRecordingVoice = false;\n\n/**\r\n * Alternar grabacin de nota de voz\r\n */\nfunction toggleVoiceRecording() {\n  return _toggleVoiceRecording.apply(this, arguments);\n}\n/**\r\n * Manejar nota de voz recibida (sin reproduccin automtica)\r\n */\nfunction _toggleVoiceRecording() {\n  _toggleVoiceRecording = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee11() {\n    var voiceButton, started, audioData, username, result, _yield$import, sendVoiceNoteToUser, sendVoiceNoteToGroup, chatKey, _t11;\n    return _regenerator().w(function (_context11) {\n      while (1) switch (_context11.p = _context11.n) {\n        case 0:\n          voiceButton = document.querySelector('.voice-btn');\n          if (voiceButton) {\n            _context11.n = 1;\n            break;\n          }\n          return _context11.a(2);\n        case 1:\n          if (isRecordingVoice) {\n            _context11.n = 3;\n            break;\n          }\n          _context11.n = 2;\n          return (0,_services_audioRecorder_js__WEBPACK_IMPORTED_MODULE_2__.startRecording)();\n        case 2:\n          started = _context11.v;\n          if (started) {\n            isRecordingVoice = true;\n            voiceButton.innerHTML = '';\n            voiceButton.classList.add('recording');\n            voiceButton.title = 'Detener grabacin';\n            console.log('[CHAT]  Grabacin iniciada');\n          }\n          _context11.n = 12;\n          break;\n        case 3:\n          _context11.p = 3;\n          voiceButton.disabled = true;\n          _context11.n = 4;\n          return (0,_services_audioRecorder_js__WEBPACK_IMPORTED_MODULE_2__.stopRecording)();\n        case 4:\n          audioData = _context11.v;\n          console.log('[CHAT]  Audio capturado:', audioData.length, 'bytes');\n          username = sessionStorage.getItem('username');\n          _context11.n = 5;\n          return Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ../services/iceDelegate.js */ \"./src/services/iceDelegate.js\"));\n        case 5:\n          _yield$import = _context11.v;\n          sendVoiceNoteToUser = _yield$import.sendVoiceNoteToUser;\n          sendVoiceNoteToGroup = _yield$import.sendVoiceNoteToGroup;\n          if (!(currentChat.type === 'user')) {\n            _context11.n = 7;\n            break;\n          }\n          _context11.n = 6;\n          return sendVoiceNoteToUser(username, currentChat.name, audioData);\n        case 6:\n          result = _context11.v;\n          _context11.n = 9;\n          break;\n        case 7:\n          _context11.n = 8;\n          return sendVoiceNoteToGroup(username, currentChat.name, audioData);\n        case 8:\n          result = _context11.v;\n        case 9:\n          if (result.success) {\n            console.log('[CHAT]  Nota de voz enviada');\n\n            // Guardar en cach local para el remitente\n            chatKey = currentChat.type === 'group' ? \"group_\".concat(currentChat.name) : \"user_\".concat(currentChat.name);\n            if (!messageCache[chatKey]) {\n              messageCache[chatKey] = [];\n            }\n            messageCache[chatKey].push({\n              from: username,\n              content: '[Nota de voz]',\n              isSent: true,\n              timestamp: new Date(),\n              isVoiceNote: true,\n              audioData: audioData\n            });\n\n            // Mostrar en UI del remitente\n            addVoiceNoteToUI(username, true, audioData);\n          } else {\n            alert('Error al enviar nota de voz: ' + result.message);\n          }\n          _context11.n = 11;\n          break;\n        case 10:\n          _context11.p = 10;\n          _t11 = _context11.v;\n          console.error('[CHAT]  Error enviando nota de voz:', _t11);\n          alert('Error al enviar nota de voz: ' + _t11.message);\n        case 11:\n          _context11.p = 11;\n          isRecordingVoice = false;\n          voiceButton.disabled = false;\n          voiceButton.innerHTML = '';\n          voiceButton.classList.remove('recording');\n          voiceButton.title = 'Grabar nota de voz';\n          return _context11.f(11);\n        case 12:\n          return _context11.a(2);\n      }\n    }, _callee11, null, [[3, 10, 11, 12]]);\n  }));\n  return _toggleVoiceRecording.apply(this, arguments);\n}\nfunction playReceivedVoiceNote(from, to, audioData, isGroup) {\n  console.log('[CHAT]  Nota de voz recibida de:', from, 'para:', to, 'isGroup:', isGroup, 'Size:', audioData.length);\n\n  // Determinar clave de cach correcta segn si es grupo o privado\n  var chatKey = isGroup ? \"group_\".concat(to) : \"user_\".concat(from);\n  if (!messageCache[chatKey]) {\n    messageCache[chatKey] = [];\n  }\n  messageCache[chatKey].push({\n    from: from,\n    content: '[Nota de voz]',\n    isSent: false,\n    timestamp: new Date(),\n    isVoiceNote: true,\n    audioData: audioData\n  });\n\n  // Mostrar en UI solo si estamos en el chat correcto\n  if (currentChat) {\n    var isCorrectChat = isGroup ? currentChat.type === 'group' && currentChat.name === to : currentChat.type === 'user' && currentChat.name === from;\n    if (isCorrectChat) {\n      addVoiceNoteToUI(from, false, audioData);\n    }\n  }\n}\n\n/**\r\n * Agregar indicador visual de nota de voz en el chat\r\n */\nfunction addVoiceNoteToUI(from, isSent) {\n  var audioData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var messagesArea = document.getElementById('chat-messages');\n\n  // Remover placeholder si existe\n  if (messagesArea.children.length === 1 && messagesArea.children[0].tagName === 'P') {\n    messagesArea.innerHTML = '';\n  }\n  var messageDiv = document.createElement('div');\n  messageDiv.className = 'message voice-note ' + (isSent ? 'sent' : 'received');\n  var header = document.createElement('div');\n  header.className = 'message-header';\n  header.innerText = from;\n  var bubble = document.createElement('div');\n  bubble.className = 'message-bubble voice-bubble';\n  var voiceIcon = document.createElement('span');\n  voiceIcon.className = 'voice-icon';\n  voiceIcon.innerHTML = '';\n  var voiceContent = document.createElement('div');\n  voiceContent.className = 'voice-content';\n  var voiceText = document.createElement('span');\n  voiceText.className = 'voice-text';\n  voiceText.innerText = 'Nota de voz';\n  var voiceDuration = document.createElement('span');\n  voiceDuration.className = 'voice-duration';\n  voiceDuration.innerText = audioData ? \"\".concat(Math.ceil(audioData.length / 16000), \"s\") : '...';\n  voiceContent.appendChild(voiceText);\n  voiceContent.appendChild(voiceDuration);\n\n  // Siempre agregar botn de reproduccin si tenemos audioData\n  if (audioData) {\n    var playBtn = document.createElement('button');\n    playBtn.innerHTML = '';\n    playBtn.className = 'play-audio-btn';\n    playBtn.title = 'Reproducir nota de voz';\n    playBtn.onclick = /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee() {\n      var _t;\n      return _regenerator().w(function (_context) {\n        while (1) switch (_context.p = _context.n) {\n          case 0:\n            playBtn.disabled = true;\n            playBtn.innerHTML = '';\n            _context.p = 1;\n            _context.n = 2;\n            return (0,_services_audioRecorder_js__WEBPACK_IMPORTED_MODULE_2__.playAudio)(audioData);\n          case 2:\n            playBtn.innerHTML = '';\n            _context.n = 4;\n            break;\n          case 3:\n            _context.p = 3;\n            _t = _context.v;\n            console.error('Error reproduciendo:', _t);\n            alert('Error al reproducir audio');\n            playBtn.innerHTML = '';\n          case 4:\n            _context.p = 4;\n            playBtn.disabled = false;\n            return _context.f(4);\n          case 5:\n            return _context.a(2);\n        }\n      }, _callee, null, [[1, 3, 4, 5]]);\n    }));\n    bubble.appendChild(voiceIcon);\n    bubble.appendChild(voiceContent);\n    bubble.appendChild(playBtn);\n  } else {\n    bubble.appendChild(voiceIcon);\n    bubble.appendChild(voiceContent);\n  }\n  var time = document.createElement('div');\n  time.className = 'message-time';\n  time.innerText = new Date().toLocaleTimeString();\n  messageDiv.appendChild(header);\n  messageDiv.appendChild(bubble);\n  messageDiv.appendChild(time);\n  messagesArea.appendChild(messageDiv);\n  messagesArea.scrollTop = messagesArea.scrollHeight;\n}\n\n// ========== LLAMADAS WEBRTC ==========\n\nvar inCall = false;\nvar callWithUser = null;\n\n/**\r\n * Manejar clic en botn de llamada\r\n */\nfunction handleCallButton() {\n  return _handleCallButton.apply(this, arguments);\n}\n/**\r\n * Manejar llamada entrante\r\n */\nfunction _handleCallButton() {\n  _handleCallButton = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee12() {\n    var username, result, callResult;\n    return _regenerator().w(function (_context12) {\n      while (1) switch (_context12.n) {\n        case 0:\n          username = sessionStorage.getItem('username');\n          if (!inCall) {\n            _context12.n = 2;\n            break;\n          }\n          _context12.n = 1;\n          return (0,_services_webrtcService_js__WEBPACK_IMPORTED_MODULE_3__.hangUp)(username, callWithUser);\n        case 1:\n          endCallUI();\n          _context12.n = 8;\n          break;\n        case 2:\n          if (!(!currentChat || currentChat.type !== 'user')) {\n            _context12.n = 3;\n            break;\n          }\n          alert('Selecciona un usuario para llamar');\n          return _context12.a(2);\n        case 3:\n          console.log('[CALL] Iniciando llamada a:', currentChat.name);\n\n          // Notificar al servidor\n          _context12.n = 4;\n          return (0,_services_iceDelegate_js__WEBPACK_IMPORTED_MODULE_1__.initiateCall)(username, currentChat.name);\n        case 4:\n          result = _context12.v;\n          if (result.success) {\n            _context12.n = 5;\n            break;\n          }\n          alert('No se pudo iniciar la llamada: ' + result.message);\n          return _context12.a(2);\n        case 5:\n          _context12.n = 6;\n          return (0,_services_webrtcService_js__WEBPACK_IMPORTED_MODULE_3__.startCall)(username, currentChat.name, true);\n        case 6:\n          callResult = _context12.v;\n          if (callResult.success) {\n            _context12.n = 7;\n            break;\n          }\n          alert('Error al iniciar llamada: ' + callResult.error);\n          return _context12.a(2);\n        case 7:\n          // Actualizar UI\n          callWithUser = currentChat.name;\n          inCall = true;\n          showCallUI(currentChat.name, callResult.localStream);\n        case 8:\n          return _context12.a(2);\n      }\n    }, _callee12);\n  }));\n  return _handleCallButton.apply(this, arguments);\n}\nfunction handleIncomingCall(_x5) {\n  return _handleIncomingCall.apply(this, arguments);\n}\n/**\r\n * Mostrar UI de llamada activa\r\n */\nfunction _handleIncomingCall() {\n  _handleIncomingCall = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee14(from) {\n    var username;\n    return _regenerator().w(function (_context14) {\n      while (1) switch (_context14.n) {\n        case 0:\n          username = sessionStorage.getItem('username');\n          if (!inCall) {\n            _context14.n = 1;\n            break;\n          }\n          console.log('[CALL] Rechazando llamada, ya estamos en otra');\n          return _context14.a(2);\n        case 1:\n          // Mostrar UI de llamada entrante personalizada\n          showIncomingCallUI(from, /*#__PURE__*/function () {\n            var _ref3 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee13(accepted) {\n              var callResult;\n              return _regenerator().w(function (_context13) {\n                while (1) switch (_context13.n) {\n                  case 0:\n                    if (!accepted) {\n                      _context13.n = 3;\n                      break;\n                    }\n                    console.log('[CALL] Aceptando llamada de:', from);\n\n                    // Iniciar WebRTC para responder\n                    _context13.n = 1;\n                    return (0,_services_webrtcService_js__WEBPACK_IMPORTED_MODULE_3__.answerCall)(from, username, true);\n                  case 1:\n                    callResult = _context13.v;\n                    if (callResult.success) {\n                      _context13.n = 2;\n                      break;\n                    }\n                    alert('Error al aceptar llamada: ' + callResult.error);\n                    return _context13.a(2);\n                  case 2:\n                    // Actualizar UI\n                    callWithUser = from;\n                    inCall = true;\n                    showCallUI(from, callResult.localStream);\n\n                    // Cambiar al chat del usuario que llama\n                    selectUserDirectly(from);\n                    _context13.n = 4;\n                    break;\n                  case 3:\n                    console.log('[CALL] Llamada rechazada');\n                  case 4:\n                    return _context13.a(2);\n                }\n              }, _callee13);\n            }));\n            return function (_x6) {\n              return _ref3.apply(this, arguments);\n            };\n          }());\n        case 2:\n          return _context14.a(2);\n      }\n    }, _callee14);\n  }));\n  return _handleIncomingCall.apply(this, arguments);\n}\nfunction showCallActiveUI(remoteUser) {\n  console.log('[CALL] Mostrando UI de llamada activa con:', remoteUser);\n  var callContainer = document.getElementById('callContainer');\n  if (callContainer) {\n    var statusDiv = callContainer.querySelector('.call-status');\n    if (statusDiv) {\n      statusDiv.innerHTML = ' Conectado - Audio streaming activo';\n      statusDiv.style.color = '#28a745';\n    }\n  }\n}\n\n/**\r\n * Mostrar UI de llamada activa\r\n */\n/**\r\n * Mostrar modal de llamada entrante\r\n */\nfunction showIncomingCallUI(callerName, callback) {\n  // Crear overlay modal\n  var modal = document.createElement('div');\n  modal.id = 'incomingCallModal';\n  modal.className = 'incoming-call-modal';\n  modal.innerHTML = \"\\n        <div class=\\\"incoming-call-overlay\\\"></div>\\n        <div class=\\\"incoming-call-card\\\">\\n            <div class=\\\"incoming-call-avatar\\\">\\n                <div class=\\\"avatar-ring\\\"></div>\\n                <div class=\\\"avatar-circle\\\">\\n                    <span class=\\\"avatar-initial\\\">\".concat(callerName.charAt(0).toUpperCase(), \"</span>\\n                </div>\\n            </div>\\n            <h2 class=\\\"incoming-call-name\\\">\").concat(callerName, \"</h2>\\n            <p class=\\\"incoming-call-text\\\">\\uD83D\\uDCDE Llamada entrante...</p>\\n            <div class=\\\"incoming-call-buttons\\\">\\n                <button class=\\\"call-accept-btn\\\" id=\\\"acceptCallBtn\\\">\\n                    <span class=\\\"btn-icon\\\">\\u2713</span>\\n                    <span>Aceptar</span>\\n                </button>\\n                <button class=\\\"call-reject-btn\\\" id=\\\"rejectCallBtn\\\">\\n                    <span class=\\\"btn-icon\\\">\\u2715</span>\\n                    <span>Rechazar</span>\\n                </button>\\n            </div>\\n        </div>\\n    \");\n  document.body.appendChild(modal);\n\n  // Animar entrada\n  setTimeout(function () {\n    return modal.classList.add('show');\n  }, 10);\n\n  // Handlers\n  var acceptBtn = document.getElementById('acceptCallBtn');\n  var rejectBtn = document.getElementById('rejectCallBtn');\n  var closeModal = function closeModal() {\n    modal.classList.remove('show');\n    setTimeout(function () {\n      return modal.remove();\n    }, 300);\n  };\n  acceptBtn.onclick = function () {\n    closeModal();\n    callback(true);\n  };\n  rejectBtn.onclick = function () {\n    closeModal();\n    callback(false);\n  };\n}\nfunction showCallUI(remoteUser, localStream) {\n  var callContainer = document.getElementById('callContainer');\n  var callButton = document.getElementById('call-button');\n  callContainer.style.display = 'flex';\n  callContainer.innerHTML = \"\\n        <div class=\\\"call-info\\\">\\n            <h3>\\uD83D\\uDCDE En llamada con \".concat(remoteUser, \"</h3>\\n            <div class=\\\"call-status\\\">\\uD83D\\uDD04 Conectando via WebSocket...</div>\\n        </div>\\n        <div class=\\\"call-audio-indicators\\\">\\n            <div class=\\\"audio-indicator\\\">\\n                <div class=\\\"audio-wave local\\\">\\n                    <span></span><span></span><span></span><span></span><span></span>\\n                </div>\\n                <label>\\uD83C\\uDFA4 Tu audio</label>\\n            </div>\\n            <div class=\\\"audio-indicator\\\">\\n                <div class=\\\"audio-wave remote\\\" id=\\\"remoteAudioIndicator\\\">\\n                    <span></span><span></span><span></span><span></span><span></span>\\n                </div>\\n                <label>\\uD83D\\uDD0A Audio de \").concat(remoteUser, \"</label>\\n            </div>\\n        </div>\\n        <div class=\\\"call-controls\\\">\\n            <button class=\\\"hangup-btn\\\" onclick=\\\"window.hangUpCall()\\\">\\uD83D\\uDD34 Colgar</button>\\n        </div>\\n    \");\n\n  // Actualizar botn de llamada\n  callButton.innerHTML = '';\n  callButton.title = 'Colgar';\n\n  // Animar indicadores de audio\n  animateAudioIndicators();\n}\n\n/**\r\n * Terminar llamada y limpiar UI\r\n */\nfunction endCallUI() {\n  return _endCallUI.apply(this, arguments);\n} // Exponer funcin globalmente para el botn de colgar\nfunction _endCallUI() {\n  _endCallUI = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee15() {\n    var username, callContainer, callButton;\n    return _regenerator().w(function (_context15) {\n      while (1) switch (_context15.n) {\n        case 0:\n          username = sessionStorage.getItem('username');\n          callContainer = document.getElementById('callContainer');\n          callButton = document.getElementById('call-button');\n          if (!(inCall && callWithUser)) {\n            _context15.n = 1;\n            break;\n          }\n          _context15.n = 1;\n          return (0,_services_webrtcService_js__WEBPACK_IMPORTED_MODULE_3__.hangUp)(username, callWithUser);\n        case 1:\n          callContainer.style.display = 'none';\n          callContainer.innerHTML = '';\n          callButton.innerHTML = '';\n          callButton.title = 'Iniciar llamada';\n          inCall = false;\n          callWithUser = null;\n        case 2:\n          return _context15.a(2);\n      }\n    }, _callee15);\n  }));\n  return _endCallUI.apply(this, arguments);\n}\nwindow.hangUpCall = endCallUI;\n\n/**\r\n * Seleccionar usuario directamente (usado al recibir llamada)\r\n */\nfunction selectUserDirectly(username) {\n  var userButtons = document.querySelectorAll('.user-item');\n  userButtons.forEach(function (btn) {\n    if (btn.dataset.username === username) {\n      btn.click();\n    }\n  });\n}\n\n/**\r\n * Animar indicadores de audio durante la llamada\r\n */\nfunction animateAudioIndicators() {\n  var localWave = document.querySelector('.audio-wave.local');\n  var remoteWave = document.querySelector('.audio-wave.remote');\n  if (localWave) {\n    var spans = localWave.querySelectorAll('span');\n    spans.forEach(function (span, index) {\n      span.style.animation = \"wave 1s ease-in-out infinite\";\n      span.style.animationDelay = \"\".concat(index * 0.1, \"s\");\n    });\n  }\n  if (remoteWave) {\n    var _spans = remoteWave.querySelectorAll('span');\n    _spans.forEach(function (span, index) {\n      span.style.animation = \"wave 1s ease-in-out infinite\";\n      span.style.animationDelay = \"\".concat(index * 0.1, \"s\");\n    });\n  }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Chat);\n\n//# sourceURL=webpack://chat-web-client/./src/pages/Chat.js?\n}");

/***/ }),

/***/ "./src/pages/Login.js":
/*!****************************!*\
  !*** ./src/pages/Login.js ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = \"function\" == typeof Symbol ? Symbol : {}, n = r.iterator || \"@@iterator\", o = r.toStringTag || \"@@toStringTag\"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, \"_invoke\", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError(\"Generator is already running\"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = \"next\"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError(\"iterator result is not an object\"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i[\"return\"]) && t.call(i), c < 2 && (u = TypeError(\"The iterator does not provide a '\" + o + \"' method\"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, \"GeneratorFunction\")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, \"constructor\", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = \"GeneratorFunction\", _regeneratorDefine2(GeneratorFunctionPrototype, o, \"GeneratorFunction\"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, \"Generator\"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, \"toString\", function () { return \"[object Generator]\"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }\nfunction _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, \"\", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o(\"next\", 0), o(\"throw\", 1), o(\"return\", 2)); }, _regeneratorDefine2(e, r, n, t); }\nfunction asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"next\", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"throw\", n); } _next(void 0); }); }; }\nfunction Login() {\n  var container = document.createElement('div');\n  container.className = 'login-container';\n  var title = document.createElement('h1');\n  title.innerText = ' TCP Chat';\n  container.appendChild(title);\n  var subtitle = document.createElement('p');\n  subtitle.innerText = 'Multi-Protocol Chat System';\n  subtitle.style.marginBottom = '40px';\n  subtitle.style.color = '#666';\n  container.appendChild(subtitle);\n  var form = document.createElement('div');\n  form.className = 'login-form';\n  var usernameInput = document.createElement('input');\n  usernameInput.type = 'text';\n  usernameInput.placeholder = 'Enter your username';\n  usernameInput.id = 'username-input';\n  form.appendChild(usernameInput);\n  var loginButton = document.createElement('button');\n  loginButton.innerText = 'Join Chat';\n  loginButton.onclick = /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee() {\n    var username;\n    return _regenerator().w(function (_context) {\n      while (1) switch (_context.n) {\n        case 0:\n          username = usernameInput.value.trim();\n          if (username) {\n            // Store username in sessionStorage\n            sessionStorage.setItem('username', username);\n            // Navigate to chat\n            window.location.href = '/chat';\n          } else {\n            alert('Please enter a username');\n          }\n        case 1:\n          return _context.a(2);\n      }\n    }, _callee);\n  }));\n  form.appendChild(loginButton);\n  container.appendChild(form);\n  return container;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Login);\n\n//# sourceURL=webpack://chat-web-client/./src/pages/Login.js?\n}");

/***/ }),

/***/ "./src/router/Router.js":
/*!******************************!*\
  !*** ./src/router/Router.js ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Router: () => (/* binding */ Router)\n/* harmony export */ });\nvar Router = function Router(paths) {\n  var route = window.location.pathname;\n  var routeComponent = paths[route] || function () {\n    var notFound = document.createElement('p');\n    notFound.innerText = '404 - Not Found';\n    notFound.style.padding = '40px';\n    notFound.style.textAlign = 'center';\n    return notFound;\n  };\n  return routeComponent();\n};\n\n//# sourceURL=webpack://chat-web-client/./src/router/Router.js?\n}");

/***/ }),

/***/ "./src/router/routes.js":
/*!******************************!*\
  !*** ./src/router/routes.js ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   routes: () => (/* binding */ routes)\n/* harmony export */ });\n/* harmony import */ var _pages_Login_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../pages/Login.js */ \"./src/pages/Login.js\");\n/* harmony import */ var _pages_Chat_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../pages/Chat.js */ \"./src/pages/Chat.js\");\n/* harmony import */ var _Router_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Router.js */ \"./src/router/Router.js\");\n\n\n\nvar urls = {\n  '/': _pages_Login_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"],\n  '/chat': _pages_Chat_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\n};\nvar routes = (0,_Router_js__WEBPACK_IMPORTED_MODULE_2__.Router)(urls);\n\n//# sourceURL=webpack://chat-web-client/./src/router/routes.js?\n}");

/***/ }),

/***/ "./src/services/audioRecorder.js":
/*!***************************************!*\
  !*** ./src/services/audioRecorder.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cancelRecording: () => (/* binding */ cancelRecording),\n/* harmony export */   getAudioSupport: () => (/* binding */ getAudioSupport),\n/* harmony export */   isAudioRecordingSupported: () => (/* binding */ isAudioRecordingSupported),\n/* harmony export */   isCurrentlyRecording: () => (/* binding */ isCurrentlyRecording),\n/* harmony export */   playAudio: () => (/* binding */ playAudio),\n/* harmony export */   startRecording: () => (/* binding */ startRecording),\n/* harmony export */   stopRecording: () => (/* binding */ stopRecording)\n/* harmony export */ });\nfunction _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = \"function\" == typeof Symbol ? Symbol : {}, n = r.iterator || \"@@iterator\", o = r.toStringTag || \"@@toStringTag\"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, \"_invoke\", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError(\"Generator is already running\"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = \"next\"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError(\"iterator result is not an object\"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i[\"return\"]) && t.call(i), c < 2 && (u = TypeError(\"The iterator does not provide a '\" + o + \"' method\"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, \"GeneratorFunction\")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, \"constructor\", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = \"GeneratorFunction\", _regeneratorDefine2(GeneratorFunctionPrototype, o, \"GeneratorFunction\"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, \"Generator\"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, \"toString\", function () { return \"[object Generator]\"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }\nfunction _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, \"\", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o(\"next\", 0), o(\"throw\", 1), o(\"return\", 2)); }, _regeneratorDefine2(e, r, n, t); }\nfunction asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"next\", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"throw\", n); } _next(void 0); }); }; }\n/**\r\n * Audio Recorder Module\r\n * Graba audio desde el micrfono del navegador usando MediaRecorder API\r\n */\n\nvar mediaRecorder = null;\nvar audioChunks = [];\nvar stream = null;\nvar isRecording = false;\n\n/**\r\n * Iniciar grabacin de audio\r\n * @returns {Promise<boolean>} true si la grabacin comenz exitosamente\r\n */\nfunction startRecording() {\n  return _startRecording.apply(this, arguments);\n}\n\n/**\r\n * Detener grabacin y obtener audio como Uint8Array\r\n * @returns {Promise<Uint8Array>} Audio en formato byte array\r\n */\nfunction _startRecording() {\n  _startRecording = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee() {\n    var mimeType, _t;\n    return _regenerator().w(function (_context) {\n      while (1) switch (_context.p = _context.n) {\n        case 0:\n          _context.p = 0;\n          if (!isRecording) {\n            _context.n = 1;\n            break;\n          }\n          console.warn('[AUDIO] Ya hay una grabacin en curso');\n          return _context.a(2, false);\n        case 1:\n          console.log('[AUDIO]  Solicitando acceso al micrfono...');\n\n          // Solicitar permiso de micrfono\n          _context.n = 2;\n          return navigator.mediaDevices.getUserMedia({\n            audio: {\n              echoCancellation: true,\n              noiseSuppression: true,\n              sampleRate: 44100\n            }\n          });\n        case 2:\n          stream = _context.v;\n          console.log('[AUDIO]  Acceso al micrfono concedido');\n\n          // Determinar el tipo MIME soportado\n          mimeType = 'audio/webm';\n          if (MediaRecorder.isTypeSupported('audio/webm;codecs=opus')) {\n            mimeType = 'audio/webm;codecs=opus';\n          } else if (MediaRecorder.isTypeSupported('audio/ogg;codecs=opus')) {\n            mimeType = 'audio/ogg;codecs=opus';\n          } else if (MediaRecorder.isTypeSupported('audio/mp4')) {\n            mimeType = 'audio/mp4';\n          }\n          console.log('[AUDIO]  Using MIME type:', mimeType);\n\n          // Crear MediaRecorder\n          mediaRecorder = new MediaRecorder(stream, {\n            mimeType: mimeType\n          });\n          audioChunks = [];\n\n          // Evento: se reciben datos de audio\n          mediaRecorder.ondataavailable = function (event) {\n            if (event.data.size > 0) {\n              audioChunks.push(event.data);\n              console.log('[AUDIO]  Chunk received:', event.data.size, 'bytes');\n            }\n          };\n\n          // Evento: grabacin iniciada\n          mediaRecorder.onstart = function () {\n            console.log('[AUDIO]  Grabacin iniciada');\n            isRecording = true;\n          };\n\n          // Evento: grabacin detenida\n          mediaRecorder.onstop = function () {\n            console.log('[AUDIO]  Grabacin detenida');\n            isRecording = false;\n          };\n\n          // Iniciar grabacin (captura cada 1 segundo)\n          mediaRecorder.start(1000);\n          return _context.a(2, true);\n        case 3:\n          _context.p = 3;\n          _t = _context.v;\n          console.error('[AUDIO]  Error iniciando grabacin:', _t);\n          if (_t.name === 'NotAllowedError') {\n            alert('Permiso de micrfono denegado. Por favor, habilita el micrfono en la configuracin del navegador.');\n          } else if (_t.name === 'NotFoundError') {\n            alert('No se encontr ningn micrfono. Por favor, conecta un micrfono.');\n          } else {\n            alert('Error al acceder al micrfono: ' + _t.message);\n          }\n          return _context.a(2, false);\n      }\n    }, _callee, null, [[0, 3]]);\n  }));\n  return _startRecording.apply(this, arguments);\n}\nfunction stopRecording() {\n  return _stopRecording.apply(this, arguments);\n}\n\n/**\r\n * Cancelar grabacin sin guardar\r\n */\nfunction _stopRecording() {\n  _stopRecording = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3() {\n    return _regenerator().w(function (_context3) {\n      while (1) switch (_context3.n) {\n        case 0:\n          return _context3.a(2, new Promise(function (resolve, reject) {\n            if (!mediaRecorder || mediaRecorder.state === 'inactive') {\n              reject(new Error('[AUDIO] No hay grabacin activa'));\n              return;\n            }\n            console.log('[AUDIO]  Deteniendo grabacin...');\n\n            // Cuando se detenga, procesar el audio\n            mediaRecorder.onstop = /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2() {\n              var audioBlob, arrayBuffer, uint8Array, _t2;\n              return _regenerator().w(function (_context2) {\n                while (1) switch (_context2.p = _context2.n) {\n                  case 0:\n                    _context2.p = 0;\n                    // Combinar chunks en un Blob\n                    audioBlob = new Blob(audioChunks, {\n                      type: mediaRecorder.mimeType\n                    });\n                    console.log('[AUDIO]  Audio Blob created:', audioBlob.size, 'bytes');\n\n                    // Convertir Blob a ArrayBuffer\n                    _context2.n = 1;\n                    return audioBlob.arrayBuffer();\n                  case 1:\n                    arrayBuffer = _context2.v;\n                    // Convertir a Uint8Array para enviar por Ice\n                    uint8Array = new Uint8Array(arrayBuffer);\n                    console.log('[AUDIO]  Audio procesado:', uint8Array.length, 'bytes');\n\n                    // Limpiar\n                    cleanup();\n                    resolve(uint8Array);\n                    _context2.n = 3;\n                    break;\n                  case 2:\n                    _context2.p = 2;\n                    _t2 = _context2.v;\n                    console.error('[AUDIO]  Error procesando audio:', _t2);\n                    cleanup();\n                    reject(_t2);\n                  case 3:\n                    return _context2.a(2);\n                }\n              }, _callee2, null, [[0, 2]]);\n            }));\n\n            // Detener grabacin\n            mediaRecorder.stop();\n          }));\n      }\n    }, _callee3);\n  }));\n  return _stopRecording.apply(this, arguments);\n}\nfunction cancelRecording() {\n  console.log('[AUDIO]  Grabacin cancelada');\n  if (mediaRecorder && mediaRecorder.state !== 'inactive') {\n    mediaRecorder.stop();\n  }\n  cleanup();\n}\n\n/**\r\n * Limpiar recursos\r\n */\nfunction cleanup() {\n  // Detener todos los tracks del stream\n  if (stream) {\n    stream.getTracks().forEach(function (track) {\n      track.stop();\n      console.log('[AUDIO]  Track stopped');\n    });\n    stream = null;\n  }\n\n  // Resetear variables\n  mediaRecorder = null;\n  audioChunks = [];\n  isRecording = false;\n}\n\n/**\r\n * Verificar si hay una grabacin activa\r\n * @returns {boolean}\r\n */\nfunction isCurrentlyRecording() {\n  return isRecording;\n}\n\n/**\r\n * Reproducir audio desde un Uint8Array\r\n * @param {Uint8Array} audioData - Datos de audio\r\n * @param {string} mimeType - Tipo MIME del audio (default: audio/webm)\r\n * @returns {Promise<void>}\r\n */\nfunction playAudio(_x) {\n  return _playAudio.apply(this, arguments);\n}\n\n/**\r\n * Verificar si el navegador soporta grabacin de audio\r\n * @returns {boolean}\r\n */\nfunction _playAudio() {\n  _playAudio = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(audioData) {\n    var mimeType,\n      audioBlob,\n      audioUrl,\n      audio,\n      _args4 = arguments,\n      _t3;\n    return _regenerator().w(function (_context4) {\n      while (1) switch (_context4.p = _context4.n) {\n        case 0:\n          mimeType = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : 'audio/webm';\n          _context4.p = 1;\n          console.log('[AUDIO]  Reproduciendo audio:', audioData.length, 'bytes');\n\n          // Convertir Uint8Array a Blob\n          audioBlob = new Blob([audioData], {\n            type: mimeType\n          }); // Crear URL del blob\n          audioUrl = URL.createObjectURL(audioBlob); // Crear elemento de audio\n          audio = new Audio(audioUrl); // Reproducir\n          _context4.n = 2;\n          return audio.play();\n        case 2:\n          console.log('[AUDIO]  Audio reproducindose');\n\n          // Limpiar URL cuando termine\n          audio.onended = function () {\n            URL.revokeObjectURL(audioUrl);\n            console.log('[AUDIO]  Audio finalizado');\n          };\n          _context4.n = 4;\n          break;\n        case 3:\n          _context4.p = 3;\n          _t3 = _context4.v;\n          console.error('[AUDIO]  Error reproduciendo audio:', _t3);\n          throw _t3;\n        case 4:\n          return _context4.a(2);\n      }\n    }, _callee4, null, [[1, 3]]);\n  }));\n  return _playAudio.apply(this, arguments);\n}\nfunction isAudioRecordingSupported() {\n  return !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia && window.MediaRecorder);\n}\n\n/**\r\n * Obtener informacin sobre soporte de audio\r\n * @returns {Object}\r\n */\nfunction getAudioSupport() {\n  return {\n    mediaDevices: !!navigator.mediaDevices,\n    getUserMedia: !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia),\n    mediaRecorder: !!window.MediaRecorder,\n    supportedTypes: {\n      webmOpus: MediaRecorder.isTypeSupported('audio/webm;codecs=opus'),\n      webm: MediaRecorder.isTypeSupported('audio/webm'),\n      oggOpus: MediaRecorder.isTypeSupported('audio/ogg;codecs=opus'),\n      mp4: MediaRecorder.isTypeSupported('audio/mp4')\n    }\n  };\n}\n\n//# sourceURL=webpack://chat-web-client/./src/services/audioRecorder.js?\n}");

/***/ }),

/***/ "./src/services/iceDelegate.js":
/*!*************************************!*\
  !*** ./src/services/iceDelegate.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   acceptCall: () => (/* binding */ acceptCall),\n/* harmony export */   addMemberToGroup: () => (/* binding */ addMemberToGroup),\n/* harmony export */   createGroup: () => (/* binding */ createGroup),\n/* harmony export */   endCall: () => (/* binding */ endCall),\n/* harmony export */   getAllUsers: () => (/* binding */ getAllUsers),\n/* harmony export */   getGroupMembers: () => (/* binding */ getGroupMembers),\n/* harmony export */   getGroups: () => (/* binding */ getGroups),\n/* harmony export */   getHistory: () => (/* binding */ getHistory),\n/* harmony export */   getOnlineUsers: () => (/* binding */ getOnlineUsers),\n/* harmony export */   getPendingMessages: () => (/* binding */ getPendingMessages),\n/* harmony export */   getUserGroups: () => (/* binding */ getUserGroups),\n/* harmony export */   initIce: () => (/* binding */ initIce),\n/* harmony export */   initiateCall: () => (/* binding */ initiateCall),\n/* harmony export */   login: () => (/* binding */ login),\n/* harmony export */   logout: () => (/* binding */ logout),\n/* harmony export */   sendAudioChunk: () => (/* binding */ sendAudioChunk),\n/* harmony export */   sendICECandidate: () => (/* binding */ sendICECandidate),\n/* harmony export */   sendMessageToGroup: () => (/* binding */ sendMessageToGroup),\n/* harmony export */   sendMessageToUser: () => (/* binding */ sendMessageToUser),\n/* harmony export */   sendVoiceNoteToGroup: () => (/* binding */ sendVoiceNoteToGroup),\n/* harmony export */   sendVoiceNoteToUser: () => (/* binding */ sendVoiceNoteToUser),\n/* harmony export */   sendWebRTCSignal: () => (/* binding */ sendWebRTCSignal),\n/* harmony export */   shutdownIce: () => (/* binding */ shutdownIce)\n/* harmony export */ });\n/* harmony import */ var ice__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ice */ \"./node_modules/ice/src/index.js\");\n/* harmony import */ var _generated_Chat_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../generated/Chat.js */ \"./src/generated/Chat.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = \"function\" == typeof Symbol ? Symbol : {}, n = r.iterator || \"@@iterator\", o = r.toStringTag || \"@@toStringTag\"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, \"_invoke\", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError(\"Generator is already running\"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = \"next\"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError(\"iterator result is not an object\"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i[\"return\"]) && t.call(i), c < 2 && (u = TypeError(\"The iterator does not provide a '\" + o + \"' method\"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, \"GeneratorFunction\")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, \"constructor\", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = \"GeneratorFunction\", _regeneratorDefine2(GeneratorFunctionPrototype, o, \"GeneratorFunction\"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, \"Generator\"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, \"toString\", function () { return \"[object Generator]\"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }\nfunction _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, \"\", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o(\"next\", 0), o(\"throw\", 1), o(\"return\", 2)); }, _regeneratorDefine2(e, r, n, t); }\nfunction asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"next\", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"throw\", n); } _next(void 0); }); }; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n/**\r\n * ICE Delegate Service - Comunicacin con el backend Java va Ice con WebSocket\r\n * Incluye callbacks para notificaciones en tiempo real\r\n */\n\n\n\n// Importar el mdulo generado - se carga globalmente\n\nvar Chat = window.Chat || ice__WEBPACK_IMPORTED_MODULE_0__.Ice._ModuleRegistry.module(\"Chat\");\nvar HOSTNAME = 'localhost';\nvar ICE_PORT = 10001; // WebSocket port\n\nvar communicator = null;\nvar chatServicePrx = null;\nvar callbackAdapter = null;\nvar currentUsername = null;\n\n// Callbacks para notificaciones en tiempo real\nvar onMessageReceivedCallback = null;\nvar onUserStatusChangedCallback = null;\nvar onGroupMemberAddedCallback = null;\nvar onVoiceNoteReceivedCallback = null;\n\n// Callbacks para llamadas por WebSocket\nvar onIncomingCallCallback = null;\nvar onWebRTCSignalCallback = null;\nvar onICECandidateCallback = null;\nvar onCallEndedCallback = null;\nvar onAudioChunkCallback = null;\nvar onCallAcceptedCallback = null;\n\n/**\r\n * Implementacin del callback ChatCallback\r\n * Hereda de la clase generada Chat.ChatCallback\r\n */\nvar ChatCallbackI = /*#__PURE__*/function (_Chat$ChatCallback) {\n  function ChatCallbackI() {\n    _classCallCheck(this, ChatCallbackI);\n    return _callSuper(this, ChatCallbackI, arguments);\n  }\n  _inherits(ChatCallbackI, _Chat$ChatCallback);\n  return _createClass(ChatCallbackI, [{\n    key: \"onNewMessage\",\n    value: function onNewMessage(msg, current) {\n      console.log('[ICE CALLBACK]  onNewMessage INVOCADO!!!');\n      console.log('[ICE CALLBACK] Message:', msg);\n      console.log('[ICE CALLBACK] From:', msg.from, 'To:', msg.to, 'Content:', msg.content);\n      try {\n        if (onMessageReceivedCallback) {\n          onMessageReceivedCallback({\n            from: msg.from,\n            to: msg.to,\n            content: msg.content,\n            timestamp: msg.timestamp,\n            isGroup: msg.isGroup\n          });\n          console.log('[ICE CALLBACK]  Message callback executed');\n        } else {\n          console.error('[ICE CALLBACK]  No message callback registered!');\n        }\n      } catch (error) {\n        console.error('[ICE CALLBACK] Error in callback:', error);\n      }\n    }\n  }, {\n    key: \"onUserStatusChanged\",\n    value: function onUserStatusChanged(user, current) {\n      console.log('[ICE CALLBACK]  User status changed:', user);\n      try {\n        if (onUserStatusChangedCallback) {\n          onUserStatusChangedCallback({\n            username: user.username,\n            isOnline: user.isOnline\n          });\n        }\n      } catch (error) {\n        console.error('[ICE CALLBACK] Error in status callback:', error);\n      }\n    }\n  }, {\n    key: \"onGroupMemberAdded\",\n    value: function onGroupMemberAdded(groupName, username, current) {\n      console.log('[ICE CALLBACK]  Group member added:', groupName, username);\n      try {\n        if (onGroupMemberAddedCallback) {\n          onGroupMemberAddedCallback(groupName, username);\n        }\n      } catch (error) {\n        console.error('[ICE CALLBACK] Error in group callback:', error);\n      }\n    }\n  }, {\n    key: \"onVoiceNoteReceived\",\n    value: function onVoiceNoteReceived(from, to, audioData, isGroup, current) {\n      console.log('[ICE CALLBACK]  Voice note received from:', from, 'to:', to, 'isGroup:', isGroup, 'Size:', audioData.length);\n      try {\n        if (onVoiceNoteReceivedCallback) {\n          onVoiceNoteReceivedCallback(from, to, audioData, isGroup);\n        }\n      } catch (error) {\n        console.error('[ICE CALLBACK] Error in voice callback:', error);\n      }\n    }\n\n    // ===== CALLBACKS DE LLAMADAS WEBRTC =====\n  }, {\n    key: \"onIncomingCall\",\n    value: function onIncomingCall(from, current) {\n      console.log('[ICE CALLBACK]  Incoming call from:', from);\n      try {\n        if (onIncomingCallCallback) {\n          onIncomingCallCallback(from);\n        }\n      } catch (error) {\n        console.error('[ICE CALLBACK] Error in incoming call callback:', error);\n      }\n    }\n  }, {\n    key: \"onWebRTCSignal\",\n    value: function onWebRTCSignal(from, signalType, signalData, current) {\n      console.log('[ICE CALLBACK]  WebRTC signal from:', from, 'type:', signalType);\n      try {\n        if (onWebRTCSignalCallback) {\n          onWebRTCSignalCallback(from, signalType, signalData);\n        }\n      } catch (error) {\n        console.error('[ICE CALLBACK] Error in WebRTC signal callback:', error);\n      }\n    }\n  }, {\n    key: \"onICECandidate\",\n    value: function onICECandidate(from, candidate, current) {\n      console.log('[ICE CALLBACK]  ICE candidate from:', from);\n      try {\n        if (onICECandidateCallback) {\n          onICECandidateCallback(from, candidate);\n        }\n      } catch (error) {\n        console.error('[ICE CALLBACK] Error in ICE candidate callback:', error);\n      }\n    }\n  }, {\n    key: \"onCallEnded\",\n    value: function onCallEnded(from, current) {\n      console.log('[ICE CALLBACK]  Call ended by:', from);\n      try {\n        if (onCallEndedCallback) {\n          onCallEndedCallback(from);\n        }\n      } catch (error) {\n        console.error('[ICE CALLBACK] Error in call ended callback:', error);\n      }\n    }\n  }, {\n    key: \"onAudioChunk\",\n    value: function onAudioChunk(from, audioData, current) {\n      console.log('[ICE CALLBACK]  Audio chunk from:', from, 'size:', audioData.length);\n      try {\n        if (onAudioChunkCallback) {\n          onAudioChunkCallback(from, audioData);\n        }\n      } catch (error) {\n        console.error('[ICE CALLBACK] Error in audio chunk callback:', error);\n      }\n    }\n  }, {\n    key: \"onCallAccepted\",\n    value: function onCallAccepted(from, current) {\n      console.log('[ICE CALLBACK]  Call accepted by:', from);\n      try {\n        if (onCallAcceptedCallback) {\n          onCallAcceptedCallback(from);\n        }\n      } catch (error) {\n        console.error('[ICE CALLBACK] Error in call accepted callback:', error);\n      }\n    }\n  }]);\n}(Chat.ChatCallback);\n\n/**\r\n * Inicializar conexin Ice con callbacks bidireccionales\r\n */\nfunction initIce(_x) {\n  return _initIce.apply(this, arguments);\n}\n\n/**\r\n * Cerrar conexin Ice\r\n */\nfunction _initIce() {\n  _initIce = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(username) {\n    var callbacks,\n      initData,\n      proxyString,\n      proxy,\n      connection,\n      callbackServant,\n      callbackPrx,\n      response,\n      _args = arguments,\n      _t;\n    return _regenerator().w(function (_context) {\n      while (1) switch (_context.p = _context.n) {\n        case 0:\n          callbacks = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n          _context.p = 1;\n          console.log('[ICE]  Initializing Ice communicator...');\n\n          // Guardar callbacks\n          onMessageReceivedCallback = callbacks.onMessageReceived;\n          onUserStatusChangedCallback = callbacks.onUserStatusChanged;\n          onGroupMemberAddedCallback = callbacks.onGroupMemberAdded;\n          onVoiceNoteReceivedCallback = callbacks.onVoiceNoteReceived;\n\n          // Callbacks de llamadas\n          onIncomingCallCallback = callbacks.onIncomingCall;\n          onWebRTCSignalCallback = callbacks.onWebRTCSignal;\n          onICECandidateCallback = callbacks.onICECandidate;\n          onCallEndedCallback = callbacks.onCallEnded;\n          onAudioChunkCallback = callbacks.onAudioChunk;\n          onCallAcceptedCallback = callbacks.onCallAccepted;\n          currentUsername = username;\n\n          // Inicializar comunicador Ice\n          initData = new ice__WEBPACK_IMPORTED_MODULE_0__.Ice.InitializationData();\n          initData.properties = ice__WEBPACK_IMPORTED_MODULE_0__.Ice.createProperties();\n          initData.properties.setProperty(\"Ice.Default.Protocol\", \"ws\");\n          communicator = ice__WEBPACK_IMPORTED_MODULE_0__.Ice.initialize(initData);\n          console.log('[ICE]  Communicator initialized');\n\n          // Crear proxy al servicio ChatService via WebSocket\n          proxyString = \"ChatService:ws -h \".concat(HOSTNAME, \" -p \").concat(ICE_PORT);\n          console.log('[ICE]  Connecting to:', proxyString);\n          proxy = communicator.stringToProxy(proxyString); // Hacer checkedCast con el proxy del servicio\n          _context.n = 2;\n          return Chat.ChatServicePrx.checkedCast(proxy);\n        case 2:\n          chatServicePrx = _context.v;\n          if (chatServicePrx) {\n            _context.n = 3;\n            break;\n          }\n          throw new Error(\"Invalid proxy - ChatService not available\");\n        case 3:\n          console.log('[ICE]  Connected to ChatService');\n\n          // Crear adaptador para callbacks (comunicacin bidireccional)\n          console.log('[ICE]  Creating callback adapter...');\n          _context.n = 4;\n          return communicator.createObjectAdapter(\"\");\n        case 4:\n          callbackAdapter = _context.v;\n          // CRTICO: Obtener la conexin cacheada y vincular el adaptador\n          connection = chatServicePrx.ice_getCachedConnection();\n          connection.setAdapter(callbackAdapter);\n          console.log('[ICE]  Adapter linked to connection');\n\n          // Crear callback servant\n          callbackServant = new ChatCallbackI(); // Agregar servant con UUID automtico (patrn del profesor)\n          callbackPrx = Chat.ChatCallbackPrx.uncheckedCast(callbackAdapter.addWithUUID(callbackServant));\n          console.log('[ICE]  Callback proxy created:', callbackPrx.toString());\n\n          // Login con callback para notificaciones push\n          console.log('[ICE]  Logging in user:', username);\n          _context.n = 5;\n          return chatServicePrx.login(username, callbackPrx);\n        case 5:\n          response = _context.v;\n          console.log('[ICE]  Login complete:', response.message);\n          return _context.a(2, {\n            success: response.success,\n            message: response.message\n          });\n        case 6:\n          _context.p = 6;\n          _t = _context.v;\n          console.error('[ICE]  Error initializing Ice:', _t);\n          return _context.a(2, {\n            success: false,\n            message: _t.message || 'Error connecting to Ice server'\n          });\n      }\n    }, _callee, null, [[1, 6]]);\n  }));\n  return _initIce.apply(this, arguments);\n}\nfunction shutdownIce() {\n  return _shutdownIce.apply(this, arguments);\n}\n\n/**\r\n * Initialize Ice communicator and get proxy (helper interno)\r\n */\nfunction _shutdownIce() {\n  _shutdownIce = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2() {\n    var _t2;\n    return _regenerator().w(function (_context2) {\n      while (1) switch (_context2.p = _context2.n) {\n        case 0:\n          _context2.p = 0;\n          if (!(currentUsername && chatServicePrx)) {\n            _context2.n = 1;\n            break;\n          }\n          _context2.n = 1;\n          return chatServicePrx.logout(currentUsername);\n        case 1:\n          if (!callbackAdapter) {\n            _context2.n = 2;\n            break;\n          }\n          _context2.n = 2;\n          return callbackAdapter.destroy();\n        case 2:\n          if (!communicator) {\n            _context2.n = 3;\n            break;\n          }\n          _context2.n = 3;\n          return communicator.destroy();\n        case 3:\n          console.log('[ICE]  Ice connection closed');\n          _context2.n = 5;\n          break;\n        case 4:\n          _context2.p = 4;\n          _t2 = _context2.v;\n          console.error('[ICE] Error shutting down Ice:', _t2);\n        case 5:\n          return _context2.a(2);\n      }\n    }, _callee2, null, [[0, 4]]);\n  }));\n  return _shutdownIce.apply(this, arguments);\n}\nfunction getProxy() {\n  return _getProxy.apply(this, arguments);\n}\n/**\r\n * Login to chat (legacy - use initIce instead)\r\n */\nfunction _getProxy() {\n  _getProxy = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3() {\n    return _regenerator().w(function (_context3) {\n      while (1) switch (_context3.n) {\n        case 0:\n          if (!chatServicePrx) {\n            _context3.n = 1;\n            break;\n          }\n          return _context3.a(2, chatServicePrx);\n        case 1:\n          throw new Error('[ICE] Not connected. Call initIce() first.');\n        case 2:\n          return _context3.a(2);\n      }\n    }, _callee3);\n  }));\n  return _getProxy.apply(this, arguments);\n}\nfunction login(_x2) {\n  return _login.apply(this, arguments);\n}\n\n/**\r\n * Logout from chat\r\n */\nfunction _login() {\n  _login = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(username) {\n    return _regenerator().w(function (_context4) {\n      while (1) switch (_context4.n) {\n        case 0:\n          return _context4.a(2, {\n            success: true,\n            message: 'Use initIce instead'\n          });\n      }\n    }, _callee4);\n  }));\n  return _login.apply(this, arguments);\n}\nfunction logout(_x3) {\n  return _logout.apply(this, arguments);\n}\n\n/**\r\n * Get online users\r\n */\nfunction _logout() {\n  _logout = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5(username) {\n    var proxy, response, _t3;\n    return _regenerator().w(function (_context5) {\n      while (1) switch (_context5.p = _context5.n) {\n        case 0:\n          _context5.p = 0;\n          _context5.n = 1;\n          return getProxy();\n        case 1:\n          proxy = _context5.v;\n          _context5.n = 2;\n          return proxy.logout(username);\n        case 2:\n          response = _context5.v;\n          _context5.n = 3;\n          return shutdownIce();\n        case 3:\n          return _context5.a(2, {\n            success: response.success,\n            message: response.message\n          });\n        case 4:\n          _context5.p = 4;\n          _t3 = _context5.v;\n          console.error('[ICE] Logout error:', _t3);\n          return _context5.a(2, {\n            success: false,\n            message: _t3.message\n          });\n      }\n    }, _callee5, null, [[0, 4]]);\n  }));\n  return _logout.apply(this, arguments);\n}\nfunction getOnlineUsers() {\n  return _getOnlineUsers.apply(this, arguments);\n}\n\n/**\r\n * Get all users with status\r\n */\nfunction _getOnlineUsers() {\n  _getOnlineUsers = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6() {\n    var proxy, users, usersArray, _t4;\n    return _regenerator().w(function (_context6) {\n      while (1) switch (_context6.p = _context6.n) {\n        case 0:\n          _context6.p = 0;\n          _context6.n = 1;\n          return getProxy();\n        case 1:\n          proxy = _context6.v;\n          _context6.n = 2;\n          return proxy.getOnlineUsers();\n        case 2:\n          users = _context6.v;\n          // Convertir Ice sequence a array JavaScript\n          usersArray = users ? Array.from(users) : [];\n          console.log('[ICE] getOnlineUsers result:', usersArray);\n          return _context6.a(2, {\n            success: true,\n            users: usersArray\n          });\n        case 3:\n          _context6.p = 3;\n          _t4 = _context6.v;\n          console.error('[ICE] Get users error:', _t4);\n          return _context6.a(2, {\n            success: false,\n            message: _t4.message\n          });\n      }\n    }, _callee6, null, [[0, 3]]);\n  }));\n  return _getOnlineUsers.apply(this, arguments);\n}\nfunction getAllUsers() {\n  return _getAllUsers.apply(this, arguments);\n}\n\n/**\r\n * Create a group\r\n */\nfunction _getAllUsers() {\n  _getAllUsers = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee7() {\n    var proxy, usersMap, usersObj, _t5;\n    return _regenerator().w(function (_context7) {\n      while (1) switch (_context7.p = _context7.n) {\n        case 0:\n          _context7.p = 0;\n          _context7.n = 1;\n          return getProxy();\n        case 1:\n          proxy = _context7.v;\n          _context7.n = 2;\n          return proxy.getAllUsers();\n        case 2:\n          usersMap = _context7.v;\n          // Convertir Ice Map a objeto JavaScript\n          usersObj = {};\n          if (usersMap) {\n            if (usersMap instanceof Map) {\n              usersMap.forEach(function (value, key) {\n                usersObj[key] = value;\n              });\n            } else {\n              // Ya es un objeto plano\n              Object.assign(usersObj, usersMap);\n            }\n          }\n          console.log('[ICE] getAllUsers result:', usersObj);\n          return _context7.a(2, {\n            success: true,\n            users: usersObj\n          });\n        case 3:\n          _context7.p = 3;\n          _t5 = _context7.v;\n          console.error('[ICE] Get all users error:', _t5);\n          return _context7.a(2, {\n            success: false,\n            message: _t5.message\n          });\n      }\n    }, _callee7, null, [[0, 3]]);\n  }));\n  return _getAllUsers.apply(this, arguments);\n}\nfunction createGroup(_x4, _x5) {\n  return _createGroup.apply(this, arguments);\n}\n\n/**\r\n * Add user to group\r\n */\nfunction _createGroup() {\n  _createGroup = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee8(groupName, creator) {\n    var proxy, response, _t6;\n    return _regenerator().w(function (_context8) {\n      while (1) switch (_context8.p = _context8.n) {\n        case 0:\n          _context8.p = 0;\n          _context8.n = 1;\n          return getProxy();\n        case 1:\n          proxy = _context8.v;\n          _context8.n = 2;\n          return proxy.createGroup(groupName, creator);\n        case 2:\n          response = _context8.v;\n          return _context8.a(2, {\n            success: response.success,\n            message: response.message\n          });\n        case 3:\n          _context8.p = 3;\n          _t6 = _context8.v;\n          console.error('[ICE] Create group error:', _t6);\n          return _context8.a(2, {\n            success: false,\n            message: _t6.message\n          });\n      }\n    }, _callee8, null, [[0, 3]]);\n  }));\n  return _createGroup.apply(this, arguments);\n}\nfunction addMemberToGroup(_x6, _x7) {\n  return _addMemberToGroup.apply(this, arguments);\n}\n\n/**\r\n * Get all groups\r\n */\nfunction _addMemberToGroup() {\n  _addMemberToGroup = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee9(groupName, username) {\n    var proxy, response, _t7;\n    return _regenerator().w(function (_context9) {\n      while (1) switch (_context9.p = _context9.n) {\n        case 0:\n          _context9.p = 0;\n          _context9.n = 1;\n          return getProxy();\n        case 1:\n          proxy = _context9.v;\n          _context9.n = 2;\n          return proxy.addToGroup(groupName, username);\n        case 2:\n          response = _context9.v;\n          return _context9.a(2, {\n            success: response.success,\n            message: response.message\n          });\n        case 3:\n          _context9.p = 3;\n          _t7 = _context9.v;\n          console.error('[ICE] Add to group error:', _t7);\n          return _context9.a(2, {\n            success: false,\n            message: _t7.message\n          });\n      }\n    }, _callee9, null, [[0, 3]]);\n  }));\n  return _addMemberToGroup.apply(this, arguments);\n}\nfunction getGroups() {\n  return _getGroups.apply(this, arguments);\n}\n\n/**\r\n * Get user groups\r\n */\nfunction _getGroups() {\n  _getGroups = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee0() {\n    var proxy, groups, _t8;\n    return _regenerator().w(function (_context0) {\n      while (1) switch (_context0.p = _context0.n) {\n        case 0:\n          _context0.p = 0;\n          _context0.n = 1;\n          return getProxy();\n        case 1:\n          proxy = _context0.v;\n          _context0.n = 2;\n          return proxy.getGroups();\n        case 2:\n          groups = _context0.v;\n          return _context0.a(2, {\n            success: true,\n            groups: groups || []\n          });\n        case 3:\n          _context0.p = 3;\n          _t8 = _context0.v;\n          console.error('[ICE] Get groups error:', _t8);\n          return _context0.a(2, {\n            success: false,\n            message: _t8.message\n          });\n      }\n    }, _callee0, null, [[0, 3]]);\n  }));\n  return _getGroups.apply(this, arguments);\n}\nfunction getUserGroups(_x8) {\n  return _getUserGroups.apply(this, arguments);\n}\n\n/**\r\n * Get group members\r\n */\nfunction _getUserGroups() {\n  _getUserGroups = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee1(username) {\n    var proxy, groups, _t9;\n    return _regenerator().w(function (_context1) {\n      while (1) switch (_context1.p = _context1.n) {\n        case 0:\n          _context1.p = 0;\n          _context1.n = 1;\n          return getProxy();\n        case 1:\n          proxy = _context1.v;\n          _context1.n = 2;\n          return proxy.getUserGroups(username);\n        case 2:\n          groups = _context1.v;\n          return _context1.a(2, {\n            success: true,\n            groups: groups || []\n          });\n        case 3:\n          _context1.p = 3;\n          _t9 = _context1.v;\n          console.error('[ICE] Get user groups error:', _t9);\n          return _context1.a(2, {\n            success: false,\n            message: _t9.message\n          });\n      }\n    }, _callee1, null, [[0, 3]]);\n  }));\n  return _getUserGroups.apply(this, arguments);\n}\nfunction getGroupMembers(_x9) {\n  return _getGroupMembers.apply(this, arguments);\n}\n\n/**\r\n * Send message to user\r\n */\nfunction _getGroupMembers() {\n  _getGroupMembers = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee10(groupName) {\n    var proxy, members, _t0;\n    return _regenerator().w(function (_context10) {\n      while (1) switch (_context10.p = _context10.n) {\n        case 0:\n          _context10.p = 0;\n          _context10.n = 1;\n          return getProxy();\n        case 1:\n          proxy = _context10.v;\n          _context10.n = 2;\n          return proxy.getGroupMembers(groupName);\n        case 2:\n          members = _context10.v;\n          return _context10.a(2, {\n            success: true,\n            members: members || []\n          });\n        case 3:\n          _context10.p = 3;\n          _t0 = _context10.v;\n          console.error('[ICE] Get group members error:', _t0);\n          return _context10.a(2, {\n            success: false,\n            message: _t0.message\n          });\n      }\n    }, _callee10, null, [[0, 3]]);\n  }));\n  return _getGroupMembers.apply(this, arguments);\n}\nfunction sendMessageToUser(_x0, _x1, _x10) {\n  return _sendMessageToUser.apply(this, arguments);\n}\n\n/**\r\n * Send message to group\r\n */\nfunction _sendMessageToUser() {\n  _sendMessageToUser = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee11(from, to, content) {\n    var proxy, response, _t1;\n    return _regenerator().w(function (_context11) {\n      while (1) switch (_context11.p = _context11.n) {\n        case 0:\n          _context11.p = 0;\n          _context11.n = 1;\n          return getProxy();\n        case 1:\n          proxy = _context11.v;\n          _context11.n = 2;\n          return proxy.sendMessageToUser(from, to, content);\n        case 2:\n          response = _context11.v;\n          return _context11.a(2, {\n            success: response.success,\n            message: response.message\n          });\n        case 3:\n          _context11.p = 3;\n          _t1 = _context11.v;\n          console.error('[ICE] Send message error:', _t1);\n          return _context11.a(2, {\n            success: false,\n            message: _t1.message\n          });\n      }\n    }, _callee11, null, [[0, 3]]);\n  }));\n  return _sendMessageToUser.apply(this, arguments);\n}\nfunction sendMessageToGroup(_x11, _x12, _x13) {\n  return _sendMessageToGroup.apply(this, arguments);\n}\n\n/**\r\n * Get message history\r\n */\nfunction _sendMessageToGroup() {\n  _sendMessageToGroup = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee12(from, groupName, content) {\n    var proxy, response, _t10;\n    return _regenerator().w(function (_context12) {\n      while (1) switch (_context12.p = _context12.n) {\n        case 0:\n          _context12.p = 0;\n          _context12.n = 1;\n          return getProxy();\n        case 1:\n          proxy = _context12.v;\n          _context12.n = 2;\n          return proxy.sendMessageToGroup(from, groupName, content);\n        case 2:\n          response = _context12.v;\n          return _context12.a(2, {\n            success: response.success,\n            message: response.message\n          });\n        case 3:\n          _context12.p = 3;\n          _t10 = _context12.v;\n          console.error('[ICE] Send group message error:', _t10);\n          return _context12.a(2, {\n            success: false,\n            message: _t10.message\n          });\n      }\n    }, _callee12, null, [[0, 3]]);\n  }));\n  return _sendMessageToGroup.apply(this, arguments);\n}\nfunction getHistory(_x14) {\n  return _getHistory.apply(this, arguments);\n}\n\n/**\r\n * Get pending messages (for initial sync)\r\n */\nfunction _getHistory() {\n  _getHistory = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee13(username) {\n    var proxy, history, _t11;\n    return _regenerator().w(function (_context13) {\n      while (1) switch (_context13.p = _context13.n) {\n        case 0:\n          _context13.p = 0;\n          _context13.n = 1;\n          return getProxy();\n        case 1:\n          proxy = _context13.v;\n          _context13.n = 2;\n          return proxy.getHistory(username);\n        case 2:\n          history = _context13.v;\n          return _context13.a(2, {\n            success: true,\n            history: history || []\n          });\n        case 3:\n          _context13.p = 3;\n          _t11 = _context13.v;\n          console.error('[ICE] Get history error:', _t11);\n          return _context13.a(2, {\n            success: false,\n            message: _t11.message\n          });\n      }\n    }, _callee13, null, [[0, 3]]);\n  }));\n  return _getHistory.apply(this, arguments);\n}\nfunction getPendingMessages(_x15) {\n  return _getPendingMessages.apply(this, arguments);\n}\n\n/**\r\n * Send voice note to user\r\n */\nfunction _getPendingMessages() {\n  _getPendingMessages = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee14(username) {\n    var proxy, messages, _t12;\n    return _regenerator().w(function (_context14) {\n      while (1) switch (_context14.p = _context14.n) {\n        case 0:\n          _context14.p = 0;\n          _context14.n = 1;\n          return getProxy();\n        case 1:\n          proxy = _context14.v;\n          _context14.n = 2;\n          return proxy.getPendingMessages(username);\n        case 2:\n          messages = _context14.v;\n          return _context14.a(2, {\n            success: true,\n            messages: messages || []\n          });\n        case 3:\n          _context14.p = 3;\n          _t12 = _context14.v;\n          console.error('[ICE] Get pending messages error:', _t12);\n          return _context14.a(2, {\n            success: false,\n            message: _t12.message\n          });\n      }\n    }, _callee14, null, [[0, 3]]);\n  }));\n  return _getPendingMessages.apply(this, arguments);\n}\nfunction sendVoiceNoteToUser(_x16, _x17, _x18) {\n  return _sendVoiceNoteToUser.apply(this, arguments);\n}\n\n/**\r\n * Send voice note to group\r\n */\nfunction _sendVoiceNoteToUser() {\n  _sendVoiceNoteToUser = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee15(from, to, audioData) {\n    var proxy, byteArray, response, _t13;\n    return _regenerator().w(function (_context15) {\n      while (1) switch (_context15.p = _context15.n) {\n        case 0:\n          _context15.p = 0;\n          _context15.n = 1;\n          return getProxy();\n        case 1:\n          proxy = _context15.v;\n          byteArray = audioData instanceof Uint8Array ? audioData : new Uint8Array(audioData);\n          _context15.n = 2;\n          return proxy.sendVoiceNoteToUser(from, to, byteArray);\n        case 2:\n          response = _context15.v;\n          return _context15.a(2, {\n            success: response.success,\n            message: response.message\n          });\n        case 3:\n          _context15.p = 3;\n          _t13 = _context15.v;\n          console.error('[ICE] Send voice note error:', _t13);\n          return _context15.a(2, {\n            success: false,\n            message: _t13.message\n          });\n      }\n    }, _callee15, null, [[0, 3]]);\n  }));\n  return _sendVoiceNoteToUser.apply(this, arguments);\n}\nfunction sendVoiceNoteToGroup(_x19, _x20, _x21) {\n  return _sendVoiceNoteToGroup.apply(this, arguments);\n}\n\n// ========== LLAMADAS WEBRTC ==========\n\n/**\r\n * Iniciar llamada a un usuario\r\n */\nfunction _sendVoiceNoteToGroup() {\n  _sendVoiceNoteToGroup = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee16(from, groupName, audioData) {\n    var proxy, byteArray, response, _t14;\n    return _regenerator().w(function (_context16) {\n      while (1) switch (_context16.p = _context16.n) {\n        case 0:\n          _context16.p = 0;\n          _context16.n = 1;\n          return getProxy();\n        case 1:\n          proxy = _context16.v;\n          byteArray = audioData instanceof Uint8Array ? audioData : new Uint8Array(audioData);\n          _context16.n = 2;\n          return proxy.sendVoiceNoteToGroup(from, groupName, byteArray);\n        case 2:\n          response = _context16.v;\n          return _context16.a(2, {\n            success: response.success,\n            message: response.message\n          });\n        case 3:\n          _context16.p = 3;\n          _t14 = _context16.v;\n          console.error('[ICE] Send group voice note error:', _t14);\n          return _context16.a(2, {\n            success: false,\n            message: _t14.message\n          });\n      }\n    }, _callee16, null, [[0, 3]]);\n  }));\n  return _sendVoiceNoteToGroup.apply(this, arguments);\n}\nfunction initiateCall(_x22, _x23) {\n  return _initiateCall.apply(this, arguments);\n}\n\n/**\r\n * Enviar seal WebRTC (offer/answer)\r\n */\nfunction _initiateCall() {\n  _initiateCall = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee17(from, to) {\n    var proxy, response, _t15;\n    return _regenerator().w(function (_context17) {\n      while (1) switch (_context17.p = _context17.n) {\n        case 0:\n          _context17.p = 0;\n          _context17.n = 1;\n          return getProxy();\n        case 1:\n          proxy = _context17.v;\n          _context17.n = 2;\n          return proxy.initiateCall(from, to);\n        case 2:\n          response = _context17.v;\n          return _context17.a(2, {\n            success: response.success,\n            message: response.message\n          });\n        case 3:\n          _context17.p = 3;\n          _t15 = _context17.v;\n          console.error('[ICE] Initiate call error:', _t15);\n          return _context17.a(2, {\n            success: false,\n            message: _t15.message\n          });\n      }\n    }, _callee17, null, [[0, 3]]);\n  }));\n  return _initiateCall.apply(this, arguments);\n}\nfunction sendWebRTCSignal(_x24, _x25, _x26, _x27) {\n  return _sendWebRTCSignal.apply(this, arguments);\n}\n\n/**\r\n * Enviar candidato ICE\r\n */\nfunction _sendWebRTCSignal() {\n  _sendWebRTCSignal = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee18(from, to, signalType, signalData) {\n    var proxy, response, _t16;\n    return _regenerator().w(function (_context18) {\n      while (1) switch (_context18.p = _context18.n) {\n        case 0:\n          _context18.p = 0;\n          _context18.n = 1;\n          return getProxy();\n        case 1:\n          proxy = _context18.v;\n          _context18.n = 2;\n          return proxy.sendWebRTCSignal(from, to, signalType, signalData);\n        case 2:\n          response = _context18.v;\n          return _context18.a(2, {\n            success: response.success,\n            message: response.message\n          });\n        case 3:\n          _context18.p = 3;\n          _t16 = _context18.v;\n          console.error('[ICE] Send WebRTC signal error:', _t16);\n          return _context18.a(2, {\n            success: false,\n            message: _t16.message\n          });\n      }\n    }, _callee18, null, [[0, 3]]);\n  }));\n  return _sendWebRTCSignal.apply(this, arguments);\n}\nfunction sendICECandidate(_x28, _x29, _x30) {\n  return _sendICECandidate.apply(this, arguments);\n}\n\n/**\r\n * Terminar llamada\r\n */\nfunction _sendICECandidate() {\n  _sendICECandidate = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee19(from, to, candidate) {\n    var proxy, response, _t17;\n    return _regenerator().w(function (_context19) {\n      while (1) switch (_context19.p = _context19.n) {\n        case 0:\n          _context19.p = 0;\n          _context19.n = 1;\n          return getProxy();\n        case 1:\n          proxy = _context19.v;\n          _context19.n = 2;\n          return proxy.sendICECandidate(from, to, candidate);\n        case 2:\n          response = _context19.v;\n          return _context19.a(2, {\n            success: response.success,\n            message: response.message\n          });\n        case 3:\n          _context19.p = 3;\n          _t17 = _context19.v;\n          console.error('[ICE] Send ICE candidate error:', _t17);\n          return _context19.a(2, {\n            success: false,\n            message: _t17.message\n          });\n      }\n    }, _callee19, null, [[0, 3]]);\n  }));\n  return _sendICECandidate.apply(this, arguments);\n}\nfunction endCall(_x31, _x32) {\n  return _endCall.apply(this, arguments);\n}\n\n/**\r\n * Enviar chunk de audio durante llamada\r\n */\nfunction _endCall() {\n  _endCall = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee20(from, to) {\n    var proxy, response, _t18;\n    return _regenerator().w(function (_context20) {\n      while (1) switch (_context20.p = _context20.n) {\n        case 0:\n          _context20.p = 0;\n          _context20.n = 1;\n          return getProxy();\n        case 1:\n          proxy = _context20.v;\n          _context20.n = 2;\n          return proxy.endCall(from, to);\n        case 2:\n          response = _context20.v;\n          return _context20.a(2, {\n            success: response.success,\n            message: response.message\n          });\n        case 3:\n          _context20.p = 3;\n          _t18 = _context20.v;\n          console.error('[ICE] End call error:', _t18);\n          return _context20.a(2, {\n            success: false,\n            message: _t18.message\n          });\n      }\n    }, _callee20, null, [[0, 3]]);\n  }));\n  return _endCall.apply(this, arguments);\n}\nfunction sendAudioChunk(_x33, _x34, _x35) {\n  return _sendAudioChunk.apply(this, arguments);\n}\n\n/**\r\n * Aceptar llamada\r\n */\nfunction _sendAudioChunk() {\n  _sendAudioChunk = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee21(from, to, audioData) {\n    var proxy, byteArray, response, _t19;\n    return _regenerator().w(function (_context21) {\n      while (1) switch (_context21.p = _context21.n) {\n        case 0:\n          _context21.p = 0;\n          _context21.n = 1;\n          return getProxy();\n        case 1:\n          proxy = _context21.v;\n          byteArray = audioData instanceof Uint8Array ? audioData : new Uint8Array(audioData);\n          _context21.n = 2;\n          return proxy.sendAudioChunk(from, to, byteArray);\n        case 2:\n          response = _context21.v;\n          return _context21.a(2, {\n            success: response.success,\n            message: response.message\n          });\n        case 3:\n          _context21.p = 3;\n          _t19 = _context21.v;\n          console.error('[ICE] Send audio chunk error:', _t19);\n          return _context21.a(2, {\n            success: false,\n            message: _t19.message\n          });\n      }\n    }, _callee21, null, [[0, 3]]);\n  }));\n  return _sendAudioChunk.apply(this, arguments);\n}\nfunction acceptCall(_x36, _x37) {\n  return _acceptCall.apply(this, arguments);\n}\nfunction _acceptCall() {\n  _acceptCall = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee22(from, to) {\n    var proxy, response, _t20;\n    return _regenerator().w(function (_context22) {\n      while (1) switch (_context22.p = _context22.n) {\n        case 0:\n          _context22.p = 0;\n          _context22.n = 1;\n          return getProxy();\n        case 1:\n          proxy = _context22.v;\n          _context22.n = 2;\n          return proxy.acceptCall(from, to);\n        case 2:\n          response = _context22.v;\n          return _context22.a(2, {\n            success: response.success,\n            message: response.message\n          });\n        case 3:\n          _context22.p = 3;\n          _t20 = _context22.v;\n          console.error('[ICE] Accept call error:', _t20);\n          return _context22.a(2, {\n            success: false,\n            message: _t20.message\n          });\n      }\n    }, _callee22, null, [[0, 3]]);\n  }));\n  return _acceptCall.apply(this, arguments);\n}\n\n//# sourceURL=webpack://chat-web-client/./src/services/iceDelegate.js?\n}");

/***/ }),

/***/ "./src/services/webrtcService.js":
/*!***************************************!*\
  !*** ./src/services/webrtcService.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   answerCall: () => (/* binding */ answerCall),\n/* harmony export */   getLocalStream: () => (/* binding */ getLocalStream),\n/* harmony export */   hangUp: () => (/* binding */ hangUp),\n/* harmony export */   initWebRTC: () => (/* binding */ initWebRTC),\n/* harmony export */   receiveAudioChunk: () => (/* binding */ receiveAudioChunk),\n/* harmony export */   startCall: () => (/* binding */ startCall)\n/* harmony export */ });\n/* harmony import */ var _iceDelegate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./iceDelegate.js */ \"./src/services/iceDelegate.js\");\nfunction _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = \"function\" == typeof Symbol ? Symbol : {}, n = r.iterator || \"@@iterator\", o = r.toStringTag || \"@@toStringTag\"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, \"_invoke\", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError(\"Generator is already running\"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = \"next\"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError(\"iterator result is not an object\"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i[\"return\"]) && t.call(i), c < 2 && (u = TypeError(\"The iterator does not provide a '\" + o + \"' method\"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, \"GeneratorFunction\")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, \"constructor\", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = \"GeneratorFunction\", _regeneratorDefine2(GeneratorFunctionPrototype, o, \"GeneratorFunction\"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, \"Generator\"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, \"toString\", function () { return \"[object Generator]\"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }\nfunction _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, \"\", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o(\"next\", 0), o(\"throw\", 1), o(\"return\", 2)); }, _regeneratorDefine2(e, r, n, t); }\nfunction asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"next\", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"throw\", n); } _next(void 0); }); }; }\n/**\r\n * Audio Streaming Service - Manejo de llamadas de audio va WebSocket\r\n */\n\n\nvar localStream = null;\nvar remoteUsername = null;\nvar currentUsername = null;\nvar mediaRecorder = null;\nvar isStreaming = false;\nvar audioContext = null;\nvar audioQueue = [];\nvar isPlaying = false;\nvar audioElement = null;\nvar sourceBuffer = null;\nvar mediaSource = null;\nvar pendingChunks = [];\n\n/**\r\n * Inicializar el servicio WebRTC\r\n */\nfunction initWebRTC(username) {\n  currentUsername = username;\n  console.log('[WebRTC] Service initialized for user:', username);\n}\n\n/**\r\n * Iniciar llamada (iniciar streaming de audio)\r\n */\nfunction startCall(_x, _x2) {\n  return _startCall.apply(this, arguments);\n}\n\n/**\r\n * Iniciar streaming de audio por WebSocket\r\n */\nfunction _startCall() {\n  _startCall = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(from, to) {\n    var audioOnly,\n      constraints,\n      _args = arguments,\n      _t;\n    return _regenerator().w(function (_context) {\n      while (1) switch (_context.p = _context.n) {\n        case 0:\n          audioOnly = _args.length > 2 && _args[2] !== undefined ? _args[2] : false;\n          _context.p = 1;\n          console.log('[AUDIO-WS] Starting call from', from, 'to', to);\n          remoteUsername = to;\n          currentUsername = from;\n\n          // Desbloquear autoplay con audio silencioso (user interaction)\n          _context.n = 2;\n          return unlockAudioPlayback();\n        case 2:\n          _context.n = 3;\n          return initMediaSource();\n        case 3:\n          // Obtener stream local\n          constraints = {\n            audio: true,\n            video: false\n          };\n          _context.n = 4;\n          return navigator.mediaDevices.getUserMedia(constraints);\n        case 4:\n          localStream = _context.v;\n          console.log('[AUDIO-WS] Local stream obtained');\n\n          // Iniciar streaming de audio\n          _context.n = 5;\n          return startAudioStreaming(from, to);\n        case 5:\n          return _context.a(2, {\n            success: true,\n            localStream: localStream\n          });\n        case 6:\n          _context.p = 6;\n          _t = _context.v;\n          console.error('[AUDIO-WS] Error starting call:', _t);\n          return _context.a(2, {\n            success: false,\n            error: _t.message\n          });\n      }\n    }, _callee, null, [[1, 6]]);\n  }));\n  return _startCall.apply(this, arguments);\n}\nfunction startAudioStreaming(_x3, _x4) {\n  return _startAudioStreaming.apply(this, arguments);\n}\n/**\r\n * Responder a una llamada entrante\r\n */\nfunction _startAudioStreaming() {\n  _startAudioStreaming = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3(from, to) {\n    var options, _t2;\n    return _regenerator().w(function (_context3) {\n      while (1) switch (_context3.p = _context3.n) {\n        case 0:\n          _context3.p = 0;\n          // Configurar MediaRecorder para capturar audio en chunks pequeos\n          options = {\n            mimeType: 'audio/webm;codecs=opus'\n          };\n          mediaRecorder = new MediaRecorder(localStream, options);\n\n          // Enviar chunks de audio en tiempo real\n          mediaRecorder.ondataavailable = /*#__PURE__*/function () {\n            var _ref = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(event) {\n              var arrayBuffer, uint8Array;\n              return _regenerator().w(function (_context2) {\n                while (1) switch (_context2.n) {\n                  case 0:\n                    if (!(event.data.size > 0 && isStreaming)) {\n                      _context2.n = 3;\n                      break;\n                    }\n                    _context2.n = 1;\n                    return event.data.arrayBuffer();\n                  case 1:\n                    arrayBuffer = _context2.v;\n                    uint8Array = new Uint8Array(arrayBuffer); // Enviar chunk por WebSocket\n                    _context2.n = 2;\n                    return (0,_iceDelegate_js__WEBPACK_IMPORTED_MODULE_0__.sendAudioChunk)(from, to, uint8Array);\n                  case 2:\n                    console.log('[AUDIO-WS] Sent audio chunk:', uint8Array.length, 'bytes');\n                  case 3:\n                    return _context2.a(2);\n                }\n              }, _callee2);\n            }));\n            return function (_x0) {\n              return _ref.apply(this, arguments);\n            };\n          }();\n          mediaRecorder.onstart = function () {\n            console.log('[AUDIO-WS]  Audio streaming started');\n            isStreaming = true;\n          };\n          mediaRecorder.onstop = function () {\n            console.log('[AUDIO-WS]  Audio streaming stopped');\n            isStreaming = false;\n          };\n\n          // Iniciar grabacin con chunks de 500ms \n          // (necesario para que cada chunk tenga headers WebM vlidos)\n          mediaRecorder.start(500);\n          _context3.n = 2;\n          break;\n        case 1:\n          _context3.p = 1;\n          _t2 = _context3.v;\n          console.error('[AUDIO-WS] Error starting audio streaming:', _t2);\n          throw _t2;\n        case 2:\n          return _context3.a(2);\n      }\n    }, _callee3, null, [[0, 1]]);\n  }));\n  return _startAudioStreaming.apply(this, arguments);\n}\nfunction answerCall(_x5, _x6) {\n  return _answerCall.apply(this, arguments);\n}\n\n/**\r\n * Desbloquear reproduccin de audio (soluciona NotAllowedError)\r\n */\nfunction _answerCall() {\n  _answerCall = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(from, to) {\n    var audioOnly,\n      constraints,\n      _args4 = arguments,\n      _t3;\n    return _regenerator().w(function (_context4) {\n      while (1) switch (_context4.p = _context4.n) {\n        case 0:\n          audioOnly = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : false;\n          _context4.p = 1;\n          console.log('[AUDIO-WS] Answering call from', from);\n          remoteUsername = from;\n          currentUsername = to;\n\n          // Desbloquear autoplay con audio silencioso (user interaction)\n          _context4.n = 2;\n          return unlockAudioPlayback();\n        case 2:\n          _context4.n = 3;\n          return initMediaSource();\n        case 3:\n          // Obtener stream local\n          constraints = {\n            audio: true,\n            video: false\n          };\n          _context4.n = 4;\n          return navigator.mediaDevices.getUserMedia(constraints);\n        case 4:\n          localStream = _context4.v;\n          console.log('[AUDIO-WS] Local stream obtained');\n\n          // Notificar aceptacin al servidor\n          _context4.n = 5;\n          return (0,_iceDelegate_js__WEBPACK_IMPORTED_MODULE_0__.acceptCall)(to, from);\n        case 5:\n          _context4.n = 6;\n          return startAudioStreaming(to, from);\n        case 6:\n          return _context4.a(2, {\n            success: true,\n            localStream: localStream\n          });\n        case 7:\n          _context4.p = 7;\n          _t3 = _context4.v;\n          console.error('[AUDIO-WS] Error answering call:', _t3);\n          return _context4.a(2, {\n            success: false,\n            error: _t3.message\n          });\n      }\n    }, _callee4, null, [[1, 7]]);\n  }));\n  return _answerCall.apply(this, arguments);\n}\nfunction unlockAudioPlayback() {\n  return _unlockAudioPlayback.apply(this, arguments);\n}\n/**\r\n * Inicializar MediaSource para streaming de audio\r\n */\nfunction _unlockAudioPlayback() {\n  _unlockAudioPlayback = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5() {\n    var buffer, source;\n    return _regenerator().w(function (_context5) {\n      while (1) switch (_context5.n) {\n        case 0:\n          try {\n            // Crear audio context y reproducir silencio brevemente\n            if (!audioContext) {\n              audioContext = new (window.AudioContext || window.webkitAudioContext)();\n            }\n\n            // Crear buffer de silencio\n            buffer = audioContext.createBuffer(1, 1, 22050);\n            source = audioContext.createBufferSource();\n            source.buffer = buffer;\n            source.connect(audioContext.destination);\n            source.start(0);\n            console.log('[AUDIO-WS] Audio playback unlocked');\n          } catch (error) {\n            console.warn('[AUDIO-WS] Could not unlock audio:', error);\n          }\n        case 1:\n          return _context5.a(2);\n      }\n    }, _callee5);\n  }));\n  return _unlockAudioPlayback.apply(this, arguments);\n}\nfunction initMediaSource() {\n  return new Promise(function (resolve, reject) {\n    if (audioElement && mediaSource && mediaSource.readyState === 'open') {\n      resolve();\n      return;\n    }\n\n    // Limpiar existentes\n    if (audioElement) {\n      audioElement.pause();\n      audioElement.src = '';\n    }\n    audioElement = new Audio();\n    audioElement.autoplay = true;\n    audioElement.volume = 1.0;\n    mediaSource = new MediaSource();\n    audioElement.src = URL.createObjectURL(mediaSource);\n    mediaSource.addEventListener('sourceopen', function () {\n      if (mediaSource.readyState === 'open' && !sourceBuffer) {\n        try {\n          sourceBuffer = mediaSource.addSourceBuffer('audio/webm; codecs=\"opus\"');\n          sourceBuffer.mode = 'sequence';\n          sourceBuffer.addEventListener('updateend', function () {\n            if (pendingChunks.length > 0 && !sourceBuffer.updating) {\n              var nextChunk = pendingChunks.shift();\n              try {\n                sourceBuffer.appendBuffer(nextChunk);\n              } catch (e) {\n                console.warn('[AUDIO-WS] Error appending queued chunk:', e.message);\n              }\n            }\n          });\n          sourceBuffer.addEventListener('error', function (e) {\n            console.error('[AUDIO-WS] SourceBuffer error:', e);\n          });\n          console.log('[AUDIO-WS] MediaSource initialized for streaming');\n          resolve();\n        } catch (error) {\n          console.error('[AUDIO-WS] Error creating SourceBuffer:', error);\n          reject(error);\n        }\n      }\n    });\n    mediaSource.addEventListener('sourceended', function () {\n      console.log('[AUDIO-WS] MediaSource ended');\n    });\n    mediaSource.addEventListener('error', function (e) {\n      console.error('[AUDIO-WS] MediaSource error:', e);\n      reject(e);\n    });\n\n    // Timeout si no se inicializa en 5 segundos\n    setTimeout(function () {\n      if (!sourceBuffer) {\n        reject(new Error('MediaSource initialization timeout'));\n      }\n    }, 5000);\n  });\n}\n\n/**\r\n * Recibir y reproducir chunk de audio\r\n */\nfunction receiveAudioChunk(_x7) {\n  return _receiveAudioChunk.apply(this, arguments);\n}\n\n/**\r\n * Terminar llamada\r\n */\nfunction _receiveAudioChunk() {\n  _receiveAudioChunk = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6(audioData) {\n    var _t4;\n    return _regenerator().w(function (_context6) {\n      while (1) switch (_context6.p = _context6.n) {\n        case 0:\n          _context6.p = 0;\n          if (!(audioData.length < 100)) {\n            _context6.n = 1;\n            break;\n          }\n          return _context6.a(2);\n        case 1:\n          if (!(!mediaSource || mediaSource.readyState !== 'open')) {\n            _context6.n = 3;\n            break;\n          }\n          pendingChunks.push(audioData);\n          if (mediaSource) {\n            _context6.n = 2;\n            break;\n          }\n          _context6.n = 2;\n          return initMediaSource();\n        case 2:\n          return _context6.a(2);\n        case 3:\n          // Si sourceBuffer est listo y no est actualizando\n          if (sourceBuffer && !sourceBuffer.updating && mediaSource.readyState === 'open') {\n            try {\n              sourceBuffer.appendBuffer(audioData);\n              console.log('[AUDIO-WS]  Appended audio chunk:', audioData.length, 'bytes');\n            } catch (error) {\n              console.warn('[AUDIO-WS] Error appending chunk:', error.message);\n              // Si falla, agregar a cola\n              pendingChunks.push(audioData);\n            }\n          } else {\n            // Agregar a cola de pendientes\n            pendingChunks.push(audioData);\n          }\n          _context6.n = 5;\n          break;\n        case 4:\n          _context6.p = 4;\n          _t4 = _context6.v;\n          console.error('[AUDIO-WS] Error receiving audio chunk:', _t4);\n        case 5:\n          return _context6.a(2);\n      }\n    }, _callee6, null, [[0, 4]]);\n  }));\n  return _receiveAudioChunk.apply(this, arguments);\n}\nfunction hangUp(_x8, _x9) {\n  return _hangUp.apply(this, arguments);\n}\n\n/**\r\n * Obtener stream local actual\r\n */\nfunction _hangUp() {\n  _hangUp = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee7(from, to) {\n    var _t5;\n    return _regenerator().w(function (_context7) {\n      while (1) switch (_context7.p = _context7.n) {\n        case 0:\n          _context7.p = 0;\n          console.log('[AUDIO-WS] Hanging up call');\n\n          // Detener streaming\n          if (mediaRecorder && mediaRecorder.state !== 'inactive') {\n            mediaRecorder.stop();\n          }\n          isStreaming = false;\n\n          // Detener tracks locales\n          if (localStream) {\n            localStream.getTracks().forEach(function (track) {\n              return track.stop();\n            });\n            localStream = null;\n          }\n\n          // Limpiar MediaSource\n          if (mediaSource && mediaSource.readyState === 'open') {\n            try {\n              mediaSource.endOfStream();\n            } catch (e) {}\n          }\n          if (audioElement) {\n            audioElement.pause();\n            audioElement.src = '';\n            audioElement = null;\n          }\n          mediaSource = null;\n          sourceBuffer = null;\n          pendingChunks = [];\n\n          // Limpiar colas de audio\n          audioQueue = [];\n          isPlaying = false;\n\n          // Cerrar AudioContext\n          if (!(audioContext && audioContext.state !== 'closed')) {\n            _context7.n = 2;\n            break;\n          }\n          _context7.n = 1;\n          return audioContext.close();\n        case 1:\n          audioContext = null;\n        case 2:\n          if (!to) {\n            _context7.n = 3;\n            break;\n          }\n          _context7.n = 3;\n          return (0,_iceDelegate_js__WEBPACK_IMPORTED_MODULE_0__.endCall)(from, to);\n        case 3:\n          // Limpiar UI\n          clearCallUI();\n          console.log('[AUDIO-WS] Call ended');\n          _context7.n = 5;\n          break;\n        case 4:\n          _context7.p = 4;\n          _t5 = _context7.v;\n          console.error('[AUDIO-WS] Error hanging up:', _t5);\n        case 5:\n          return _context7.a(2);\n      }\n    }, _callee7, null, [[0, 4]]);\n  }));\n  return _hangUp.apply(this, arguments);\n}\nfunction getLocalStream() {\n  return localStream;\n}\n\n/**\r\n * Mostrar indicador de audio remoto en la UI\r\n */\nfunction displayRemoteStream() {\n  console.log('[AUDIO-WS] Audio streaming active');\n  var remoteAudioIndicator = document.getElementById('remoteAudioIndicator');\n  if (remoteAudioIndicator) {\n    remoteAudioIndicator.style.display = 'block';\n    remoteAudioIndicator.innerHTML = ' Recibiendo audio...';\n  }\n}\n\n/**\r\n * Limpiar UI de llamada\r\n */\nfunction clearCallUI() {\n  var remoteVideo = document.getElementById('remoteVideo');\n  if (remoteVideo) {\n    remoteVideo.srcObject = null;\n    remoteVideo.remove();\n  }\n  var localVideo = document.getElementById('localVideo');\n  if (localVideo) {\n    localVideo.srcObject = null;\n  }\n}\n\n//# sourceURL=webpack://chat-web-client/./src/services/webrtcService.js?\n}");

/***/ }),

/***/ "?3c7e":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

eval("{/* (ignored) */\n\n//# sourceURL=webpack://chat-web-client/fs_(ignored)?\n}");

/***/ }),

/***/ "?c885":
/*!*********************!*\
  !*** net (ignored) ***!
  \*********************/
/***/ (() => {

eval("{/* (ignored) */\n\n//# sourceURL=webpack://chat-web-client/net_(ignored)?\n}");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	__webpack_require__("./index.js");
/******/ 	var __webpack_exports__ = __webpack_require__("./index.css");
/******/ 	
/******/ })()
;